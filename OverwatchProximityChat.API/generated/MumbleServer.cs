//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `MumbleServer.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//


using _System = global::System;

#pragma warning disable 1591

namespace Murmur
{
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    [global::System.Serializable]
    public partial class User : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int session;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int userid;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public bool mute;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public bool deaf;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public bool suppress;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public bool prioritySpeaker;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public bool selfMute;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public bool selfDeaf;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public bool recording;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int channel;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string name;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int onlinesecs;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int bytespersec;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int version;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string release;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string os;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string osversion;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string identity;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string context;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string comment;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public byte[] address;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public bool tcponly;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int idlesecs;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public float udpPing;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public float tcpPing;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public User()
        {
            this.name = "";
            this.release = "";
            this.os = "";
            this.osversion = "";
            this.identity = "";
            this.context = "";
            this.comment = "";
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public User(int session, int userid, bool mute, bool deaf, bool suppress, bool prioritySpeaker, bool selfMute, bool selfDeaf, bool recording, int channel, string name, int onlinesecs, int bytespersec, int version, string release, string os, string osversion, string identity, string context, string comment, byte[] address, bool tcponly, int idlesecs, float udpPing, float tcpPing)
        {
            this.session = session;
            this.userid = userid;
            this.mute = mute;
            this.deaf = deaf;
            this.suppress = suppress;
            this.prioritySpeaker = prioritySpeaker;
            this.selfMute = selfMute;
            this.selfDeaf = selfDeaf;
            this.recording = recording;
            this.channel = channel;
            this.name = name;
            this.onlinesecs = onlinesecs;
            this.bytespersec = bytespersec;
            this.version = version;
            this.release = release;
            this.os = os;
            this.osversion = osversion;
            this.identity = identity;
            this.context = context;
            this.comment = comment;
            this.address = address;
            this.tcponly = tcponly;
            this.idlesecs = idlesecs;
            this.udpPing = udpPing;
            this.tcpPing = tcpPing;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::User");
            global::IceInternal.HashUtil.hashAdd(ref h_, session);
            global::IceInternal.HashUtil.hashAdd(ref h_, userid);
            global::IceInternal.HashUtil.hashAdd(ref h_, mute);
            global::IceInternal.HashUtil.hashAdd(ref h_, deaf);
            global::IceInternal.HashUtil.hashAdd(ref h_, suppress);
            global::IceInternal.HashUtil.hashAdd(ref h_, prioritySpeaker);
            global::IceInternal.HashUtil.hashAdd(ref h_, selfMute);
            global::IceInternal.HashUtil.hashAdd(ref h_, selfDeaf);
            global::IceInternal.HashUtil.hashAdd(ref h_, recording);
            global::IceInternal.HashUtil.hashAdd(ref h_, channel);
            global::IceInternal.HashUtil.hashAdd(ref h_, name);
            global::IceInternal.HashUtil.hashAdd(ref h_, onlinesecs);
            global::IceInternal.HashUtil.hashAdd(ref h_, bytespersec);
            global::IceInternal.HashUtil.hashAdd(ref h_, version);
            global::IceInternal.HashUtil.hashAdd(ref h_, release);
            global::IceInternal.HashUtil.hashAdd(ref h_, os);
            global::IceInternal.HashUtil.hashAdd(ref h_, osversion);
            global::IceInternal.HashUtil.hashAdd(ref h_, identity);
            global::IceInternal.HashUtil.hashAdd(ref h_, context);
            global::IceInternal.HashUtil.hashAdd(ref h_, comment);
            global::IceInternal.HashUtil.hashAdd(ref h_, address);
            global::IceInternal.HashUtil.hashAdd(ref h_, tcponly);
            global::IceInternal.HashUtil.hashAdd(ref h_, idlesecs);
            global::IceInternal.HashUtil.hashAdd(ref h_, udpPing);
            global::IceInternal.HashUtil.hashAdd(ref h_, tcpPing);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            User o = (User)other;
            if(!this.session.Equals(o.session))
            {
                return false;
            }
            if(!this.userid.Equals(o.userid))
            {
                return false;
            }
            if(!this.mute.Equals(o.mute))
            {
                return false;
            }
            if(!this.deaf.Equals(o.deaf))
            {
                return false;
            }
            if(!this.suppress.Equals(o.suppress))
            {
                return false;
            }
            if(!this.prioritySpeaker.Equals(o.prioritySpeaker))
            {
                return false;
            }
            if(!this.selfMute.Equals(o.selfMute))
            {
                return false;
            }
            if(!this.selfDeaf.Equals(o.selfDeaf))
            {
                return false;
            }
            if(!this.recording.Equals(o.recording))
            {
                return false;
            }
            if(!this.channel.Equals(o.channel))
            {
                return false;
            }
            if(this.name == null)
            {
                if(o.name != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.name.Equals(o.name))
                {
                    return false;
                }
            }
            if(!this.onlinesecs.Equals(o.onlinesecs))
            {
                return false;
            }
            if(!this.bytespersec.Equals(o.bytespersec))
            {
                return false;
            }
            if(!this.version.Equals(o.version))
            {
                return false;
            }
            if(this.release == null)
            {
                if(o.release != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.release.Equals(o.release))
                {
                    return false;
                }
            }
            if(this.os == null)
            {
                if(o.os != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.os.Equals(o.os))
                {
                    return false;
                }
            }
            if(this.osversion == null)
            {
                if(o.osversion != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.osversion.Equals(o.osversion))
                {
                    return false;
                }
            }
            if(this.identity == null)
            {
                if(o.identity != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.identity.Equals(o.identity))
                {
                    return false;
                }
            }
            if(this.context == null)
            {
                if(o.context != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.context.Equals(o.context))
                {
                    return false;
                }
            }
            if(this.comment == null)
            {
                if(o.comment != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.comment.Equals(o.comment))
                {
                    return false;
                }
            }
            if(this.address == null)
            {
                if(o.address != null)
                {
                    return false;
                }
            }
            else
            {
                if(!IceUtilInternal.Arrays.Equals(this.address, o.address))
                {
                    return false;
                }
            }
            if(!this.tcponly.Equals(o.tcponly))
            {
                return false;
            }
            if(!this.idlesecs.Equals(o.idlesecs))
            {
                return false;
            }
            if(!this.udpPing.Equals(o.udpPing))
            {
                return false;
            }
            if(!this.tcpPing.Equals(o.tcpPing))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(User lhs, User rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(User lhs, User rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            ostr.writeInt(this.session);
            ostr.writeInt(this.userid);
            ostr.writeBool(this.mute);
            ostr.writeBool(this.deaf);
            ostr.writeBool(this.suppress);
            ostr.writeBool(this.prioritySpeaker);
            ostr.writeBool(this.selfMute);
            ostr.writeBool(this.selfDeaf);
            ostr.writeBool(this.recording);
            ostr.writeInt(this.channel);
            ostr.writeString(this.name);
            ostr.writeInt(this.onlinesecs);
            ostr.writeInt(this.bytespersec);
            ostr.writeInt(this.version);
            ostr.writeString(this.release);
            ostr.writeString(this.os);
            ostr.writeString(this.osversion);
            ostr.writeString(this.identity);
            ostr.writeString(this.context);
            ostr.writeString(this.comment);
            NetAddressHelper.write(ostr, this.address);
            ostr.writeBool(this.tcponly);
            ostr.writeInt(this.idlesecs);
            ostr.writeFloat(this.udpPing);
            ostr.writeFloat(this.tcpPing);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.session = istr.readInt();
            this.userid = istr.readInt();
            this.mute = istr.readBool();
            this.deaf = istr.readBool();
            this.suppress = istr.readBool();
            this.prioritySpeaker = istr.readBool();
            this.selfMute = istr.readBool();
            this.selfDeaf = istr.readBool();
            this.recording = istr.readBool();
            this.channel = istr.readInt();
            this.name = istr.readString();
            this.onlinesecs = istr.readInt();
            this.bytespersec = istr.readInt();
            this.version = istr.readInt();
            this.release = istr.readString();
            this.os = istr.readString();
            this.osversion = istr.readString();
            this.identity = istr.readString();
            this.context = istr.readString();
            this.comment = istr.readString();
            this.address = NetAddressHelper.read(istr);
            this.tcponly = istr.readBool();
            this.idlesecs = istr.readInt();
            this.udpPing = istr.readFloat();
            this.tcpPing = istr.readFloat();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static void ice_write(global::Ice.OutputStream ostr, User v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static User ice_read(global::Ice.InputStream istr)
        {
            var v = new User();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly User _nullMarshalValue = new User();

        #endregion
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    [global::System.Serializable]
    public partial class TextMessage : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int[] sessions;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int[] channels;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int[] trees;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string text;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public TextMessage()
        {
            this.text = "";
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public TextMessage(int[] sessions, int[] channels, int[] trees, string text)
        {
            this.sessions = sessions;
            this.channels = channels;
            this.trees = trees;
            this.text = text;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::TextMessage");
            global::IceInternal.HashUtil.hashAdd(ref h_, sessions);
            global::IceInternal.HashUtil.hashAdd(ref h_, channels);
            global::IceInternal.HashUtil.hashAdd(ref h_, trees);
            global::IceInternal.HashUtil.hashAdd(ref h_, text);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            TextMessage o = (TextMessage)other;
            if(this.sessions == null)
            {
                if(o.sessions != null)
                {
                    return false;
                }
            }
            else
            {
                if(!IceUtilInternal.Arrays.Equals(this.sessions, o.sessions))
                {
                    return false;
                }
            }
            if(this.channels == null)
            {
                if(o.channels != null)
                {
                    return false;
                }
            }
            else
            {
                if(!IceUtilInternal.Arrays.Equals(this.channels, o.channels))
                {
                    return false;
                }
            }
            if(this.trees == null)
            {
                if(o.trees != null)
                {
                    return false;
                }
            }
            else
            {
                if(!IceUtilInternal.Arrays.Equals(this.trees, o.trees))
                {
                    return false;
                }
            }
            if(this.text == null)
            {
                if(o.text != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.text.Equals(o.text))
                {
                    return false;
                }
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(TextMessage lhs, TextMessage rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(TextMessage lhs, TextMessage rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            IntListHelper.write(ostr, this.sessions);
            IntListHelper.write(ostr, this.channels);
            IntListHelper.write(ostr, this.trees);
            ostr.writeString(this.text);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.sessions = IntListHelper.read(istr);
            this.channels = IntListHelper.read(istr);
            this.trees = IntListHelper.read(istr);
            this.text = istr.readString();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static void ice_write(global::Ice.OutputStream ostr, TextMessage v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static TextMessage ice_read(global::Ice.InputStream istr)
        {
            var v = new TextMessage();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly TextMessage _nullMarshalValue = new TextMessage();

        #endregion
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    [global::System.Serializable]
    public partial class Channel : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int id;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string name;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int parent;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int[] links;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string description;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public bool temporary;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int position;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public Channel()
        {
            this.name = "";
            this.description = "";
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public Channel(int id, string name, int parent, int[] links, string description, bool temporary, int position)
        {
            this.id = id;
            this.name = name;
            this.parent = parent;
            this.links = links;
            this.description = description;
            this.temporary = temporary;
            this.position = position;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::Channel");
            global::IceInternal.HashUtil.hashAdd(ref h_, id);
            global::IceInternal.HashUtil.hashAdd(ref h_, name);
            global::IceInternal.HashUtil.hashAdd(ref h_, parent);
            global::IceInternal.HashUtil.hashAdd(ref h_, links);
            global::IceInternal.HashUtil.hashAdd(ref h_, description);
            global::IceInternal.HashUtil.hashAdd(ref h_, temporary);
            global::IceInternal.HashUtil.hashAdd(ref h_, position);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            Channel o = (Channel)other;
            if(!this.id.Equals(o.id))
            {
                return false;
            }
            if(this.name == null)
            {
                if(o.name != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.name.Equals(o.name))
                {
                    return false;
                }
            }
            if(!this.parent.Equals(o.parent))
            {
                return false;
            }
            if(this.links == null)
            {
                if(o.links != null)
                {
                    return false;
                }
            }
            else
            {
                if(!IceUtilInternal.Arrays.Equals(this.links, o.links))
                {
                    return false;
                }
            }
            if(this.description == null)
            {
                if(o.description != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.description.Equals(o.description))
                {
                    return false;
                }
            }
            if(!this.temporary.Equals(o.temporary))
            {
                return false;
            }
            if(!this.position.Equals(o.position))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(Channel lhs, Channel rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(Channel lhs, Channel rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            ostr.writeInt(this.id);
            ostr.writeString(this.name);
            ostr.writeInt(this.parent);
            IntListHelper.write(ostr, this.links);
            ostr.writeString(this.description);
            ostr.writeBool(this.temporary);
            ostr.writeInt(this.position);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.id = istr.readInt();
            this.name = istr.readString();
            this.parent = istr.readInt();
            this.links = IntListHelper.read(istr);
            this.description = istr.readString();
            this.temporary = istr.readBool();
            this.position = istr.readInt();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static void ice_write(global::Ice.OutputStream ostr, Channel v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static Channel ice_read(global::Ice.InputStream istr)
        {
            var v = new Channel();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly Channel _nullMarshalValue = new Channel();

        #endregion
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    [global::System.Serializable]
    public partial class Group : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string name;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public bool inherited;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public bool inherit;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public bool inheritable;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int[] add;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int[] remove;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int[] members;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public Group()
        {
            this.name = "";
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public Group(string name, bool inherited, bool inherit, bool inheritable, int[] add, int[] remove, int[] members)
        {
            this.name = name;
            this.inherited = inherited;
            this.inherit = inherit;
            this.inheritable = inheritable;
            this.add = add;
            this.remove = remove;
            this.members = members;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::Group");
            global::IceInternal.HashUtil.hashAdd(ref h_, name);
            global::IceInternal.HashUtil.hashAdd(ref h_, inherited);
            global::IceInternal.HashUtil.hashAdd(ref h_, inherit);
            global::IceInternal.HashUtil.hashAdd(ref h_, inheritable);
            global::IceInternal.HashUtil.hashAdd(ref h_, add);
            global::IceInternal.HashUtil.hashAdd(ref h_, remove);
            global::IceInternal.HashUtil.hashAdd(ref h_, members);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            Group o = (Group)other;
            if(this.name == null)
            {
                if(o.name != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.name.Equals(o.name))
                {
                    return false;
                }
            }
            if(!this.inherited.Equals(o.inherited))
            {
                return false;
            }
            if(!this.inherit.Equals(o.inherit))
            {
                return false;
            }
            if(!this.inheritable.Equals(o.inheritable))
            {
                return false;
            }
            if(this.add == null)
            {
                if(o.add != null)
                {
                    return false;
                }
            }
            else
            {
                if(!IceUtilInternal.Arrays.Equals(this.add, o.add))
                {
                    return false;
                }
            }
            if(this.remove == null)
            {
                if(o.remove != null)
                {
                    return false;
                }
            }
            else
            {
                if(!IceUtilInternal.Arrays.Equals(this.remove, o.remove))
                {
                    return false;
                }
            }
            if(this.members == null)
            {
                if(o.members != null)
                {
                    return false;
                }
            }
            else
            {
                if(!IceUtilInternal.Arrays.Equals(this.members, o.members))
                {
                    return false;
                }
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(Group lhs, Group rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(Group lhs, Group rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            ostr.writeString(this.name);
            ostr.writeBool(this.inherited);
            ostr.writeBool(this.inherit);
            ostr.writeBool(this.inheritable);
            IntListHelper.write(ostr, this.add);
            IntListHelper.write(ostr, this.remove);
            IntListHelper.write(ostr, this.members);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.name = istr.readString();
            this.inherited = istr.readBool();
            this.inherit = istr.readBool();
            this.inheritable = istr.readBool();
            this.add = IntListHelper.read(istr);
            this.remove = IntListHelper.read(istr);
            this.members = IntListHelper.read(istr);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static void ice_write(global::Ice.OutputStream ostr, Group v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static Group ice_read(global::Ice.InputStream istr)
        {
            var v = new Group();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly Group _nullMarshalValue = new Group();

        #endregion
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class PermissionWrite
    {
        public const int value = 1;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class PermissionTraverse
    {
        public const int value = 2;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class PermissionEnter
    {
        public const int value = 4;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class PermissionSpeak
    {
        public const int value = 8;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class PermissionWhisper
    {
        public const int value = 256;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class PermissionMuteDeafen
    {
        public const int value = 16;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class PermissionMove
    {
        public const int value = 32;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class PermissionMakeChannel
    {
        public const int value = 64;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class PermissionMakeTempChannel
    {
        public const int value = 1024;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class PermissionLinkChannel
    {
        public const int value = 128;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class PermissionTextMessage
    {
        public const int value = 512;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class PermissionKick
    {
        public const int value = 65536;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class PermissionBan
    {
        public const int value = 131072;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class PermissionRegister
    {
        public const int value = 262144;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class PermissionRegisterSelf
    {
        public const int value = 524288;
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    [global::System.Serializable]
    public partial class ACL : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public bool applyHere;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public bool applySubs;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public bool inherited;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int userid;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string group;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int allow;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int deny;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public ACL()
        {
            this.group = "";
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public ACL(bool applyHere, bool applySubs, bool inherited, int userid, string group, int allow, int deny)
        {
            this.applyHere = applyHere;
            this.applySubs = applySubs;
            this.inherited = inherited;
            this.userid = userid;
            this.group = group;
            this.allow = allow;
            this.deny = deny;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::ACL");
            global::IceInternal.HashUtil.hashAdd(ref h_, applyHere);
            global::IceInternal.HashUtil.hashAdd(ref h_, applySubs);
            global::IceInternal.HashUtil.hashAdd(ref h_, inherited);
            global::IceInternal.HashUtil.hashAdd(ref h_, userid);
            global::IceInternal.HashUtil.hashAdd(ref h_, group);
            global::IceInternal.HashUtil.hashAdd(ref h_, allow);
            global::IceInternal.HashUtil.hashAdd(ref h_, deny);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            ACL o = (ACL)other;
            if(!this.applyHere.Equals(o.applyHere))
            {
                return false;
            }
            if(!this.applySubs.Equals(o.applySubs))
            {
                return false;
            }
            if(!this.inherited.Equals(o.inherited))
            {
                return false;
            }
            if(!this.userid.Equals(o.userid))
            {
                return false;
            }
            if(this.group == null)
            {
                if(o.group != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.group.Equals(o.group))
                {
                    return false;
                }
            }
            if(!this.allow.Equals(o.allow))
            {
                return false;
            }
            if(!this.deny.Equals(o.deny))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(ACL lhs, ACL rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(ACL lhs, ACL rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            ostr.writeBool(this.applyHere);
            ostr.writeBool(this.applySubs);
            ostr.writeBool(this.inherited);
            ostr.writeInt(this.userid);
            ostr.writeString(this.group);
            ostr.writeInt(this.allow);
            ostr.writeInt(this.deny);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.applyHere = istr.readBool();
            this.applySubs = istr.readBool();
            this.inherited = istr.readBool();
            this.userid = istr.readInt();
            this.group = istr.readString();
            this.allow = istr.readInt();
            this.deny = istr.readInt();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static void ice_write(global::Ice.OutputStream ostr, ACL v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static ACL ice_read(global::Ice.InputStream istr)
        {
            var v = new ACL();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly ACL _nullMarshalValue = new ACL();

        #endregion
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    [global::System.Serializable]
    public partial class Ban : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public byte[] address;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int bits;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string name;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string hash;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string reason;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int start;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int duration;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public Ban()
        {
            this.name = "";
            this.hash = "";
            this.reason = "";
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public Ban(byte[] address, int bits, string name, string hash, string reason, int start, int duration)
        {
            this.address = address;
            this.bits = bits;
            this.name = name;
            this.hash = hash;
            this.reason = reason;
            this.start = start;
            this.duration = duration;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::Ban");
            global::IceInternal.HashUtil.hashAdd(ref h_, address);
            global::IceInternal.HashUtil.hashAdd(ref h_, bits);
            global::IceInternal.HashUtil.hashAdd(ref h_, name);
            global::IceInternal.HashUtil.hashAdd(ref h_, hash);
            global::IceInternal.HashUtil.hashAdd(ref h_, reason);
            global::IceInternal.HashUtil.hashAdd(ref h_, start);
            global::IceInternal.HashUtil.hashAdd(ref h_, duration);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            Ban o = (Ban)other;
            if(this.address == null)
            {
                if(o.address != null)
                {
                    return false;
                }
            }
            else
            {
                if(!IceUtilInternal.Arrays.Equals(this.address, o.address))
                {
                    return false;
                }
            }
            if(!this.bits.Equals(o.bits))
            {
                return false;
            }
            if(this.name == null)
            {
                if(o.name != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.name.Equals(o.name))
                {
                    return false;
                }
            }
            if(this.hash == null)
            {
                if(o.hash != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.hash.Equals(o.hash))
                {
                    return false;
                }
            }
            if(this.reason == null)
            {
                if(o.reason != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.reason.Equals(o.reason))
                {
                    return false;
                }
            }
            if(!this.start.Equals(o.start))
            {
                return false;
            }
            if(!this.duration.Equals(o.duration))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(Ban lhs, Ban rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(Ban lhs, Ban rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            NetAddressHelper.write(ostr, this.address);
            ostr.writeInt(this.bits);
            ostr.writeString(this.name);
            ostr.writeString(this.hash);
            ostr.writeString(this.reason);
            ostr.writeInt(this.start);
            ostr.writeInt(this.duration);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.address = NetAddressHelper.read(istr);
            this.bits = istr.readInt();
            this.name = istr.readString();
            this.hash = istr.readString();
            this.reason = istr.readString();
            this.start = istr.readInt();
            this.duration = istr.readInt();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static void ice_write(global::Ice.OutputStream ostr, Ban v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static Ban ice_read(global::Ice.InputStream istr)
        {
            var v = new Ban();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly Ban _nullMarshalValue = new Ban();

        #endregion
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    [global::System.Serializable]
    public partial class LogEntry : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public int timestamp;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string txt;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public LogEntry()
        {
            this.txt = "";
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public LogEntry(int timestamp, string txt)
        {
            this.timestamp = timestamp;
            this.txt = txt;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::LogEntry");
            global::IceInternal.HashUtil.hashAdd(ref h_, timestamp);
            global::IceInternal.HashUtil.hashAdd(ref h_, txt);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            LogEntry o = (LogEntry)other;
            if(!this.timestamp.Equals(o.timestamp))
            {
                return false;
            }
            if(this.txt == null)
            {
                if(o.txt != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.txt.Equals(o.txt))
                {
                    return false;
                }
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(LogEntry lhs, LogEntry rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(LogEntry lhs, LogEntry rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            ostr.writeInt(this.timestamp);
            ostr.writeString(this.txt);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.timestamp = istr.readInt();
            this.txt = istr.readString();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static void ice_write(global::Ice.OutputStream ostr, LogEntry v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static LogEntry ice_read(global::Ice.InputStream istr)
        {
            var v = new LogEntry();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly LogEntry _nullMarshalValue = new LogEntry();

        #endregion
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public enum ChannelInfo
    {
        ChannelDescription,
        ChannelPosition
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class ChannelInfoHelper
    {
        public static void write(global::Ice.OutputStream ostr, ChannelInfo v)
        {
            ostr.writeEnum((int)v, 1);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static ChannelInfo read(global::Ice.InputStream istr)
        {
            ChannelInfo v;
            v = (ChannelInfo)istr.readEnum(1);
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public enum UserInfo
    {
        UserName,
        UserEmail,
        UserComment,
        UserHash,
        UserPassword,
        UserLastActive,
        UserKDFIterations
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class UserInfoHelper
    {
        public static void write(global::Ice.OutputStream ostr, UserInfo v)
        {
            ostr.writeEnum((int)v, 6);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static UserInfo read(global::Ice.InputStream istr)
        {
            UserInfo v;
            v = (UserInfo)istr.readEnum(6);
            return v;
        }
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    [global::System.Serializable]
    public partial class Tree : global::Ice.Value
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public Channel c;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public Tree[] children;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public User[] users;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public Tree()
        {
            this.c = new Channel();
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public Tree(Channel c, Tree[] children, User[] users)
        {
            this.c = c;
            this.children = children;
            this.users = users;
            ice_initialize();
        }

        #endregion

        private const string _id = "::Murmur::Tree";

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static new string ice_staticId()
        {
            return _id;
        }
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return _id;
        }

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice(ice_staticId(), -1, true);
            Channel.ice_write(ostr_, c);
            TreeListHelper.write(ostr_, children);
            UserListHelper.write(ostr_, users);
            ostr_.endSlice();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            c = Channel.ice_read(istr_);
            children = TreeListHelper.read(istr_);
            users = UserListHelper.read(istr_);
            istr_.endSlice();
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032")]
    [global::System.Serializable]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class MurmurException : global::Ice.UserException
    {
        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public MurmurException()
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public MurmurException(global::System.Exception ex) : base(ex)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public MurmurException(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #endregion

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return "::Murmur::MurmurException";
        }

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::MurmurException");
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(other == null)
            {
                return false;
            }
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            MurmurException o = other as MurmurException;
            if(o == null)
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(MurmurException lhs, MurmurException rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(MurmurException lhs, MurmurException rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::Murmur::MurmurException", -1, true);
            ostr_.endSlice();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
        }

        #endregion
    }

    /// <summary>
    /// This is thrown when you specify an invalid session.
    /// This may happen if the user has disconnected since your last call to Server.getUsers. See User.session
    /// </summary>

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032")]
    [global::System.Serializable]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class InvalidSessionException : MurmurException
    {
        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidSessionException()
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidSessionException(global::System.Exception ex) : base(ex)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidSessionException(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #endregion

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return "::Murmur::InvalidSessionException";
        }

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = base.GetHashCode();
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::InvalidSessionException");
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(other == null)
            {
                return false;
            }
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            InvalidSessionException o = other as InvalidSessionException;
            if(o == null)
            {
                return false;
            }
            if(!base.Equals(other))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(InvalidSessionException lhs, InvalidSessionException rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(InvalidSessionException lhs, InvalidSessionException rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::Murmur::InvalidSessionException", -1, false);
            ostr_.endSlice();
            base.iceWriteImpl(ostr_);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
            base.iceReadImpl(istr_);
        }

        #endregion
    }

    /// <summary>
    /// This is thrown when you specify an invalid channel id.
    /// This may happen if the channel was removed by another provess. It can also be thrown if you try to add an invalid channel.
    /// </summary>

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032")]
    [global::System.Serializable]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class InvalidChannelException : MurmurException
    {
        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidChannelException()
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidChannelException(global::System.Exception ex) : base(ex)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidChannelException(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #endregion

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return "::Murmur::InvalidChannelException";
        }

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = base.GetHashCode();
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::InvalidChannelException");
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(other == null)
            {
                return false;
            }
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            InvalidChannelException o = other as InvalidChannelException;
            if(o == null)
            {
                return false;
            }
            if(!base.Equals(other))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(InvalidChannelException lhs, InvalidChannelException rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(InvalidChannelException lhs, InvalidChannelException rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::Murmur::InvalidChannelException", -1, false);
            ostr_.endSlice();
            base.iceWriteImpl(ostr_);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
            base.iceReadImpl(istr_);
        }

        #endregion
    }

    /// <summary>
    /// This is thrown when you try to do an operation on a server that does not exist.
    /// This may happen if someone has removed the server.
    /// </summary>

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032")]
    [global::System.Serializable]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class InvalidServerException : MurmurException
    {
        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidServerException()
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidServerException(global::System.Exception ex) : base(ex)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidServerException(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #endregion

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return "::Murmur::InvalidServerException";
        }

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = base.GetHashCode();
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::InvalidServerException");
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(other == null)
            {
                return false;
            }
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            InvalidServerException o = other as InvalidServerException;
            if(o == null)
            {
                return false;
            }
            if(!base.Equals(other))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(InvalidServerException lhs, InvalidServerException rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(InvalidServerException lhs, InvalidServerException rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::Murmur::InvalidServerException", -1, false);
            ostr_.endSlice();
            base.iceWriteImpl(ostr_);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
            base.iceReadImpl(istr_);
        }

        #endregion
    }

    /// <summary>
    /// This happens if you try to fetch user or channel state on a stopped server, if you try to stop an already stopped server or start an already started server.
    /// </summary>

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032")]
    [global::System.Serializable]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class ServerBootedException : MurmurException
    {
        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public ServerBootedException()
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public ServerBootedException(global::System.Exception ex) : base(ex)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public ServerBootedException(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #endregion

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return "::Murmur::ServerBootedException";
        }

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = base.GetHashCode();
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::ServerBootedException");
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(other == null)
            {
                return false;
            }
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            ServerBootedException o = other as ServerBootedException;
            if(o == null)
            {
                return false;
            }
            if(!base.Equals(other))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(ServerBootedException lhs, ServerBootedException rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(ServerBootedException lhs, ServerBootedException rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::Murmur::ServerBootedException", -1, false);
            ostr_.endSlice();
            base.iceWriteImpl(ostr_);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
            base.iceReadImpl(istr_);
        }

        #endregion
    }

    /// <summary>
    /// This is thrown if Server.start fails, and should generally be the cause for some concern.
    /// </summary>

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032")]
    [global::System.Serializable]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class ServerFailureException : MurmurException
    {
        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public ServerFailureException()
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public ServerFailureException(global::System.Exception ex) : base(ex)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public ServerFailureException(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #endregion

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return "::Murmur::ServerFailureException";
        }

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = base.GetHashCode();
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::ServerFailureException");
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(other == null)
            {
                return false;
            }
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            ServerFailureException o = other as ServerFailureException;
            if(o == null)
            {
                return false;
            }
            if(!base.Equals(other))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(ServerFailureException lhs, ServerFailureException rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(ServerFailureException lhs, ServerFailureException rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::Murmur::ServerFailureException", -1, false);
            ostr_.endSlice();
            base.iceWriteImpl(ostr_);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
            base.iceReadImpl(istr_);
        }

        #endregion
    }

    /// <summary>
    /// This is thrown when you specify an invalid userid.
    /// </summary>

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032")]
    [global::System.Serializable]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class InvalidUserException : MurmurException
    {
        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidUserException()
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidUserException(global::System.Exception ex) : base(ex)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidUserException(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #endregion

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return "::Murmur::InvalidUserException";
        }

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = base.GetHashCode();
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::InvalidUserException");
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(other == null)
            {
                return false;
            }
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            InvalidUserException o = other as InvalidUserException;
            if(o == null)
            {
                return false;
            }
            if(!base.Equals(other))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(InvalidUserException lhs, InvalidUserException rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(InvalidUserException lhs, InvalidUserException rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::Murmur::InvalidUserException", -1, false);
            ostr_.endSlice();
            base.iceWriteImpl(ostr_);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
            base.iceReadImpl(istr_);
        }

        #endregion
    }

    /// <summary>
    /// This is thrown when you try to set an invalid texture.
    /// </summary>

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032")]
    [global::System.Serializable]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class InvalidTextureException : MurmurException
    {
        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidTextureException()
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidTextureException(global::System.Exception ex) : base(ex)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidTextureException(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #endregion

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return "::Murmur::InvalidTextureException";
        }

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = base.GetHashCode();
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::InvalidTextureException");
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(other == null)
            {
                return false;
            }
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            InvalidTextureException o = other as InvalidTextureException;
            if(o == null)
            {
                return false;
            }
            if(!base.Equals(other))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(InvalidTextureException lhs, InvalidTextureException rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(InvalidTextureException lhs, InvalidTextureException rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::Murmur::InvalidTextureException", -1, false);
            ostr_.endSlice();
            base.iceWriteImpl(ostr_);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
            base.iceReadImpl(istr_);
        }

        #endregion
    }

    /// <summary>
    /// This is thrown when you supply an invalid callback.
    /// </summary>

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032")]
    [global::System.Serializable]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class InvalidCallbackException : MurmurException
    {
        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidCallbackException()
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidCallbackException(global::System.Exception ex) : base(ex)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidCallbackException(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #endregion

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return "::Murmur::InvalidCallbackException";
        }

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = base.GetHashCode();
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::InvalidCallbackException");
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(other == null)
            {
                return false;
            }
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            InvalidCallbackException o = other as InvalidCallbackException;
            if(o == null)
            {
                return false;
            }
            if(!base.Equals(other))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(InvalidCallbackException lhs, InvalidCallbackException rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(InvalidCallbackException lhs, InvalidCallbackException rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::Murmur::InvalidCallbackException", -1, false);
            ostr_.endSlice();
            base.iceWriteImpl(ostr_);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
            base.iceReadImpl(istr_);
        }

        #endregion
    }

    /// <summary>
    /// This is thrown when you supply the wrong secret in the calling context.
    /// </summary>

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032")]
    [global::System.Serializable]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class InvalidSecretException : MurmurException
    {
        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidSecretException()
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidSecretException(global::System.Exception ex) : base(ex)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidSecretException(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #endregion

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return "::Murmur::InvalidSecretException";
        }

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = base.GetHashCode();
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::InvalidSecretException");
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(other == null)
            {
                return false;
            }
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            InvalidSecretException o = other as InvalidSecretException;
            if(o == null)
            {
                return false;
            }
            if(!base.Equals(other))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(InvalidSecretException lhs, InvalidSecretException rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(InvalidSecretException lhs, InvalidSecretException rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::Murmur::InvalidSecretException", -1, false);
            ostr_.endSlice();
            base.iceWriteImpl(ostr_);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
            base.iceReadImpl(istr_);
        }

        #endregion
    }

    /// <summary>
    /// This is thrown when the channel operation would excede the channel nesting limit
    /// </summary>

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032")]
    [global::System.Serializable]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class NestingLimitException : MurmurException
    {
        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public NestingLimitException()
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public NestingLimitException(global::System.Exception ex) : base(ex)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public NestingLimitException(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #endregion

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return "::Murmur::NestingLimitException";
        }

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = base.GetHashCode();
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::NestingLimitException");
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(other == null)
            {
                return false;
            }
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            NestingLimitException o = other as NestingLimitException;
            if(o == null)
            {
                return false;
            }
            if(!base.Equals(other))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(NestingLimitException lhs, NestingLimitException rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(NestingLimitException lhs, NestingLimitException rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::Murmur::NestingLimitException", -1, false);
            ostr_.endSlice();
            base.iceWriteImpl(ostr_);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
            base.iceReadImpl(istr_);
        }

        #endregion
    }

    /// <summary>
    /// This is thrown when you ask the server to disclose something that should be secret.
    /// </summary>

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032")]
    [global::System.Serializable]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class WriteOnlyException : MurmurException
    {
        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public WriteOnlyException()
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public WriteOnlyException(global::System.Exception ex) : base(ex)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public WriteOnlyException(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #endregion

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return "::Murmur::WriteOnlyException";
        }

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = base.GetHashCode();
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::WriteOnlyException");
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(other == null)
            {
                return false;
            }
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            WriteOnlyException o = other as WriteOnlyException;
            if(o == null)
            {
                return false;
            }
            if(!base.Equals(other))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(WriteOnlyException lhs, WriteOnlyException rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(WriteOnlyException lhs, WriteOnlyException rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::Murmur::WriteOnlyException", -1, false);
            ostr_.endSlice();
            base.iceWriteImpl(ostr_);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
            base.iceReadImpl(istr_);
        }

        #endregion
    }

    /// <summary>
    /// This is thrown when invalid input data was specified.
    /// </summary>

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032")]
    [global::System.Serializable]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class InvalidInputDataException : MurmurException
    {
        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidInputDataException()
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidInputDataException(global::System.Exception ex) : base(ex)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public InvalidInputDataException(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #endregion

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return "::Murmur::InvalidInputDataException";
        }

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = base.GetHashCode();
            global::IceInternal.HashUtil.hashAdd(ref h_, "::Murmur::InvalidInputDataException");
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(other == null)
            {
                return false;
            }
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            InvalidInputDataException o = other as InvalidInputDataException;
            if(o == null)
            {
                return false;
            }
            if(!base.Equals(other))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(InvalidInputDataException lhs, InvalidInputDataException rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(InvalidInputDataException lhs, InvalidInputDataException rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::Murmur::InvalidInputDataException", -1, false);
            ostr_.endSlice();
            base.iceWriteImpl(ostr_);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
            base.iceReadImpl(istr_);
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial interface ServerCallback : global::Ice.Object, ServerCallbackOperations_
    {
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class ContextServer
    {
        public const int value = 1;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class ContextChannel
    {
        public const int value = 2;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class ContextUser
    {
        public const int value = 4;
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial interface ServerContextCallback : global::Ice.Object, ServerContextCallbackOperations_
    {
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial interface ServerAuthenticator : global::Ice.Object, ServerAuthenticatorOperations_
    {
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial interface ServerUpdatingAuthenticator : global::Ice.Object, ServerUpdatingAuthenticatorOperations_, ServerAuthenticator
    {
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial interface Server : global::Ice.Object, ServerOperations_
    {
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial interface MetaCallback : global::Ice.Object, MetaCallbackOperations_
    {
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial interface Meta : global::Ice.Object, MetaOperations_
    {
    }
}

namespace Murmur
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerCallback_userConnected();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerCallback_userDisconnected();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerCallback_userStateChanged();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerCallback_userTextMessage();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerCallback_channelCreated();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerCallback_channelRemoved();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerCallback_channelStateChanged();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerContextCallback_contextAction();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerAuthenticator_authenticate(int ret, string newname, string[] groups);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerAuthenticator_getInfo(bool ret, global::System.Collections.Generic.Dictionary<UserInfo, string> info);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerAuthenticator_nameToId(int ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerAuthenticator_idToName(string ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerAuthenticator_idToTexture(byte[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerUpdatingAuthenticator_registerUser(int ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerUpdatingAuthenticator_unregisterUser(int ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerUpdatingAuthenticator_getRegisteredUsers(global::System.Collections.Generic.Dictionary<int, string> ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerUpdatingAuthenticator_setInfo(int ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_ServerUpdatingAuthenticator_setTexture(int ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_isRunning(bool ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_start();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_stop();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_delete();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_id(int ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_addCallback();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_removeCallback();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_setAuthenticator();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getConf(string ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getAllConf(global::System.Collections.Generic.Dictionary<string, string> ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_setConf();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_setSuperuserPassword();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getLog(LogEntry[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getLogLen(int ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getUsers(global::System.Collections.Generic.Dictionary<int, User> ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getChannels(global::System.Collections.Generic.Dictionary<int, Channel> ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getCertificateList(byte[][] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getTree(Tree ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getBans(Ban[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_setBans();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_kickUser();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getState(User ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_setState();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_sendMessage();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_hasPermission(bool ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_effectivePermissions(int ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_addContextCallback();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_removeContextCallback();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getChannelState(Channel ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_setChannelState();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_removeChannel();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_addChannel(int ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_sendMessageChannel();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getACL(ACL[] acls, Group[] groups, bool inherit);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_setACL();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_addUserToGroup();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_removeUserFromGroup();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_redirectWhisperGroup();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getUserNames(global::System.Collections.Generic.Dictionary<int, string> ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getUserIds(global::System.Collections.Generic.Dictionary<string, int> ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_registerUser(int ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_unregisterUser();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_updateRegistration();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getRegistration(global::System.Collections.Generic.Dictionary<UserInfo, string> ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getRegisteredUsers(global::System.Collections.Generic.Dictionary<int, string> ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_verifyPassword(int ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getTexture(byte[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_setTexture();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_getUptime(int ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Server_updateCertificate();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_MetaCallback_started();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_MetaCallback_stopped();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Meta_getServer(ServerPrx ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Meta_newServer(ServerPrx ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Meta_getBootedServers(ServerPrx[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Meta_getAllServers(ServerPrx[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Meta_getDefaultConf(global::System.Collections.Generic.Dictionary<string, string> ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Meta_getVersion(int major, int minor, int patch, string text);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Meta_addCallback();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Meta_removeCallback();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Meta_getUptime(int ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Meta_getSlice(string ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_Meta_getSliceChecksums(global::System.Collections.Generic.Dictionary<string, string> ret);
}

namespace Murmur
{
    public struct ServerAuthenticator_AuthenticateResult
    {
        public ServerAuthenticator_AuthenticateResult(int returnValue, string newname, string[] groups)
        {
            this.returnValue = returnValue;
            this.newname = newname;
            this.groups = groups;
        }

        public int returnValue;
        public string newname;
        public string[] groups;
    }

    public struct ServerAuthenticator_GetInfoResult
    {
        public ServerAuthenticator_GetInfoResult(bool returnValue, global::System.Collections.Generic.Dictionary<UserInfo, string> info)
        {
            this.returnValue = returnValue;
            this.info = info;
        }

        public bool returnValue;
        public global::System.Collections.Generic.Dictionary<UserInfo, string> info;
    }

    public struct Server_GetACLResult
    {
        public Server_GetACLResult(ACL[] acls, Group[] groups, bool inherit)
        {
            this.acls = acls;
            this.groups = groups;
            this.inherit = inherit;
        }

        public ACL[] acls;
        public Group[] groups;
        public bool inherit;
    }

    public struct Meta_GetVersionResult
    {
        public Meta_GetVersionResult(int major, int minor, int patch, string text)
        {
            this.major = major;
            this.minor = minor;
            this.patch = patch;
            this.text = text;
        }

        public int major;
        public int minor;
        public int patch;
        public string text;
    }
}

namespace Murmur
{
    /// <summary>
    /// Callback interface for servers.
    /// You can supply an implementation of this to receive notification
    /// messages from the server.
    /// If an added callback ever throws an exception or goes away, it will be automatically removed.
    /// Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
    /// complete before continuing processing.
    /// Note that callbacks are removed when a server is stopped, so you should have a callback for
    /// MetaCallback.started which calls Server.addCallback.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public interface ServerCallbackPrx : global::Ice.ObjectPrx
    {
        /// <summary>
        /// Called when a user connects to the server.
        /// </summary>
        /// <param name="state">State of connected user.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void userConnected(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a user connects to the server.
        /// </summary>
        /// <param name="state">State of connected user.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task userConnectedAsync(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Called when a user connects to the server.
        /// </summary>
        /// <param name="state">State of connected user.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerCallback_userConnected> begin_userConnected(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a user connects to the server.
        /// </summary>
        /// <param name="state">State of connected user.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_userConnected(User state, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a user connects to the server.
        /// </summary>
        /// <param name="state">State of connected user.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_userConnected(User state, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a user connects to the server.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_userConnected(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Called when a user disconnects from the server.
        /// The user has already been removed, so you can no longer use methods like Server.getState
        /// to retrieve the user's state.
        /// </summary>
        /// <param name="state">State of disconnected user.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void userDisconnected(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a user disconnects from the server.
        /// The user has already been removed, so you can no longer use methods like Server.getState
        /// </summary>
        /// <param name="state">State of disconnected user.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task userDisconnectedAsync(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Called when a user disconnects from the server.
        /// The user has already been removed, so you can no longer use methods like Server.getState
        /// </summary>
        /// <param name="state">State of disconnected user.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerCallback_userDisconnected> begin_userDisconnected(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a user disconnects from the server.
        /// The user has already been removed, so you can no longer use methods like Server.getState
        /// </summary>
        /// <param name="state">State of disconnected user.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_userDisconnected(User state, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a user disconnects from the server.
        /// The user has already been removed, so you can no longer use methods like Server.getState
        /// </summary>
        /// <param name="state">State of disconnected user.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_userDisconnected(User state, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a user disconnects from the server.
        /// The user has already been removed, so you can no longer use methods like Server.getState
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_userDisconnected(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Called when a user state changes.
        /// This is called if the user moves, is renamed, is muted, deafened etc.
        /// </summary>
        /// <param name="state">New state of user.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void userStateChanged(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a user state changes.
        /// This is called if the user moves, is renamed, is muted, deafened etc.
        /// </summary>
        /// <param name="state">New state of user.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task userStateChangedAsync(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Called when a user state changes.
        /// This is called if the user moves, is renamed, is muted, deafened etc.
        /// </summary>
        /// <param name="state">New state of user.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerCallback_userStateChanged> begin_userStateChanged(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a user state changes.
        /// This is called if the user moves, is renamed, is muted, deafened etc.
        /// </summary>
        /// <param name="state">New state of user.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_userStateChanged(User state, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a user state changes.
        /// This is called if the user moves, is renamed, is muted, deafened etc.
        /// </summary>
        /// <param name="state">New state of user.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_userStateChanged(User state, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a user state changes.
        /// This is called if the user moves, is renamed, is muted, deafened etc.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_userStateChanged(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Called when user writes a text message
        /// </summary>
        /// <param name="state">the User sending the message
        /// </param>
        /// <param name="message">the TextMessage the user has sent</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void userTextMessage(User state, TextMessage message, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when user writes a text message
        /// </summary>
        /// <param name="state">the User sending the message
        /// </param>
        /// <param name="message">the TextMessage the user has sent</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task userTextMessageAsync(User state, TextMessage message, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Called when user writes a text message
        /// </summary>
        /// <param name="state">the User sending the message
        /// </param>
        /// <param name="message">the TextMessage the user has sent</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerCallback_userTextMessage> begin_userTextMessage(User state, TextMessage message, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when user writes a text message
        /// </summary>
        /// <param name="state">the User sending the message
        /// </param>
        /// <param name="message">the TextMessage the user has sent</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_userTextMessage(User state, TextMessage message, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when user writes a text message
        /// </summary>
        /// <param name="state">the User sending the message
        /// </param>
        /// <param name="message">the TextMessage the user has sent</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_userTextMessage(User state, TextMessage message, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when user writes a text message
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_userTextMessage(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Called when a new channel is created.
        /// </summary>
        /// <param name="state">State of new channel.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void channelCreated(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a new channel is created.
        /// </summary>
        /// <param name="state">State of new channel.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task channelCreatedAsync(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Called when a new channel is created.
        /// </summary>
        /// <param name="state">State of new channel.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerCallback_channelCreated> begin_channelCreated(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a new channel is created.
        /// </summary>
        /// <param name="state">State of new channel.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_channelCreated(Channel state, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a new channel is created.
        /// </summary>
        /// <param name="state">State of new channel.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_channelCreated(Channel state, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a new channel is created.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_channelCreated(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Called when a channel is removed.
        /// The channel has already been removed, you can no longer use methods like Server.getChannelState
        /// </summary>
        /// <param name="state">State of removed channel.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void channelRemoved(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a channel is removed.
        /// The channel has already been removed, you can no longer use methods like Server.getChannelState
        /// </summary>
        /// <param name="state">State of removed channel.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task channelRemovedAsync(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Called when a channel is removed.
        /// The channel has already been removed, you can no longer use methods like Server.getChannelState
        /// </summary>
        /// <param name="state">State of removed channel.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerCallback_channelRemoved> begin_channelRemoved(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a channel is removed.
        /// The channel has already been removed, you can no longer use methods like Server.getChannelState
        /// </summary>
        /// <param name="state">State of removed channel.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_channelRemoved(Channel state, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a channel is removed.
        /// The channel has already been removed, you can no longer use methods like Server.getChannelState
        /// </summary>
        /// <param name="state">State of removed channel.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_channelRemoved(Channel state, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a channel is removed.
        /// The channel has already been removed, you can no longer use methods like Server.getChannelState
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_channelRemoved(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Called when a new channel state changes.
        /// This is called if the channel is moved, renamed or if new links are added.
        /// </summary>
        /// <param name="state">New state of channel.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void channelStateChanged(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a new channel state changes.
        /// This is called if the channel is moved, renamed or if new links are added.
        /// </summary>
        /// <param name="state">New state of channel.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task channelStateChangedAsync(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Called when a new channel state changes.
        /// This is called if the channel is moved, renamed or if new links are added.
        /// </summary>
        /// <param name="state">New state of channel.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerCallback_channelStateChanged> begin_channelStateChanged(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a new channel state changes.
        /// This is called if the channel is moved, renamed or if new links are added.
        /// </summary>
        /// <param name="state">New state of channel.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_channelStateChanged(Channel state, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a new channel state changes.
        /// This is called if the channel is moved, renamed or if new links are added.
        /// </summary>
        /// <param name="state">New state of channel.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_channelStateChanged(Channel state, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a new channel state changes.
        /// This is called if the channel is moved, renamed or if new links are added.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_channelStateChanged(global::Ice.AsyncResult asyncResult);
    }

    /// <summary>
    /// Callback interface for context actions.
    /// You need to supply one of these for Server.addContext. 
    /// If an added callback ever throws an exception or goes away, it will be automatically removed.
    /// Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
    /// complete before continuing processing.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public interface ServerContextCallbackPrx : global::Ice.ObjectPrx
    {
        /// <summary>
        /// Called when a context action is performed.
        /// </summary>
        /// <param name="action">Action to be performed.
        /// </param>
        /// <param name="usr">User which initiated the action.
        /// </param>
        /// <param name="session">If nonzero, session of target user.
        /// </param>
        /// <param name="channelid">If not -1, id of target channel.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void contextAction(string action, User usr, int session, int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a context action is performed.
        /// </summary>
        /// <param name="action">Action to be performed.
        /// </param>
        /// <param name="usr">User which initiated the action.
        /// </param>
        /// <param name="session">If nonzero, session of target user.
        /// </param>
        /// <param name="channelid">If not -1, id of target channel.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task contextActionAsync(string action, User usr, int session, int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Called when a context action is performed.
        /// </summary>
        /// <param name="action">Action to be performed.
        /// </param>
        /// <param name="usr">User which initiated the action.
        /// </param>
        /// <param name="session">If nonzero, session of target user.
        /// </param>
        /// <param name="channelid">If not -1, id of target channel.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerContextCallback_contextAction> begin_contextAction(string action, User usr, int session, int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a context action is performed.
        /// </summary>
        /// <param name="action">Action to be performed.
        /// </param>
        /// <param name="usr">User which initiated the action.
        /// </param>
        /// <param name="session">If nonzero, session of target user.
        /// </param>
        /// <param name="channelid">If not -1, id of target channel.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_contextAction(string action, User usr, int session, int channelid, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a context action is performed.
        /// </summary>
        /// <param name="action">Action to be performed.
        /// </param>
        /// <param name="usr">User which initiated the action.
        /// </param>
        /// <param name="session">If nonzero, session of target user.
        /// </param>
        /// <param name="channelid">If not -1, id of target channel.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_contextAction(string action, User usr, int session, int channelid, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a context action is performed.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_contextAction(global::Ice.AsyncResult asyncResult);
    }

    /// <summary>
    /// Callback interface for server authentication.
    /// You need to supply one of these for Server.setAuthenticator.
    /// If an added callback ever throws an exception or goes away, it will be automatically removed.
    /// Please note that unlike ServerCallback and ServerContextCallback, these methods are called
    /// synchronously. If the response lags, the entire murmur server will lag.
    /// Also note that, as the method calls are synchronous, making a call to Server or Meta will
    /// deadlock the server.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public interface ServerAuthenticatorPrx : global::Ice.ObjectPrx
    {
        /// <summary>
        /// Called to authenticate a user.
        /// If you do not know the username in question, always return -2 from this
        /// method to fall through to normal database authentication.
        /// Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
        /// the username and id so it cannot be used for normal database authentication.
        /// The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
        /// should only be trusted if certstrong is true.
        ///
        /// Internally, Murmur treats usernames as case-insensitive. It is recommended
        /// that authenticators do the same. Murmur checks if a username is in use when
        /// a user connects. If the connecting user is registered, the other username is
        /// kicked. If the connecting user is not registered, the connecting user is not
        /// allowed to join the server.
        ///
        /// </summary>
        /// <param name="name">Username to authenticate.
        /// </param>
        /// <param name="pw">Password to authenticate with.
        /// </param>
        /// <param name="certificates">List of der encoded certificates the user connected with.
        /// </param>
        /// <param name="certhash">Hash of user certificate, as used by murmur internally when matching.
        /// </param>
        /// <param name="certstrong">True if certificate was valid and signed by a trusted CA.
        /// </param>
        /// <param name="newname">Set this to change the username from the supplied one.
        /// </param>
        /// <param name="groups">List of groups on the root channel that the user will be added to for the duration of the connection.
        /// </param>
        /// <returns>UserID of authenticated user, -1 for authentication failures, -2 for unknown user (fallthrough),
        /// -3 for authentication failures where the data could (temporarily) not be verified.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        int authenticate(string name, string pw, byte[][] certificates, string certhash, bool certstrong, out string newname, out string[] groups, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called to authenticate a user.
        /// If you do not know the username in question, always return -2 from this
        /// </summary>
        /// <param name="name">Username to authenticate.
        /// </param>
        /// <param name="pw">Password to authenticate with.
        /// </param>
        /// <param name="certificates">List of der encoded certificates the user connected with.
        /// </param>
        /// <param name="certhash">Hash of user certificate, as used by murmur internally when matching.
        /// </param>
        /// <param name="certstrong">True if certificate was valid and signed by a trusted CA.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ServerAuthenticator_AuthenticateResult> authenticateAsync(string name, string pw, byte[][] certificates, string certhash, bool certstrong, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Called to authenticate a user.
        /// If you do not know the username in question, always return -2 from this
        /// </summary>
        /// <param name="name">Username to authenticate.
        /// </param>
        /// <param name="pw">Password to authenticate with.
        /// </param>
        /// <param name="certificates">List of der encoded certificates the user connected with.
        /// </param>
        /// <param name="certhash">Hash of user certificate, as used by murmur internally when matching.
        /// </param>
        /// <param name="certstrong">True if certificate was valid and signed by a trusted CA.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerAuthenticator_authenticate> begin_authenticate(string name, string pw, byte[][] certificates, string certhash, bool certstrong, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called to authenticate a user.
        /// If you do not know the username in question, always return -2 from this
        /// </summary>
        /// <param name="name">Username to authenticate.
        /// </param>
        /// <param name="pw">Password to authenticate with.
        /// </param>
        /// <param name="certificates">List of der encoded certificates the user connected with.
        /// </param>
        /// <param name="certhash">Hash of user certificate, as used by murmur internally when matching.
        /// </param>
        /// <param name="certstrong">True if certificate was valid and signed by a trusted CA.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_authenticate(string name, string pw, byte[][] certificates, string certhash, bool certstrong, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called to authenticate a user.
        /// If you do not know the username in question, always return -2 from this
        /// </summary>
        /// <param name="name">Username to authenticate.
        /// </param>
        /// <param name="pw">Password to authenticate with.
        /// </param>
        /// <param name="certificates">List of der encoded certificates the user connected with.
        /// </param>
        /// <param name="certhash">Hash of user certificate, as used by murmur internally when matching.
        /// </param>
        /// <param name="certstrong">True if certificate was valid and signed by a trusted CA.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_authenticate(string name, string pw, byte[][] certificates, string certhash, bool certstrong, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called to authenticate a user.
        /// If you do not know the username in question, always return -2 from this
        /// </summary>
        /// <param name="newname">Set this to change the username from the supplied one.
        /// </param>
        /// <param name="groups">List of groups on the root channel that the user will be added to for the duration of the connection.
        /// </param>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>UserID of authenticated user, -1 for authentication failures, -2 for unknown user (fallthrough),
        /// -3 for authentication failures where the data could (temporarily) not be verified.</returns>
        int end_authenticate(out string newname, out string[] groups, global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Fetch information about a user.
        /// This is used to retrieve information like email address, keyhash etc. If you
        /// want murmur to take care of this information itself, simply return false to fall through.
        /// </summary>
        /// <param name="id">User id.
        /// </param>
        /// <param name="info">Information about user. This needs to include at least "name".
        /// </param>
        /// <returns>true if information is present, false to fall through.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        bool getInfo(int id, out global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch information about a user.
        /// This is used to retrieve information like email address, keyhash etc. If you
        /// </summary>
        /// <param name="id">User id.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ServerAuthenticator_GetInfoResult> getInfoAsync(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch information about a user.
        /// This is used to retrieve information like email address, keyhash etc. If you
        /// </summary>
        /// <param name="id">User id.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerAuthenticator_getInfo> begin_getInfo(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch information about a user.
        /// This is used to retrieve information like email address, keyhash etc. If you
        /// </summary>
        /// <param name="id">User id.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getInfo(int id, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch information about a user.
        /// This is used to retrieve information like email address, keyhash etc. If you
        /// </summary>
        /// <param name="id">User id.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getInfo(int id, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch information about a user.
        /// This is used to retrieve information like email address, keyhash etc. If you
        /// </summary>
        /// <param name="info">Information about user. This needs to include at least "name".
        /// </param>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>true if information is present, false to fall through.</returns>
        bool end_getInfo(out global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Map a name to a user id.
        /// </summary>
        /// <param name="name">Username to map.
        /// </param>
        /// <returns>User id or -2 for unknown name.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        int nameToId(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Map a name to a user id.
        /// </summary>
        /// <param name="name">Username to map.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> nameToIdAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Map a name to a user id.
        /// </summary>
        /// <param name="name">Username to map.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerAuthenticator_nameToId> begin_nameToId(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Map a name to a user id.
        /// </summary>
        /// <param name="name">Username to map.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_nameToId(string name, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Map a name to a user id.
        /// </summary>
        /// <param name="name">Username to map.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_nameToId(string name, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Map a name to a user id.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>User id or -2 for unknown name.</returns>
        int end_nameToId(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Map a user id to a username.
        /// </summary>
        /// <param name="id">User id to map.
        /// </param>
        /// <returns>Name of user or empty string for unknown id.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string idToName(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Map a user id to a username.
        /// </summary>
        /// <param name="id">User id to map.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string> idToNameAsync(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Map a user id to a username.
        /// </summary>
        /// <param name="id">User id to map.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerAuthenticator_idToName> begin_idToName(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Map a user id to a username.
        /// </summary>
        /// <param name="id">User id to map.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_idToName(int id, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Map a user id to a username.
        /// </summary>
        /// <param name="id">User id to map.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_idToName(int id, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Map a user id to a username.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Name of user or empty string for unknown id.</returns>
        string end_idToName(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Map a user to a custom Texture.
        /// </summary>
        /// <param name="id">User id to map.
        /// </param>
        /// <returns>User texture or an empty texture for unknwon users or users without textures.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        byte[] idToTexture(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Map a user to a custom Texture.
        /// </summary>
        /// <param name="id">User id to map.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<byte[]> idToTextureAsync(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Map a user to a custom Texture.
        /// </summary>
        /// <param name="id">User id to map.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerAuthenticator_idToTexture> begin_idToTexture(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Map a user to a custom Texture.
        /// </summary>
        /// <param name="id">User id to map.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_idToTexture(int id, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Map a user to a custom Texture.
        /// </summary>
        /// <param name="id">User id to map.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_idToTexture(int id, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Map a user to a custom Texture.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>User texture or an empty texture for unknwon users or users without textures.</returns>
        byte[] end_idToTexture(global::Ice.AsyncResult asyncResult);
    }

    /// <summary>
    /// Callback interface for server authentication and registration.
    /// This allows you to support both authentication
    /// and account updating.
    /// You do not need to implement this if all you want is authentication, you only need this if other scripts
    /// connected to the same server calls e.g. Server.setTexture.
    /// Almost all of these methods support fall through, meaning murmur should continue the operation against its
    /// own database.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public interface ServerUpdatingAuthenticatorPrx : ServerAuthenticatorPrx
    {
        /// <summary>
        /// Register a new user.
        /// </summary>
        /// <param name="info">Information about user to register.
        /// </param>
        /// <returns>User id of new user, -1 for registration failure, or -2 to fall through.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        int registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Register a new user.
        /// </summary>
        /// <param name="info">Information about user to register.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> registerUserAsync(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Register a new user.
        /// </summary>
        /// <param name="info">Information about user to register.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerUpdatingAuthenticator_registerUser> begin_registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Register a new user.
        /// </summary>
        /// <param name="info">Information about user to register.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Register a new user.
        /// </summary>
        /// <param name="info">Information about user to register.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Register a new user.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>User id of new user, -1 for registration failure, or -2 to fall through.</returns>
        int end_registerUser(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Unregister a user.
        /// </summary>
        /// <param name="id">Userid to unregister.
        /// </param>
        /// <returns>1 for successfull unregistration, 0 for unsuccessfull unregistration, -1 to fall through.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        int unregisterUser(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Unregister a user.
        /// </summary>
        /// <param name="id">Userid to unregister.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> unregisterUserAsync(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Unregister a user.
        /// </summary>
        /// <param name="id">Userid to unregister.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerUpdatingAuthenticator_unregisterUser> begin_unregisterUser(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Unregister a user.
        /// </summary>
        /// <param name="id">Userid to unregister.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_unregisterUser(int id, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Unregister a user.
        /// </summary>
        /// <param name="id">Userid to unregister.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_unregisterUser(int id, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Unregister a user.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>1 for successfull unregistration, 0 for unsuccessfull unregistration, -1 to fall through.</returns>
        int end_unregisterUser(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Get a list of registered users matching filter.
        /// </summary>
        /// <param name="filter">Substring usernames must contain. If empty, return all registered users.
        /// </param>
        /// <returns>List of matching registered users.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::System.Collections.Generic.Dictionary<int, string> getRegisteredUsers(string filter, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get a list of registered users matching filter.
        /// </summary>
        /// <param name="filter">Substring usernames must contain. If empty, return all registered users.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, string>> getRegisteredUsersAsync(string filter, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get a list of registered users matching filter.
        /// </summary>
        /// <param name="filter">Substring usernames must contain. If empty, return all registered users.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerUpdatingAuthenticator_getRegisteredUsers> begin_getRegisteredUsers(string filter, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get a list of registered users matching filter.
        /// </summary>
        /// <param name="filter">Substring usernames must contain. If empty, return all registered users.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getRegisteredUsers(string filter, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Get a list of registered users matching filter.
        /// </summary>
        /// <param name="filter">Substring usernames must contain. If empty, return all registered users.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getRegisteredUsers(string filter, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Get a list of registered users matching filter.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>List of matching registered users.</returns>
        global::System.Collections.Generic.Dictionary<int, string> end_getRegisteredUsers(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Set additional information for user registration.
        /// </summary>
        /// <param name="id">Userid of registered user.
        /// </param>
        /// <param name="info">Information to set about user. This should be merged with existing information.
        /// </param>
        /// <returns>1 for successfull update, 0 for unsuccessfull update, -1 to fall through.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        int setInfo(int id, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set additional information for user registration.
        /// </summary>
        /// <param name="id">Userid of registered user.
        /// </param>
        /// <param name="info">Information to set about user. This should be merged with existing information.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> setInfoAsync(int id, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Set additional information for user registration.
        /// </summary>
        /// <param name="id">Userid of registered user.
        /// </param>
        /// <param name="info">Information to set about user. This should be merged with existing information.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerUpdatingAuthenticator_setInfo> begin_setInfo(int id, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set additional information for user registration.
        /// </summary>
        /// <param name="id">Userid of registered user.
        /// </param>
        /// <param name="info">Information to set about user. This should be merged with existing information.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setInfo(int id, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set additional information for user registration.
        /// </summary>
        /// <param name="id">Userid of registered user.
        /// </param>
        /// <param name="info">Information to set about user. This should be merged with existing information.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setInfo(int id, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set additional information for user registration.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>1 for successfull update, 0 for unsuccessfull update, -1 to fall through.</returns>
        int end_setInfo(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Set texture (now called avatar) of user registration.
        /// </summary>
        /// <param name="id">registrationId of registered user.
        /// </param>
        /// <param name="tex">New texture.
        /// </param>
        /// <returns>1 for successfull update, 0 for unsuccessfull update, -1 to fall through.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        int setTexture(int id, byte[] tex, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set texture (now called avatar) of user registration.
        /// </summary>
        /// <param name="id">registrationId of registered user.
        /// </param>
        /// <param name="tex">New texture.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> setTextureAsync(int id, byte[] tex, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Set texture (now called avatar) of user registration.
        /// </summary>
        /// <param name="id">registrationId of registered user.
        /// </param>
        /// <param name="tex">New texture.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_ServerUpdatingAuthenticator_setTexture> begin_setTexture(int id, byte[] tex, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set texture (now called avatar) of user registration.
        /// </summary>
        /// <param name="id">registrationId of registered user.
        /// </param>
        /// <param name="tex">New texture.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setTexture(int id, byte[] tex, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set texture (now called avatar) of user registration.
        /// </summary>
        /// <param name="id">registrationId of registered user.
        /// </param>
        /// <param name="tex">New texture.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setTexture(int id, byte[] tex, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set texture (now called avatar) of user registration.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>1 for successfull update, 0 for unsuccessfull update, -1 to fall through.</returns>
        int end_setTexture(global::Ice.AsyncResult asyncResult);
    }

    /// <summary>
    /// Per-server interface.
    /// This includes all methods for configuring and altering
    /// the state of a single virtual server. You can retrieve a pointer to this interface
    /// from one of the methods in Meta.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public interface ServerPrx : global::Ice.ObjectPrx
    {
        /// <summary>
        /// Shows if the server currently running (accepting users).
        /// </summary>
        /// <returns>Run-state of server.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        bool isRunning(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Shows if the server currently running (accepting users).
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<bool> isRunningAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Shows if the server currently running (accepting users).
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_isRunning> begin_isRunning(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Shows if the server currently running (accepting users).
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_isRunning(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Shows if the server currently running (accepting users).
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_isRunning(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Shows if the server currently running (accepting users).
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Run-state of server.</returns>
        bool end_isRunning(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Start server.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void start(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Start server.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task startAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Start server.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_start> begin_start(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Start server.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_start(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Start server.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_start(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Start server.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_start(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Stop server.
        /// Note: Server will be restarted on Murmur restart unless explicitly disabled
        /// with setConf("boot", false)
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void stop(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Stop server.
        /// Note: Server will be restarted on Murmur restart unless explicitly disabled
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task stopAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Stop server.
        /// Note: Server will be restarted on Murmur restart unless explicitly disabled
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_stop> begin_stop(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Stop server.
        /// Note: Server will be restarted on Murmur restart unless explicitly disabled
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_stop(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Stop server.
        /// Note: Server will be restarted on Murmur restart unless explicitly disabled
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_stop(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Stop server.
        /// Note: Server will be restarted on Murmur restart unless explicitly disabled
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_stop(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Delete server and all it's configuration.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void delete(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Delete server and all it's configuration.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task deleteAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Delete server and all it's configuration.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_delete> begin_delete(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Delete server and all it's configuration.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_delete(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Delete server and all it's configuration.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_delete(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Delete server and all it's configuration.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_delete(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Fetch the server id.
        /// </summary>
        /// <returns>Unique server id.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        int id(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch the server id.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> idAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch the server id.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_id> begin_id(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch the server id.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_id(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch the server id.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_id(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch the server id.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Unique server id.</returns>
        int end_id(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Add a callback.
        /// The callback will receive notifications about changes to users and channels.
        ///
        /// </summary>
        /// <param name="cb">Callback interface which will receive notifications.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void addCallback(ServerCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Add a callback.
        /// The callback will receive notifications about changes to users and channels.
        /// </summary>
        /// <param name="cb">Callback interface which will receive notifications.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task addCallbackAsync(ServerCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Add a callback.
        /// The callback will receive notifications about changes to users and channels.
        /// </summary>
        /// <param name="cb">Callback interface which will receive notifications.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_addCallback> begin_addCallback(ServerCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Add a callback.
        /// The callback will receive notifications about changes to users and channels.
        /// </summary>
        /// <param name="cb">Callback interface which will receive notifications.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_addCallback(ServerCallbackPrx cb, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Add a callback.
        /// The callback will receive notifications about changes to users and channels.
        /// </summary>
        /// <param name="cb">Callback interface which will receive notifications.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_addCallback(ServerCallbackPrx cb, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Add a callback.
        /// The callback will receive notifications about changes to users and channels.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_addCallback(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void removeCallback(ServerCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task removeCallbackAsync(ServerCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_removeCallback> begin_removeCallback(ServerCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_removeCallback(ServerCallbackPrx cb, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_removeCallback(ServerCallbackPrx cb, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_removeCallback(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Set external authenticator.
        /// If set, all authentications from clients are forwarded to this
        /// proxy.
        ///
        /// </summary>
        /// <param name="auth">Authenticator object to perform subsequent authentications.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setAuthenticator(ServerAuthenticatorPrx auth, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set external authenticator.
        /// If set, all authentications from clients are forwarded to this
        /// </summary>
        /// <param name="auth">Authenticator object to perform subsequent authentications.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setAuthenticatorAsync(ServerAuthenticatorPrx auth, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Set external authenticator.
        /// If set, all authentications from clients are forwarded to this
        /// </summary>
        /// <param name="auth">Authenticator object to perform subsequent authentications.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_setAuthenticator> begin_setAuthenticator(ServerAuthenticatorPrx auth, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set external authenticator.
        /// If set, all authentications from clients are forwarded to this
        /// </summary>
        /// <param name="auth">Authenticator object to perform subsequent authentications.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setAuthenticator(ServerAuthenticatorPrx auth, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set external authenticator.
        /// If set, all authentications from clients are forwarded to this
        /// </summary>
        /// <param name="auth">Authenticator object to perform subsequent authentications.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setAuthenticator(ServerAuthenticatorPrx auth, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set external authenticator.
        /// If set, all authentications from clients are forwarded to this
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_setAuthenticator(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Retrieve configuration item.
        /// </summary>
        /// <param name="key">Configuration key.
        /// </param>
        /// <returns>Configuration value. If this is empty, see Meta.getDefaultConf</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string getConf(string key, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Retrieve configuration item.
        /// </summary>
        /// <param name="key">Configuration key.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string> getConfAsync(string key, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Retrieve configuration item.
        /// </summary>
        /// <param name="key">Configuration key.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getConf> begin_getConf(string key, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Retrieve configuration item.
        /// </summary>
        /// <param name="key">Configuration key.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getConf(string key, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Retrieve configuration item.
        /// </summary>
        /// <param name="key">Configuration key.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getConf(string key, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Retrieve configuration item.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Configuration value. If this is empty, see Meta.getDefaultConf</returns>
        string end_getConf(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Retrieve all configuration items.
        /// </summary>
        /// <returns>All configured values. If a value isn't set here, the value from Meta.getDefaultConf is used.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::System.Collections.Generic.Dictionary<string, string> getAllConf(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Retrieve all configuration items.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, string>> getAllConfAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Retrieve all configuration items.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getAllConf> begin_getAllConf(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Retrieve all configuration items.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getAllConf(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Retrieve all configuration items.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getAllConf(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Retrieve all configuration items.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>All configured values. If a value isn't set here, the value from Meta.getDefaultConf is used.</returns>
        global::System.Collections.Generic.Dictionary<string, string> end_getAllConf(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Set a configuration item.
        /// </summary>
        /// <param name="key">Configuration key.
        /// </param>
        /// <param name="value">Configuration value.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setConf(string key, string value, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set a configuration item.
        /// </summary>
        /// <param name="key">Configuration key.
        /// </param>
        /// <param name="value">Configuration value.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setConfAsync(string key, string value, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Set a configuration item.
        /// </summary>
        /// <param name="key">Configuration key.
        /// </param>
        /// <param name="value">Configuration value.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_setConf> begin_setConf(string key, string value, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set a configuration item.
        /// </summary>
        /// <param name="key">Configuration key.
        /// </param>
        /// <param name="value">Configuration value.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setConf(string key, string value, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set a configuration item.
        /// </summary>
        /// <param name="key">Configuration key.
        /// </param>
        /// <param name="value">Configuration value.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setConf(string key, string value, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set a configuration item.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_setConf(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Set superuser password.
        /// This is just a convenience for using updateRegistration on user id 0.
        /// </summary>
        /// <param name="pw">Password.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setSuperuserPassword(string pw, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set superuser password.
        /// This is just a convenience for using updateRegistration on user id 0.
        /// </summary>
        /// <param name="pw">Password.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setSuperuserPasswordAsync(string pw, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Set superuser password.
        /// This is just a convenience for using updateRegistration on user id 0.
        /// </summary>
        /// <param name="pw">Password.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_setSuperuserPassword> begin_setSuperuserPassword(string pw, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set superuser password.
        /// This is just a convenience for using updateRegistration on user id 0.
        /// </summary>
        /// <param name="pw">Password.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setSuperuserPassword(string pw, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set superuser password.
        /// This is just a convenience for using updateRegistration on user id 0.
        /// </summary>
        /// <param name="pw">Password.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setSuperuserPassword(string pw, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set superuser password.
        /// This is just a convenience for using updateRegistration on user id 0.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_setSuperuserPassword(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Fetch log entries.
        /// </summary>
        /// <param name="first">Lowest numbered entry to fetch. 0 is the most recent item.
        /// </param>
        /// <param name="last">Last entry to fetch.
        /// </param>
        /// <returns>List of log entries.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        LogEntry[] getLog(int first, int last, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch log entries.
        /// </summary>
        /// <param name="first">Lowest numbered entry to fetch. 0 is the most recent item.
        /// </param>
        /// <param name="last">Last entry to fetch.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<LogEntry[]> getLogAsync(int first, int last, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch log entries.
        /// </summary>
        /// <param name="first">Lowest numbered entry to fetch. 0 is the most recent item.
        /// </param>
        /// <param name="last">Last entry to fetch.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getLog> begin_getLog(int first, int last, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch log entries.
        /// </summary>
        /// <param name="first">Lowest numbered entry to fetch. 0 is the most recent item.
        /// </param>
        /// <param name="last">Last entry to fetch.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getLog(int first, int last, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch log entries.
        /// </summary>
        /// <param name="first">Lowest numbered entry to fetch. 0 is the most recent item.
        /// </param>
        /// <param name="last">Last entry to fetch.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getLog(int first, int last, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch log entries.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>List of log entries.</returns>
        LogEntry[] end_getLog(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Fetch length of log
        /// </summary>
        /// <returns>Number of entries in log</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        int getLogLen(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch length of log
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> getLogLenAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch length of log
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getLogLen> begin_getLogLen(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch length of log
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getLogLen(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch length of log
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getLogLen(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch length of log
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Number of entries in log</returns>
        int end_getLogLen(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Fetch all users.
        /// This returns all currently connected users on the server.
        /// </summary>
        /// <returns>List of connected users.
        /// </returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::System.Collections.Generic.Dictionary<int, User> getUsers(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch all users.
        /// This returns all currently connected users on the server.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, User>> getUsersAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch all users.
        /// This returns all currently connected users on the server.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getUsers> begin_getUsers(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch all users.
        /// This returns all currently connected users on the server.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getUsers(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch all users.
        /// This returns all currently connected users on the server.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getUsers(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch all users.
        /// This returns all currently connected users on the server.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>List of connected users.
        /// </returns>
        global::System.Collections.Generic.Dictionary<int, User> end_getUsers(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Fetch all channels.
        /// This returns all defined channels on the server. The root channel is always channel 0.
        /// </summary>
        /// <returns>List of defined channels.
        /// </returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::System.Collections.Generic.Dictionary<int, Channel> getChannels(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch all channels.
        /// This returns all defined channels on the server. The root channel is always channel 0.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, Channel>> getChannelsAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch all channels.
        /// This returns all defined channels on the server. The root channel is always channel 0.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getChannels> begin_getChannels(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch all channels.
        /// This returns all defined channels on the server. The root channel is always channel 0.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getChannels(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch all channels.
        /// This returns all defined channels on the server. The root channel is always channel 0.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getChannels(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch all channels.
        /// This returns all defined channels on the server. The root channel is always channel 0.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>List of defined channels.
        /// </returns>
        global::System.Collections.Generic.Dictionary<int, Channel> end_getChannels(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Fetch certificate of user.
        /// This returns the complete certificate chain of a user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <returns>Certificate list of user.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        byte[][] getCertificateList(int session, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch certificate of user.
        /// This returns the complete certificate chain of a user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<byte[][]> getCertificateListAsync(int session, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch certificate of user.
        /// This returns the complete certificate chain of a user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getCertificateList> begin_getCertificateList(int session, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch certificate of user.
        /// This returns the complete certificate chain of a user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getCertificateList(int session, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch certificate of user.
        /// This returns the complete certificate chain of a user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getCertificateList(int session, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch certificate of user.
        /// This returns the complete certificate chain of a user.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Certificate list of user.</returns>
        byte[][] end_getCertificateList(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Fetch all channels and connected users as a tree.
        /// This retrieves an easy-to-use representation of the server
        /// as a tree. This is primarily used for viewing the state of the server on a webpage.
        /// </summary>
        /// <returns>Recursive tree of all channels and connected users.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        Tree getTree(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch all channels and connected users as a tree.
        /// This retrieves an easy-to-use representation of the server
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<Tree> getTreeAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch all channels and connected users as a tree.
        /// This retrieves an easy-to-use representation of the server
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getTree> begin_getTree(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch all channels and connected users as a tree.
        /// This retrieves an easy-to-use representation of the server
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getTree(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch all channels and connected users as a tree.
        /// This retrieves an easy-to-use representation of the server
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getTree(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch all channels and connected users as a tree.
        /// This retrieves an easy-to-use representation of the server
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Recursive tree of all channels and connected users.</returns>
        Tree end_getTree(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Fetch all current IP bans on the server.
        /// </summary>
        /// <returns>List of bans.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        Ban[] getBans(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch all current IP bans on the server.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<Ban[]> getBansAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch all current IP bans on the server.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getBans> begin_getBans(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch all current IP bans on the server.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getBans(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch all current IP bans on the server.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getBans(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch all current IP bans on the server.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>List of bans.</returns>
        Ban[] end_getBans(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Set all current IP bans on the server.
        /// This will replace any bans already present, so if you want to add a ban, be sure to call getBans and then
        /// append to the returned list before calling this method.
        /// </summary>
        /// <param name="bans">List of bans.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setBans(Ban[] bans, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set all current IP bans on the server.
        /// This will replace any bans already present, so if you want to add a ban, be sure to call getBans and then
        /// </summary>
        /// <param name="bans">List of bans.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setBansAsync(Ban[] bans, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Set all current IP bans on the server.
        /// This will replace any bans already present, so if you want to add a ban, be sure to call getBans and then
        /// </summary>
        /// <param name="bans">List of bans.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_setBans> begin_setBans(Ban[] bans, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set all current IP bans on the server.
        /// This will replace any bans already present, so if you want to add a ban, be sure to call getBans and then
        /// </summary>
        /// <param name="bans">List of bans.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setBans(Ban[] bans, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set all current IP bans on the server.
        /// This will replace any bans already present, so if you want to add a ban, be sure to call getBans and then
        /// </summary>
        /// <param name="bans">List of bans.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setBans(Ban[] bans, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set all current IP bans on the server.
        /// This will replace any bans already present, so if you want to add a ban, be sure to call getBans and then
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_setBans(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Kick a user.
        /// The user is not banned, and is free to rejoin the server.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="reason">Text message to show when user is kicked.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void kickUser(int session, string reason, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Kick a user.
        /// The user is not banned, and is free to rejoin the server.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="reason">Text message to show when user is kicked.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task kickUserAsync(int session, string reason, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Kick a user.
        /// The user is not banned, and is free to rejoin the server.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="reason">Text message to show when user is kicked.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_kickUser> begin_kickUser(int session, string reason, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Kick a user.
        /// The user is not banned, and is free to rejoin the server.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="reason">Text message to show when user is kicked.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_kickUser(int session, string reason, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Kick a user.
        /// The user is not banned, and is free to rejoin the server.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="reason">Text message to show when user is kicked.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_kickUser(int session, string reason, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Kick a user.
        /// The user is not banned, and is free to rejoin the server.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_kickUser(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Get state of a single connected user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <returns>State of connected user.
        /// </returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        User getState(int session, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get state of a single connected user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<User> getStateAsync(int session, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get state of a single connected user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getState> begin_getState(int session, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get state of a single connected user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getState(int session, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Get state of a single connected user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getState(int session, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Get state of a single connected user.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>State of connected user.
        /// </returns>
        User end_getState(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Set user state.
        /// You can use this to move, mute and deafen users.
        /// </summary>
        /// <param name="state">User state to set.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setState(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set user state.
        /// You can use this to move, mute and deafen users.
        /// </summary>
        /// <param name="state">User state to set.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setStateAsync(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Set user state.
        /// You can use this to move, mute and deafen users.
        /// </summary>
        /// <param name="state">User state to set.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_setState> begin_setState(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set user state.
        /// You can use this to move, mute and deafen users.
        /// </summary>
        /// <param name="state">User state to set.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setState(User state, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set user state.
        /// You can use this to move, mute and deafen users.
        /// </summary>
        /// <param name="state">User state to set.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setState(User state, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set user state.
        /// You can use this to move, mute and deafen users.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_setState(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Send text message to a single user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="text">Message to send.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void sendMessage(int session, string text, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Send text message to a single user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="text">Message to send.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task sendMessageAsync(int session, string text, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Send text message to a single user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="text">Message to send.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_sendMessage> begin_sendMessage(int session, string text, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Send text message to a single user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="text">Message to send.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_sendMessage(int session, string text, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Send text message to a single user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="text">Message to send.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_sendMessage(int session, string text, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Send text message to a single user.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_sendMessage(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Check if user is permitted to perform action.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <param name="perm">Permission bits to check.
        /// </param>
        /// <returns>true if any of the permissions in perm were set for the user.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        bool hasPermission(int session, int channelid, int perm, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Check if user is permitted to perform action.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <param name="perm">Permission bits to check.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<bool> hasPermissionAsync(int session, int channelid, int perm, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Check if user is permitted to perform action.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <param name="perm">Permission bits to check.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_hasPermission> begin_hasPermission(int session, int channelid, int perm, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Check if user is permitted to perform action.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <param name="perm">Permission bits to check.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_hasPermission(int session, int channelid, int perm, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Check if user is permitted to perform action.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <param name="perm">Permission bits to check.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_hasPermission(int session, int channelid, int perm, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Check if user is permitted to perform action.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>true if any of the permissions in perm were set for the user.</returns>
        bool end_hasPermission(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Return users effective permissions
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <returns>bitfield of allowed actions</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        int effectivePermissions(int session, int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Return users effective permissions
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> effectivePermissionsAsync(int session, int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Return users effective permissions
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_effectivePermissions> begin_effectivePermissions(int session, int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Return users effective permissions
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_effectivePermissions(int session, int channelid, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Return users effective permissions
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_effectivePermissions(int session, int channelid, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Return users effective permissions
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>bitfield of allowed actions</returns>
        int end_effectivePermissions(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Add a context callback.
        /// This is done per user, and will add a context menu action for the user.
        ///
        /// </summary>
        /// <param name="session">Session of user which should receive context entry.
        /// </param>
        /// <param name="action">Action string, a unique name to associate with the action.
        /// </param>
        /// <param name="text">Name of action shown to user.
        /// </param>
        /// <param name="cb">Callback interface which will receive notifications.
        /// </param>
        /// <param name="ctx">Context this should be used in. Needs to be one or a combination of ContextServer, ContextChannel and ContextUser.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void addContextCallback(int session, string action, string text, ServerContextCallbackPrx cb, int ctx, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Add a context callback.
        /// This is done per user, and will add a context menu action for the user.
        /// </summary>
        /// <param name="session">Session of user which should receive context entry.
        /// </param>
        /// <param name="action">Action string, a unique name to associate with the action.
        /// </param>
        /// <param name="text">Name of action shown to user.
        /// </param>
        /// <param name="cb">Callback interface which will receive notifications.
        /// </param>
        /// <param name="ctx">Context this should be used in. Needs to be one or a combination of ContextServer, ContextChannel and ContextUser.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task addContextCallbackAsync(int session, string action, string text, ServerContextCallbackPrx cb, int ctx, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Add a context callback.
        /// This is done per user, and will add a context menu action for the user.
        /// </summary>
        /// <param name="session">Session of user which should receive context entry.
        /// </param>
        /// <param name="action">Action string, a unique name to associate with the action.
        /// </param>
        /// <param name="text">Name of action shown to user.
        /// </param>
        /// <param name="cb">Callback interface which will receive notifications.
        /// </param>
        /// <param name="ctx">Context this should be used in. Needs to be one or a combination of ContextServer, ContextChannel and ContextUser.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_addContextCallback> begin_addContextCallback(int session, string action, string text, ServerContextCallbackPrx cb, int ctx, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Add a context callback.
        /// This is done per user, and will add a context menu action for the user.
        /// </summary>
        /// <param name="session">Session of user which should receive context entry.
        /// </param>
        /// <param name="action">Action string, a unique name to associate with the action.
        /// </param>
        /// <param name="text">Name of action shown to user.
        /// </param>
        /// <param name="cb">Callback interface which will receive notifications.
        /// </param>
        /// <param name="ctx">Context this should be used in. Needs to be one or a combination of ContextServer, ContextChannel and ContextUser.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_addContextCallback(int session, string action, string text, ServerContextCallbackPrx cb, int ctx, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Add a context callback.
        /// This is done per user, and will add a context menu action for the user.
        /// </summary>
        /// <param name="session">Session of user which should receive context entry.
        /// </param>
        /// <param name="action">Action string, a unique name to associate with the action.
        /// </param>
        /// <param name="text">Name of action shown to user.
        /// </param>
        /// <param name="cb">Callback interface which will receive notifications.
        /// </param>
        /// <param name="ctx">Context this should be used in. Needs to be one or a combination of ContextServer, ContextChannel and ContextUser.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_addContextCallback(int session, string action, string text, ServerContextCallbackPrx cb, int ctx, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Add a context callback.
        /// This is done per user, and will add a context menu action for the user.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_addContextCallback(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed. This callback will be removed from all from all users.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void removeContextCallback(ServerContextCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed. This callback will be removed from all from all users.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task removeContextCallbackAsync(ServerContextCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed. This callback will be removed from all from all users.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_removeContextCallback> begin_removeContextCallback(ServerContextCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed. This callback will be removed from all from all users.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_removeContextCallback(ServerContextCallbackPrx cb, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed. This callback will be removed from all from all users.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_removeContextCallback(ServerContextCallbackPrx cb, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_removeContextCallback(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Get state of single channel.
        /// </summary>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <returns>State of channel.
        /// </returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        Channel getChannelState(int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get state of single channel.
        /// </summary>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<Channel> getChannelStateAsync(int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get state of single channel.
        /// </summary>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getChannelState> begin_getChannelState(int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get state of single channel.
        /// </summary>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getChannelState(int channelid, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Get state of single channel.
        /// </summary>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getChannelState(int channelid, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Get state of single channel.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>State of channel.
        /// </returns>
        Channel end_getChannelState(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Set state of a single channel.
        /// You can use this to move or relink channels.
        /// </summary>
        /// <param name="state">Channel state to set.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setChannelState(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set state of a single channel.
        /// You can use this to move or relink channels.
        /// </summary>
        /// <param name="state">Channel state to set.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setChannelStateAsync(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Set state of a single channel.
        /// You can use this to move or relink channels.
        /// </summary>
        /// <param name="state">Channel state to set.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_setChannelState> begin_setChannelState(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set state of a single channel.
        /// You can use this to move or relink channels.
        /// </summary>
        /// <param name="state">Channel state to set.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setChannelState(Channel state, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set state of a single channel.
        /// You can use this to move or relink channels.
        /// </summary>
        /// <param name="state">Channel state to set.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setChannelState(Channel state, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set state of a single channel.
        /// You can use this to move or relink channels.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_setChannelState(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Remove a channel and all its subchannels.
        /// </summary>
        /// <param name="channelid">ID of Channel. See Channel.id.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void removeChannel(int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Remove a channel and all its subchannels.
        /// </summary>
        /// <param name="channelid">ID of Channel. See Channel.id.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task removeChannelAsync(int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Remove a channel and all its subchannels.
        /// </summary>
        /// <param name="channelid">ID of Channel. See Channel.id.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_removeChannel> begin_removeChannel(int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Remove a channel and all its subchannels.
        /// </summary>
        /// <param name="channelid">ID of Channel. See Channel.id.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_removeChannel(int channelid, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Remove a channel and all its subchannels.
        /// </summary>
        /// <param name="channelid">ID of Channel. See Channel.id.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_removeChannel(int channelid, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Remove a channel and all its subchannels.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_removeChannel(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Add a new channel.
        /// </summary>
        /// <param name="name">Name of new channel.
        /// </param>
        /// <param name="parent">Channel ID of parent channel. See Channel.id.
        /// </param>
        /// <returns>ID of newly created channel.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        int addChannel(string name, int parent, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Add a new channel.
        /// </summary>
        /// <param name="name">Name of new channel.
        /// </param>
        /// <param name="parent">Channel ID of parent channel. See Channel.id.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> addChannelAsync(string name, int parent, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Add a new channel.
        /// </summary>
        /// <param name="name">Name of new channel.
        /// </param>
        /// <param name="parent">Channel ID of parent channel. See Channel.id.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_addChannel> begin_addChannel(string name, int parent, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Add a new channel.
        /// </summary>
        /// <param name="name">Name of new channel.
        /// </param>
        /// <param name="parent">Channel ID of parent channel. See Channel.id.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_addChannel(string name, int parent, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Add a new channel.
        /// </summary>
        /// <param name="name">Name of new channel.
        /// </param>
        /// <param name="parent">Channel ID of parent channel. See Channel.id.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_addChannel(string name, int parent, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Add a new channel.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>ID of newly created channel.</returns>
        int end_addChannel(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Send text message to channel or a tree of channels.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to send to. See Channel.id.
        /// </param>
        /// <param name="tree">If true, the message will be sent to the channel and all its subchannels.
        /// </param>
        /// <param name="text">Message to send.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void sendMessageChannel(int channelid, bool tree, string text, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Send text message to channel or a tree of channels.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to send to. See Channel.id.
        /// </param>
        /// <param name="tree">If true, the message will be sent to the channel and all its subchannels.
        /// </param>
        /// <param name="text">Message to send.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task sendMessageChannelAsync(int channelid, bool tree, string text, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Send text message to channel or a tree of channels.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to send to. See Channel.id.
        /// </param>
        /// <param name="tree">If true, the message will be sent to the channel and all its subchannels.
        /// </param>
        /// <param name="text">Message to send.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_sendMessageChannel> begin_sendMessageChannel(int channelid, bool tree, string text, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Send text message to channel or a tree of channels.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to send to. See Channel.id.
        /// </param>
        /// <param name="tree">If true, the message will be sent to the channel and all its subchannels.
        /// </param>
        /// <param name="text">Message to send.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_sendMessageChannel(int channelid, bool tree, string text, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Send text message to channel or a tree of channels.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to send to. See Channel.id.
        /// </param>
        /// <param name="tree">If true, the message will be sent to the channel and all its subchannels.
        /// </param>
        /// <param name="text">Message to send.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_sendMessageChannel(int channelid, bool tree, string text, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Send text message to channel or a tree of channels.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_sendMessageChannel(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Retrieve ACLs and Groups on a channel.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to fetch from. See Channel.id.
        /// </param>
        /// <param name="acls">List of ACLs on the channel. This will include inherited ACLs.
        /// </param>
        /// <param name="groups">List of groups on the channel. This will include inherited groups.
        /// </param>
        /// <param name="inherit">Does this channel inherit ACLs from the parent channel?</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void getACL(int channelid, out ACL[] acls, out Group[] groups, out bool inherit, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Retrieve ACLs and Groups on a channel.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to fetch from. See Channel.id.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<Server_GetACLResult> getACLAsync(int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Retrieve ACLs and Groups on a channel.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to fetch from. See Channel.id.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getACL> begin_getACL(int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Retrieve ACLs and Groups on a channel.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to fetch from. See Channel.id.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getACL(int channelid, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Retrieve ACLs and Groups on a channel.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to fetch from. See Channel.id.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getACL(int channelid, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Retrieve ACLs and Groups on a channel.
        /// </summary>
        /// <param name="acls">List of ACLs on the channel. This will include inherited ACLs.
        /// </param>
        /// <param name="groups">List of groups on the channel. This will include inherited groups.
        /// </param>
        /// <param name="inherit">Does this channel inherit ACLs from the parent channel?</param>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_getACL(out ACL[] acls, out Group[] groups, out bool inherit, global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Set ACLs and Groups on a channel.
        /// Note that this will replace all existing ACLs and groups on the channel.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to fetch from. See Channel.id.
        /// </param>
        /// <param name="acls">List of ACLs on the channel.
        /// </param>
        /// <param name="groups">List of groups on the channel.
        /// </param>
        /// <param name="inherit">Should this channel inherit ACLs from the parent channel?</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setACL(int channelid, ACL[] acls, Group[] groups, bool inherit, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set ACLs and Groups on a channel.
        /// Note that this will replace all existing ACLs and groups on the channel.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to fetch from. See Channel.id.
        /// </param>
        /// <param name="acls">List of ACLs on the channel.
        /// </param>
        /// <param name="groups">List of groups on the channel.
        /// </param>
        /// <param name="inherit">Should this channel inherit ACLs from the parent channel?</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setACLAsync(int channelid, ACL[] acls, Group[] groups, bool inherit, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Set ACLs and Groups on a channel.
        /// Note that this will replace all existing ACLs and groups on the channel.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to fetch from. See Channel.id.
        /// </param>
        /// <param name="acls">List of ACLs on the channel.
        /// </param>
        /// <param name="groups">List of groups on the channel.
        /// </param>
        /// <param name="inherit">Should this channel inherit ACLs from the parent channel?</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_setACL> begin_setACL(int channelid, ACL[] acls, Group[] groups, bool inherit, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set ACLs and Groups on a channel.
        /// Note that this will replace all existing ACLs and groups on the channel.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to fetch from. See Channel.id.
        /// </param>
        /// <param name="acls">List of ACLs on the channel.
        /// </param>
        /// <param name="groups">List of groups on the channel.
        /// </param>
        /// <param name="inherit">Should this channel inherit ACLs from the parent channel?</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setACL(int channelid, ACL[] acls, Group[] groups, bool inherit, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set ACLs and Groups on a channel.
        /// Note that this will replace all existing ACLs and groups on the channel.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to fetch from. See Channel.id.
        /// </param>
        /// <param name="acls">List of ACLs on the channel.
        /// </param>
        /// <param name="groups">List of groups on the channel.
        /// </param>
        /// <param name="inherit">Should this channel inherit ACLs from the parent channel?</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setACL(int channelid, ACL[] acls, Group[] groups, bool inherit, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set ACLs and Groups on a channel.
        /// Note that this will replace all existing ACLs and groups on the channel.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_setACL(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Temporarily add a user to a group on a channel.
        /// This state is not saved, and is intended for temporary memberships.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to add to. See Channel.id.
        /// </param>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="group">Group name to add to.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void addUserToGroup(int channelid, int session, string group, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Temporarily add a user to a group on a channel.
        /// This state is not saved, and is intended for temporary memberships.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to add to. See Channel.id.
        /// </param>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="group">Group name to add to.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task addUserToGroupAsync(int channelid, int session, string group, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Temporarily add a user to a group on a channel.
        /// This state is not saved, and is intended for temporary memberships.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to add to. See Channel.id.
        /// </param>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="group">Group name to add to.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_addUserToGroup> begin_addUserToGroup(int channelid, int session, string group, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Temporarily add a user to a group on a channel.
        /// This state is not saved, and is intended for temporary memberships.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to add to. See Channel.id.
        /// </param>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="group">Group name to add to.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_addUserToGroup(int channelid, int session, string group, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Temporarily add a user to a group on a channel.
        /// This state is not saved, and is intended for temporary memberships.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to add to. See Channel.id.
        /// </param>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="group">Group name to add to.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_addUserToGroup(int channelid, int session, string group, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Temporarily add a user to a group on a channel.
        /// This state is not saved, and is intended for temporary memberships.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_addUserToGroup(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Remove a user from a temporary group membership on a channel.
        /// This state is not saved, and is intended for temporary memberships.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to add to. See Channel.id.
        /// </param>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="group">Group name to remove from.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void removeUserFromGroup(int channelid, int session, string group, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Remove a user from a temporary group membership on a channel.
        /// This state is not saved, and is intended for temporary memberships.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to add to. See Channel.id.
        /// </param>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="group">Group name to remove from.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task removeUserFromGroupAsync(int channelid, int session, string group, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Remove a user from a temporary group membership on a channel.
        /// This state is not saved, and is intended for temporary memberships.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to add to. See Channel.id.
        /// </param>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="group">Group name to remove from.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_removeUserFromGroup> begin_removeUserFromGroup(int channelid, int session, string group, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Remove a user from a temporary group membership on a channel.
        /// This state is not saved, and is intended for temporary memberships.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to add to. See Channel.id.
        /// </param>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="group">Group name to remove from.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_removeUserFromGroup(int channelid, int session, string group, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Remove a user from a temporary group membership on a channel.
        /// This state is not saved, and is intended for temporary memberships.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to add to. See Channel.id.
        /// </param>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="group">Group name to remove from.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_removeUserFromGroup(int channelid, int session, string group, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Remove a user from a temporary group membership on a channel.
        /// This state is not saved, and is intended for temporary memberships.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_removeUserFromGroup(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Redirect whisper targets for user.
        /// If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
        /// To remove a redirect pass an empty target string. This is intended for context groups.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="source">Group name to redirect from.
        /// </param>
        /// <param name="target">Group name to redirect to.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void redirectWhisperGroup(int session, string source, string target, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Redirect whisper targets for user.
        /// If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="source">Group name to redirect from.
        /// </param>
        /// <param name="target">Group name to redirect to.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task redirectWhisperGroupAsync(int session, string source, string target, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Redirect whisper targets for user.
        /// If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="source">Group name to redirect from.
        /// </param>
        /// <param name="target">Group name to redirect to.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_redirectWhisperGroup> begin_redirectWhisperGroup(int session, string source, string target, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Redirect whisper targets for user.
        /// If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="source">Group name to redirect from.
        /// </param>
        /// <param name="target">Group name to redirect to.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_redirectWhisperGroup(int session, string source, string target, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Redirect whisper targets for user.
        /// If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="source">Group name to redirect from.
        /// </param>
        /// <param name="target">Group name to redirect to.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_redirectWhisperGroup(int session, string source, string target, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Redirect whisper targets for user.
        /// If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_redirectWhisperGroup(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Map a list of User.userid to a matching name.
        /// </summary>
        /// <param name="List">of ids.
        /// </param>
        /// <returns>Matching list of names, with an empty string representing invalid or unknown ids.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::System.Collections.Generic.Dictionary<int, string> getUserNames(int[] ids, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Map a list of User.userid to a matching name.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, string>> getUserNamesAsync(int[] ids, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Map a list of User.userid to a matching name.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getUserNames> begin_getUserNames(int[] ids, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Map a list of User.userid to a matching name.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getUserNames(int[] ids, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Map a list of User.userid to a matching name.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getUserNames(int[] ids, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Map a list of User.userid to a matching name.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Matching list of names, with an empty string representing invalid or unknown ids.</returns>
        global::System.Collections.Generic.Dictionary<int, string> end_getUserNames(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Map a list of user names to a matching id.
        /// </summary>
        /// <param name="List">of names.
        /// </param>
        /// @reuturn List of matching ids, with -1 representing invalid or unknown user names.
        /// <param name="context">The Context map to send with the invocation.</param>

        global::System.Collections.Generic.Dictionary<string, int> getUserIds(string[] names, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Map a list of user names to a matching id.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, int>> getUserIdsAsync(string[] names, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Map a list of user names to a matching id.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getUserIds> begin_getUserIds(string[] names, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Map a list of user names to a matching id.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getUserIds(string[] names, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Map a list of user names to a matching id.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getUserIds(string[] names, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Map a list of user names to a matching id.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        global::System.Collections.Generic.Dictionary<string, int> end_getUserIds(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Register a new user.
        /// </summary>
        /// <param name="info">Information about new user. Must include at least "name".
        /// </param>
        /// <returns>The ID of the user. See RegisteredUser.userid.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        int registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Register a new user.
        /// </summary>
        /// <param name="info">Information about new user. Must include at least "name".
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> registerUserAsync(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Register a new user.
        /// </summary>
        /// <param name="info">Information about new user. Must include at least "name".
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_registerUser> begin_registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Register a new user.
        /// </summary>
        /// <param name="info">Information about new user. Must include at least "name".
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Register a new user.
        /// </summary>
        /// <param name="info">Information about new user. Must include at least "name".
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Register a new user.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>The ID of the user. See RegisteredUser.userid.</returns>
        int end_registerUser(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Remove a user registration.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void unregisterUser(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Remove a user registration.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task unregisterUserAsync(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Remove a user registration.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_unregisterUser> begin_unregisterUser(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Remove a user registration.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_unregisterUser(int userid, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Remove a user registration.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_unregisterUser(int userid, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Remove a user registration.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_unregisterUser(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Update the registration for a user.
        /// You can use this to set the email or password of a user,
        /// and can also use it to change the user's name.
        /// </summary>
        /// <param name="registration">Updated registration record.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void updateRegistration(int userid, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Update the registration for a user.
        /// You can use this to set the email or password of a user,
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task updateRegistrationAsync(int userid, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Update the registration for a user.
        /// You can use this to set the email or password of a user,
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_updateRegistration> begin_updateRegistration(int userid, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Update the registration for a user.
        /// You can use this to set the email or password of a user,
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_updateRegistration(int userid, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Update the registration for a user.
        /// You can use this to set the email or password of a user,
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_updateRegistration(int userid, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Update the registration for a user.
        /// You can use this to set the email or password of a user,
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_updateRegistration(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Fetch registration for a single user.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <returns>Registration record.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::System.Collections.Generic.Dictionary<UserInfo, string> getRegistration(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch registration for a single user.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<UserInfo, string>> getRegistrationAsync(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch registration for a single user.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getRegistration> begin_getRegistration(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch registration for a single user.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getRegistration(int userid, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch registration for a single user.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getRegistration(int userid, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch registration for a single user.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Registration record.</returns>
        global::System.Collections.Generic.Dictionary<UserInfo, string> end_getRegistration(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Fetch a group of registered users.
        /// </summary>
        /// <param name="filter">Substring of user name. If blank, will retrieve all registered users.
        /// </param>
        /// <returns>List of registration records.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::System.Collections.Generic.Dictionary<int, string> getRegisteredUsers(string filter, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch a group of registered users.
        /// </summary>
        /// <param name="filter">Substring of user name. If blank, will retrieve all registered users.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, string>> getRegisteredUsersAsync(string filter, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch a group of registered users.
        /// </summary>
        /// <param name="filter">Substring of user name. If blank, will retrieve all registered users.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getRegisteredUsers> begin_getRegisteredUsers(string filter, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch a group of registered users.
        /// </summary>
        /// <param name="filter">Substring of user name. If blank, will retrieve all registered users.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getRegisteredUsers(string filter, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch a group of registered users.
        /// </summary>
        /// <param name="filter">Substring of user name. If blank, will retrieve all registered users.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getRegisteredUsers(string filter, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch a group of registered users.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>List of registration records.</returns>
        global::System.Collections.Generic.Dictionary<int, string> end_getRegisteredUsers(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Verify the password of a user.
        /// You can use this to verify a user's credentials.
        /// </summary>
        /// <param name="name">User name. See RegisteredUser.name.
        /// </param>
        /// <param name="pw">User password.
        /// </param>
        /// <returns>User ID of registered user (See RegisteredUser.userid), -1 for failed authentication or -2 for unknown usernames.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        int verifyPassword(string name, string pw, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Verify the password of a user.
        /// You can use this to verify a user's credentials.
        /// </summary>
        /// <param name="name">User name. See RegisteredUser.name.
        /// </param>
        /// <param name="pw">User password.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> verifyPasswordAsync(string name, string pw, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Verify the password of a user.
        /// You can use this to verify a user's credentials.
        /// </summary>
        /// <param name="name">User name. See RegisteredUser.name.
        /// </param>
        /// <param name="pw">User password.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_verifyPassword> begin_verifyPassword(string name, string pw, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Verify the password of a user.
        /// You can use this to verify a user's credentials.
        /// </summary>
        /// <param name="name">User name. See RegisteredUser.name.
        /// </param>
        /// <param name="pw">User password.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_verifyPassword(string name, string pw, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Verify the password of a user.
        /// You can use this to verify a user's credentials.
        /// </summary>
        /// <param name="name">User name. See RegisteredUser.name.
        /// </param>
        /// <param name="pw">User password.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_verifyPassword(string name, string pw, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Verify the password of a user.
        /// You can use this to verify a user's credentials.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>User ID of registered user (See RegisteredUser.userid), -1 for failed authentication or -2 for unknown usernames.</returns>
        int end_verifyPassword(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Fetch user texture.
        /// Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <returns>Custom texture associated with user or an empty texture.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        byte[] getTexture(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch user texture.
        /// Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<byte[]> getTextureAsync(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch user texture.
        /// Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getTexture> begin_getTexture(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch user texture.
        /// Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getTexture(int userid, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch user texture.
        /// Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getTexture(int userid, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch user texture.
        /// Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Custom texture associated with user or an empty texture.</returns>
        byte[] end_getTexture(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Set a user texture (now called avatar).
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <param name="tex">Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setTexture(int userid, byte[] tex, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set a user texture (now called avatar).
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <param name="tex">Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setTextureAsync(int userid, byte[] tex, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Set a user texture (now called avatar).
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <param name="tex">Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_setTexture> begin_setTexture(int userid, byte[] tex, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set a user texture (now called avatar).
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <param name="tex">Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setTexture(int userid, byte[] tex, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set a user texture (now called avatar).
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <param name="tex">Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_setTexture(int userid, byte[] tex, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Set a user texture (now called avatar).
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_setTexture(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Get virtual server uptime.
        /// </summary>
        /// <returns>Uptime of the virtual server in seconds</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        int getUptime(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get virtual server uptime.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> getUptimeAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get virtual server uptime.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_getUptime> begin_getUptime(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get virtual server uptime.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getUptime(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Get virtual server uptime.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getUptime(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Get virtual server uptime.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Uptime of the virtual server in seconds</returns>
        int end_getUptime(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Update the server's certificate information.
        /// Reconfigure the running server's TLS socket with the given
        /// certificate and private key.
        ///
        /// The certificate and and private key must be PEM formatted.
        ///
        /// New clients will see the new certificate.
        /// Existing clients will continue to see the certificate the server
        /// was using when they connected to it.
        ///
        /// This method throws InvalidInputDataException if any of the
        /// following errors happen:
        /// - Unable to decode the PEM certificate and/or private key.
        /// - Unable to decrypt the private key with the given passphrase.
        /// - The certificate and/or private key do not contain RSA keys.
        /// - The certificate is not usable with the given private key.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void updateCertificate(string certificate, string privateKey, string passphrase, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Update the server's certificate information.
        /// Reconfigure the running server's TLS socket with the given
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task updateCertificateAsync(string certificate, string privateKey, string passphrase, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Update the server's certificate information.
        /// Reconfigure the running server's TLS socket with the given
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Server_updateCertificate> begin_updateCertificate(string certificate, string privateKey, string passphrase, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Update the server's certificate information.
        /// Reconfigure the running server's TLS socket with the given
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_updateCertificate(string certificate, string privateKey, string passphrase, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Update the server's certificate information.
        /// Reconfigure the running server's TLS socket with the given
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_updateCertificate(string certificate, string privateKey, string passphrase, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Update the server's certificate information.
        /// Reconfigure the running server's TLS socket with the given
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_updateCertificate(global::Ice.AsyncResult asyncResult);
    }

    /// <summary>
    /// Callback interface for Meta.
    /// You can supply an implementation of this to receive notifications
    /// when servers are stopped or started.
    /// If an added callback ever throws an exception or goes away, it will be automatically removed.
    /// Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
    /// complete before continuing processing.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public interface MetaCallbackPrx : global::Ice.ObjectPrx
    {
        /// <summary>
        /// Called when a server is started.
        /// The server is up and running when this event is sent, so all methods that 
        /// need a running server will work.
        /// </summary>
        /// <param name="srv">Interface for started server.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void started(ServerPrx srv, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a server is started.
        /// The server is up and running when this event is sent, so all methods that 
        /// </summary>
        /// <param name="srv">Interface for started server.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task startedAsync(ServerPrx srv, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Called when a server is started.
        /// The server is up and running when this event is sent, so all methods that 
        /// </summary>
        /// <param name="srv">Interface for started server.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_MetaCallback_started> begin_started(ServerPrx srv, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a server is started.
        /// The server is up and running when this event is sent, so all methods that 
        /// </summary>
        /// <param name="srv">Interface for started server.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_started(ServerPrx srv, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a server is started.
        /// The server is up and running when this event is sent, so all methods that 
        /// </summary>
        /// <param name="srv">Interface for started server.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_started(ServerPrx srv, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a server is started.
        /// The server is up and running when this event is sent, so all methods that 
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_started(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Called when a server is stopped.
        /// The server is already stopped when this event is sent, so no methods that
        /// need a running server will work.
        /// </summary>
        /// <param name="srv">Interface for started server.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void stopped(ServerPrx srv, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a server is stopped.
        /// The server is already stopped when this event is sent, so no methods that
        /// </summary>
        /// <param name="srv">Interface for started server.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task stoppedAsync(ServerPrx srv, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Called when a server is stopped.
        /// The server is already stopped when this event is sent, so no methods that
        /// </summary>
        /// <param name="srv">Interface for started server.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_MetaCallback_stopped> begin_stopped(ServerPrx srv, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Called when a server is stopped.
        /// The server is already stopped when this event is sent, so no methods that
        /// </summary>
        /// <param name="srv">Interface for started server.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_stopped(ServerPrx srv, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a server is stopped.
        /// The server is already stopped when this event is sent, so no methods that
        /// </summary>
        /// <param name="srv">Interface for started server.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_stopped(ServerPrx srv, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Called when a server is stopped.
        /// The server is already stopped when this event is sent, so no methods that
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_stopped(global::Ice.AsyncResult asyncResult);
    }

    /// <summary>
    /// This is the meta interface.
    /// It is primarily used for retrieving the Server interfaces for each individual server.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public interface MetaPrx : global::Ice.ObjectPrx
    {
        /// <summary>
        /// Fetch interface to specific server.
        /// </summary>
        /// <param name="id">Server ID. See Server.getId.
        /// </param>
        /// <returns>Interface for specified server, or a null proxy if id is invalid.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        ServerPrx getServer(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch interface to specific server.
        /// </summary>
        /// <param name="id">Server ID. See Server.getId.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ServerPrx> getServerAsync(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch interface to specific server.
        /// </summary>
        /// <param name="id">Server ID. See Server.getId.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Meta_getServer> begin_getServer(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch interface to specific server.
        /// </summary>
        /// <param name="id">Server ID. See Server.getId.
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getServer(int id, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch interface to specific server.
        /// </summary>
        /// <param name="id">Server ID. See Server.getId.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getServer(int id, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch interface to specific server.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Interface for specified server, or a null proxy if id is invalid.</returns>
        ServerPrx end_getServer(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Create a new server.
        /// Call Server.getId on the returned interface to find it's ID.
        /// </summary>
        /// <returns>Interface for new server.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        ServerPrx newServer(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Create a new server.
        /// Call Server.getId on the returned interface to find it's ID.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ServerPrx> newServerAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Create a new server.
        /// Call Server.getId on the returned interface to find it's ID.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Meta_newServer> begin_newServer(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Create a new server.
        /// Call Server.getId on the returned interface to find it's ID.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_newServer(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Create a new server.
        /// Call Server.getId on the returned interface to find it's ID.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_newServer(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Create a new server.
        /// Call Server.getId on the returned interface to find it's ID.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Interface for new server.</returns>
        ServerPrx end_newServer(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Fetch list of all currently running servers.
        /// </summary>
        /// <returns>List of interfaces for running servers.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        ServerPrx[] getBootedServers(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch list of all currently running servers.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ServerPrx[]> getBootedServersAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch list of all currently running servers.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Meta_getBootedServers> begin_getBootedServers(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch list of all currently running servers.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getBootedServers(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch list of all currently running servers.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getBootedServers(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch list of all currently running servers.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>List of interfaces for running servers.</returns>
        ServerPrx[] end_getBootedServers(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Fetch list of all defined servers.
        /// </summary>
        /// <returns>List of interfaces for all servers.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        ServerPrx[] getAllServers(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch list of all defined servers.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ServerPrx[]> getAllServersAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch list of all defined servers.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Meta_getAllServers> begin_getAllServers(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch list of all defined servers.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getAllServers(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch list of all defined servers.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getAllServers(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch list of all defined servers.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>List of interfaces for all servers.</returns>
        ServerPrx[] end_getAllServers(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Fetch default configuraion.
        /// This returns the configuration items that were set in the configuration file, or
        /// the built-in default. The individual servers will use these values unless they have been overridden in the
        /// server specific configuration. The only special case is the port, which defaults to the value defined here +
        /// the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
        /// </summary>
        /// <returns>Default configuration of the servers.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::System.Collections.Generic.Dictionary<string, string> getDefaultConf(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch default configuraion.
        /// This returns the configuration items that were set in the configuration file, or
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, string>> getDefaultConfAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch default configuraion.
        /// This returns the configuration items that were set in the configuration file, or
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Meta_getDefaultConf> begin_getDefaultConf(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch default configuraion.
        /// This returns the configuration items that were set in the configuration file, or
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getDefaultConf(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch default configuraion.
        /// This returns the configuration items that were set in the configuration file, or
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getDefaultConf(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch default configuraion.
        /// This returns the configuration items that were set in the configuration file, or
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Default configuration of the servers.</returns>
        global::System.Collections.Generic.Dictionary<string, string> end_getDefaultConf(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Fetch version of Murmur.
        /// </summary>
        /// <param name="major">Major version.
        /// </param>
        /// <param name="minor">Minor version.
        /// </param>
        /// <param name="patch">Patchlevel.
        /// </param>
        /// <param name="text">Textual representation of version. Note that this may not match the major, minor and patch levels, as it
        /// may be simply the compile date or the SVN revision. This is usually the text you want to present to users.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void getVersion(out int major, out int minor, out int patch, out string text, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch version of Murmur.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<Meta_GetVersionResult> getVersionAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Fetch version of Murmur.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Meta_getVersion> begin_getVersion(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Fetch version of Murmur.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getVersion(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch version of Murmur.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getVersion(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Fetch version of Murmur.
        /// </summary>
        /// <param name="major">Major version.
        /// </param>
        /// <param name="minor">Minor version.
        /// </param>
        /// <param name="patch">Patchlevel.
        /// </param>
        /// <param name="text">Textual representation of version. Note that this may not match the major, minor and patch levels, as it
        /// may be simply the compile date or the SVN revision. This is usually the text you want to present to users.</param>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_getVersion(out int major, out int minor, out int patch, out string text, global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Add a callback.
        /// The callback will receive notifications when servers are started or stopped.
        ///
        /// </summary>
        /// <param name="cb">Callback interface which will receive notifications.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void addCallback(MetaCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Add a callback.
        /// The callback will receive notifications when servers are started or stopped.
        /// </summary>
        /// <param name="cb">Callback interface which will receive notifications.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task addCallbackAsync(MetaCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Add a callback.
        /// The callback will receive notifications when servers are started or stopped.
        /// </summary>
        /// <param name="cb">Callback interface which will receive notifications.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Meta_addCallback> begin_addCallback(MetaCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Add a callback.
        /// The callback will receive notifications when servers are started or stopped.
        /// </summary>
        /// <param name="cb">Callback interface which will receive notifications.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_addCallback(MetaCallbackPrx cb, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Add a callback.
        /// The callback will receive notifications when servers are started or stopped.
        /// </summary>
        /// <param name="cb">Callback interface which will receive notifications.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_addCallback(MetaCallbackPrx cb, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Add a callback.
        /// The callback will receive notifications when servers are started or stopped.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_addCallback(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void removeCallback(MetaCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task removeCallbackAsync(MetaCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Meta_removeCallback> begin_removeCallback(MetaCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_removeCallback(MetaCallbackPrx cb, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed.</param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_removeCallback(MetaCallbackPrx cb, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        void end_removeCallback(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Get murmur uptime.
        /// </summary>
        /// <returns>Uptime of murmur in seconds</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        int getUptime(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get murmur uptime.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> getUptimeAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get murmur uptime.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Meta_getUptime> begin_getUptime(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get murmur uptime.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getUptime(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Get murmur uptime.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getUptime(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Get murmur uptime.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Uptime of murmur in seconds</returns>
        int end_getUptime(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Get slice file.
        /// </summary>
        /// <returns>Contents of the slice file server compiled with.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string getSlice(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get slice file.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string> getSliceAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get slice file.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Meta_getSlice> begin_getSlice(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get slice file.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getSlice(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Get slice file.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getSlice(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Get slice file.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Contents of the slice file server compiled with.</returns>
        string end_getSlice(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Returns a checksum dict for the slice file.
        /// </summary>
        /// <returns>Checksum dict</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::System.Collections.Generic.Dictionary<string, string> getSliceChecksums(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Returns a checksum dict for the slice file.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, string>> getSliceChecksumsAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Returns a checksum dict for the slice file.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_Meta_getSliceChecksums> begin_getSliceChecksums(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Returns a checksum dict for the slice file.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getSliceChecksums(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Returns a checksum dict for the slice file.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getSliceChecksums(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Returns a checksum dict for the slice file.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>Checksum dict</returns>
        global::System.Collections.Generic.Dictionary<string, string> end_getSliceChecksums(global::Ice.AsyncResult asyncResult);
    }
}

namespace Murmur
{
    /// <summary>
    /// Callback interface for servers.
    /// You can supply an implementation of this to receive notification
    /// messages from the server.
    /// If an added callback ever throws an exception or goes away, it will be automatically removed.
    /// Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
    /// complete before continuing processing.
    /// Note that callbacks are removed when a server is stopped, so you should have a callback for
    /// MetaCallback.started which calls Server.addCallback.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public interface ServerCallbackOperations_
    {
        /// <summary>
        /// Called when a user connects to the server.
        /// </summary>
        /// <param name="state">State of connected user.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        void userConnected(User state, global::Ice.Current current = null);

        /// <summary>
        /// Called when a user disconnects from the server.
        /// The user has already been removed, so you can no longer use methods like Server.getState
        /// to retrieve the user's state.
        /// </summary>
        /// <param name="state">State of disconnected user.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        void userDisconnected(User state, global::Ice.Current current = null);

        /// <summary>
        /// Called when a user state changes.
        /// This is called if the user moves, is renamed, is muted, deafened etc.
        /// </summary>
        /// <param name="state">New state of user.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        void userStateChanged(User state, global::Ice.Current current = null);

        /// <summary>
        /// Called when user writes a text message
        /// </summary>
        /// <param name="state">the User sending the message
        /// </param>
        /// <param name="message">the TextMessage the user has sent</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        void userTextMessage(User state, TextMessage message, global::Ice.Current current = null);

        /// <summary>
        /// Called when a new channel is created.
        /// </summary>
        /// <param name="state">State of new channel.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        void channelCreated(Channel state, global::Ice.Current current = null);

        /// <summary>
        /// Called when a channel is removed.
        /// The channel has already been removed, you can no longer use methods like Server.getChannelState
        /// </summary>
        /// <param name="state">State of removed channel.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        void channelRemoved(Channel state, global::Ice.Current current = null);

        /// <summary>
        /// Called when a new channel state changes.
        /// This is called if the channel is moved, renamed or if new links are added.
        /// </summary>
        /// <param name="state">New state of channel.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        void channelStateChanged(Channel state, global::Ice.Current current = null);
    }

    /// <summary>
    /// Callback interface for context actions.
    /// You need to supply one of these for Server.addContext. 
    /// If an added callback ever throws an exception or goes away, it will be automatically removed.
    /// Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
    /// complete before continuing processing.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public interface ServerContextCallbackOperations_
    {
        /// <summary>
        /// Called when a context action is performed.
        /// </summary>
        /// <param name="action">Action to be performed.
        /// </param>
        /// <param name="usr">User which initiated the action.
        /// </param>
        /// <param name="session">If nonzero, session of target user.
        /// </param>
        /// <param name="channelid">If not -1, id of target channel.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        void contextAction(string action, User usr, int session, int channelid, global::Ice.Current current = null);
    }

    /// <summary>
    /// Callback interface for server authentication.
    /// You need to supply one of these for Server.setAuthenticator.
    /// If an added callback ever throws an exception or goes away, it will be automatically removed.
    /// Please note that unlike ServerCallback and ServerContextCallback, these methods are called
    /// synchronously. If the response lags, the entire murmur server will lag.
    /// Also note that, as the method calls are synchronous, making a call to Server or Meta will
    /// deadlock the server.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public interface ServerAuthenticatorOperations_
    {
        /// <summary>
        /// Called to authenticate a user.
        /// If you do not know the username in question, always return -2 from this
        /// method to fall through to normal database authentication.
        /// Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
        /// the username and id so it cannot be used for normal database authentication.
        /// The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
        /// should only be trusted if certstrong is true.
        ///
        /// Internally, Murmur treats usernames as case-insensitive. It is recommended
        /// that authenticators do the same. Murmur checks if a username is in use when
        /// a user connects. If the connecting user is registered, the other username is
        /// kicked. If the connecting user is not registered, the connecting user is not
        /// allowed to join the server.
        ///
        /// </summary>
        /// <param name="name">Username to authenticate.
        /// </param>
        /// <param name="pw">Password to authenticate with.
        /// </param>
        /// <param name="certificates">List of der encoded certificates the user connected with.
        /// </param>
        /// <param name="certhash">Hash of user certificate, as used by murmur internally when matching.
        /// </param>
        /// <param name="certstrong">True if certificate was valid and signed by a trusted CA.
        /// </param>
        /// <param name="newname">Set this to change the username from the supplied one.
        /// </param>
        /// <param name="groups">List of groups on the root channel that the user will be added to for the duration of the connection.
        /// </param>
        /// <returns>UserID of authenticated user, -1 for authentication failures, -2 for unknown user (fallthrough),
        /// -3 for authentication failures where the data could (temporarily) not be verified.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        int authenticate(string name, string pw, byte[][] certificates, string certhash, bool certstrong, out string newname, out string[] groups, global::Ice.Current current = null);

        /// <summary>
        /// Fetch information about a user.
        /// This is used to retrieve information like email address, keyhash etc. If you
        /// want murmur to take care of this information itself, simply return false to fall through.
        /// </summary>
        /// <param name="id">User id.
        /// </param>
        /// <param name="info">Information about user. This needs to include at least "name".
        /// </param>
        /// <returns>true if information is present, false to fall through.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        bool getInfo(int id, out global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.Current current = null);

        /// <summary>
        /// Map a name to a user id.
        /// </summary>
        /// <param name="name">Username to map.
        /// </param>
        /// <returns>User id or -2 for unknown name.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        int nameToId(string name, global::Ice.Current current = null);

        /// <summary>
        /// Map a user id to a username.
        /// </summary>
        /// <param name="id">User id to map.
        /// </param>
        /// <returns>Name of user or empty string for unknown id.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        string idToName(int id, global::Ice.Current current = null);

        /// <summary>
        /// Map a user to a custom Texture.
        /// </summary>
        /// <param name="id">User id to map.
        /// </param>
        /// <returns>User texture or an empty texture for unknwon users or users without textures.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        byte[] idToTexture(int id, global::Ice.Current current = null);
    }

    /// <summary>
    /// Callback interface for server authentication and registration.
    /// This allows you to support both authentication
    /// and account updating.
    /// You do not need to implement this if all you want is authentication, you only need this if other scripts
    /// connected to the same server calls e.g. Server.setTexture.
    /// Almost all of these methods support fall through, meaning murmur should continue the operation against its
    /// own database.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public interface ServerUpdatingAuthenticatorOperations_ : ServerAuthenticatorOperations_
    {
        /// <summary>
        /// Register a new user.
        /// </summary>
        /// <param name="info">Information about user to register.
        /// </param>
        /// <returns>User id of new user, -1 for registration failure, or -2 to fall through.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        int registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.Current current = null);

        /// <summary>
        /// Unregister a user.
        /// </summary>
        /// <param name="id">Userid to unregister.
        /// </param>
        /// <returns>1 for successfull unregistration, 0 for unsuccessfull unregistration, -1 to fall through.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        int unregisterUser(int id, global::Ice.Current current = null);

        /// <summary>
        /// Get a list of registered users matching filter.
        /// </summary>
        /// <param name="filter">Substring usernames must contain. If empty, return all registered users.
        /// </param>
        /// <returns>List of matching registered users.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Collections.Generic.Dictionary<int, string> getRegisteredUsers(string filter, global::Ice.Current current = null);

        /// <summary>
        /// Set additional information for user registration.
        /// </summary>
        /// <param name="id">Userid of registered user.
        /// </param>
        /// <param name="info">Information to set about user. This should be merged with existing information.
        /// </param>
        /// <returns>1 for successfull update, 0 for unsuccessfull update, -1 to fall through.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        int setInfo(int id, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.Current current = null);

        /// <summary>
        /// Set texture (now called avatar) of user registration.
        /// </summary>
        /// <param name="id">registrationId of registered user.
        /// </param>
        /// <param name="tex">New texture.
        /// </param>
        /// <returns>1 for successfull update, 0 for unsuccessfull update, -1 to fall through.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        int setTexture(int id, byte[] tex, global::Ice.Current current = null);
    }

    /// <summary>
    /// Per-server interface.
    /// This includes all methods for configuring and altering
    /// the state of a single virtual server. You can retrieve a pointer to this interface
    /// from one of the methods in Meta.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public interface ServerOperations_
    {
        /// <summary>
        /// Shows if the server currently running (accepting users).
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<bool> isRunningAsync(global::Ice.Current current = null);

        /// <summary>
        /// Start server.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task startAsync(global::Ice.Current current = null);

        /// <summary>
        /// Stop server.
        /// Note: Server will be restarted on Murmur restart unless explicitly disabled
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task stopAsync(global::Ice.Current current = null);

        /// <summary>
        /// Delete server and all it's configuration.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task deleteAsync(global::Ice.Current current = null);

        /// <summary>
        /// Fetch the server id.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<int> idAsync(global::Ice.Current current = null);

        /// <summary>
        /// Add a callback.
        /// The callback will receive notifications about changes to users and channels.
        /// </summary>
        /// <param name="cb">Callback interface which will receive notifications.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task addCallbackAsync(ServerCallbackPrx cb, global::Ice.Current current = null);

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task removeCallbackAsync(ServerCallbackPrx cb, global::Ice.Current current = null);

        /// <summary>
        /// Set external authenticator.
        /// If set, all authentications from clients are forwarded to this
        /// </summary>
        /// <param name="auth">Authenticator object to perform subsequent authentications.</param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task setAuthenticatorAsync(ServerAuthenticatorPrx auth, global::Ice.Current current = null);

        /// <summary>
        /// Retrieve configuration item.
        /// </summary>
        /// <param name="key">Configuration key.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<string> getConfAsync(string key, global::Ice.Current current = null);

        /// <summary>
        /// Retrieve all configuration items.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, string>> getAllConfAsync(global::Ice.Current current = null);

        /// <summary>
        /// Set a configuration item.
        /// </summary>
        /// <param name="key">Configuration key.
        /// </param>
        /// <param name="value">Configuration value.</param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task setConfAsync(string key, string value, global::Ice.Current current = null);

        /// <summary>
        /// Set superuser password.
        /// This is just a convenience for using updateRegistration on user id 0.
        /// </summary>
        /// <param name="pw">Password.</param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task setSuperuserPasswordAsync(string pw, global::Ice.Current current = null);

        /// <summary>
        /// Fetch log entries.
        /// </summary>
        /// <param name="first">Lowest numbered entry to fetch. 0 is the most recent item.
        /// </param>
        /// <param name="last">Last entry to fetch.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<LogEntry[]> getLogAsync(int first, int last, global::Ice.Current current = null);

        /// <summary>
        /// Fetch length of log
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<int> getLogLenAsync(global::Ice.Current current = null);

        /// <summary>
        /// Fetch all users.
        /// This returns all currently connected users on the server.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, User>> getUsersAsync(global::Ice.Current current = null);

        /// <summary>
        /// Fetch all channels.
        /// This returns all defined channels on the server. The root channel is always channel 0.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, Channel>> getChannelsAsync(global::Ice.Current current = null);

        /// <summary>
        /// Fetch certificate of user.
        /// This returns the complete certificate chain of a user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<byte[][]> getCertificateListAsync(int session, global::Ice.Current current = null);

        /// <summary>
        /// Fetch all channels and connected users as a tree.
        /// This retrieves an easy-to-use representation of the server
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<Tree> getTreeAsync(global::Ice.Current current = null);

        /// <summary>
        /// Fetch all current IP bans on the server.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<Ban[]> getBansAsync(global::Ice.Current current = null);

        /// <summary>
        /// Set all current IP bans on the server.
        /// This will replace any bans already present, so if you want to add a ban, be sure to call getBans and then
        /// </summary>
        /// <param name="bans">List of bans.</param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task setBansAsync(Ban[] bans, global::Ice.Current current = null);

        /// <summary>
        /// Kick a user.
        /// The user is not banned, and is free to rejoin the server.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="reason">Text message to show when user is kicked.</param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task kickUserAsync(int session, string reason, global::Ice.Current current = null);

        /// <summary>
        /// Get state of a single connected user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<User> getStateAsync(int session, global::Ice.Current current = null);

        /// <summary>
        /// Set user state.
        /// You can use this to move, mute and deafen users.
        /// </summary>
        /// <param name="state">User state to set.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task setStateAsync(User state, global::Ice.Current current = null);

        /// <summary>
        /// Send text message to a single user.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="text">Message to send.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task sendMessageAsync(int session, string text, global::Ice.Current current = null);

        /// <summary>
        /// Check if user is permitted to perform action.
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <param name="perm">Permission bits to check.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<bool> hasPermissionAsync(int session, int channelid, int perm, global::Ice.Current current = null);

        /// <summary>
        /// Return users effective permissions
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<int> effectivePermissionsAsync(int session, int channelid, global::Ice.Current current = null);

        /// <summary>
        /// Add a context callback.
        /// This is done per user, and will add a context menu action for the user.
        /// </summary>
        /// <param name="session">Session of user which should receive context entry.
        /// </param>
        /// <param name="action">Action string, a unique name to associate with the action.
        /// </param>
        /// <param name="text">Name of action shown to user.
        /// </param>
        /// <param name="cb">Callback interface which will receive notifications.
        /// </param>
        /// <param name="ctx">Context this should be used in. Needs to be one or a combination of ContextServer, ContextChannel and ContextUser.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task addContextCallbackAsync(int session, string action, string text, ServerContextCallbackPrx cb, int ctx, global::Ice.Current current = null);

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed. This callback will be removed from all from all users.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task removeContextCallbackAsync(ServerContextCallbackPrx cb, global::Ice.Current current = null);

        /// <summary>
        /// Get state of single channel.
        /// </summary>
        /// <param name="channelid">ID of Channel. See Channel.id.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<Channel> getChannelStateAsync(int channelid, global::Ice.Current current = null);

        /// <summary>
        /// Set state of a single channel.
        /// You can use this to move or relink channels.
        /// </summary>
        /// <param name="state">Channel state to set.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task setChannelStateAsync(Channel state, global::Ice.Current current = null);

        /// <summary>
        /// Remove a channel and all its subchannels.
        /// </summary>
        /// <param name="channelid">ID of Channel. See Channel.id.</param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task removeChannelAsync(int channelid, global::Ice.Current current = null);

        /// <summary>
        /// Add a new channel.
        /// </summary>
        /// <param name="name">Name of new channel.
        /// </param>
        /// <param name="parent">Channel ID of parent channel. See Channel.id.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<int> addChannelAsync(string name, int parent, global::Ice.Current current = null);

        /// <summary>
        /// Send text message to channel or a tree of channels.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to send to. See Channel.id.
        /// </param>
        /// <param name="tree">If true, the message will be sent to the channel and all its subchannels.
        /// </param>
        /// <param name="text">Message to send.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task sendMessageChannelAsync(int channelid, bool tree, string text, global::Ice.Current current = null);

        /// <summary>
        /// Retrieve ACLs and Groups on a channel.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to fetch from. See Channel.id.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<Server_GetACLResult> getACLAsync(int channelid, global::Ice.Current current = null);

        /// <summary>
        /// Set ACLs and Groups on a channel.
        /// Note that this will replace all existing ACLs and groups on the channel.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to fetch from. See Channel.id.
        /// </param>
        /// <param name="acls">List of ACLs on the channel.
        /// </param>
        /// <param name="groups">List of groups on the channel.
        /// </param>
        /// <param name="inherit">Should this channel inherit ACLs from the parent channel?</param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task setACLAsync(int channelid, ACL[] acls, Group[] groups, bool inherit, global::Ice.Current current = null);

        /// <summary>
        /// Temporarily add a user to a group on a channel.
        /// This state is not saved, and is intended for temporary memberships.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to add to. See Channel.id.
        /// </param>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="group">Group name to add to.</param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task addUserToGroupAsync(int channelid, int session, string group, global::Ice.Current current = null);

        /// <summary>
        /// Remove a user from a temporary group membership on a channel.
        /// This state is not saved, and is intended for temporary memberships.
        /// </summary>
        /// <param name="channelid">Channel ID of channel to add to. See Channel.id.
        /// </param>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="group">Group name to remove from.</param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task removeUserFromGroupAsync(int channelid, int session, string group, global::Ice.Current current = null);

        /// <summary>
        /// Redirect whisper targets for user.
        /// If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
        /// </summary>
        /// <param name="session">Connection ID of user. See User.session.
        /// </param>
        /// <param name="source">Group name to redirect from.
        /// </param>
        /// <param name="target">Group name to redirect to.</param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task redirectWhisperGroupAsync(int session, string source, string target, global::Ice.Current current = null);

        /// <summary>
        /// Map a list of User.userid to a matching name.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, string>> getUserNamesAsync(int[] ids, global::Ice.Current current = null);

        /// <summary>
        /// Map a list of user names to a matching id.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, int>> getUserIdsAsync(string[] names, global::Ice.Current current = null);

        /// <summary>
        /// Register a new user.
        /// </summary>
        /// <param name="info">Information about new user. Must include at least "name".
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<int> registerUserAsync(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.Current current = null);

        /// <summary>
        /// Remove a user registration.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.</param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task unregisterUserAsync(int userid, global::Ice.Current current = null);

        /// <summary>
        /// Update the registration for a user.
        /// You can use this to set the email or password of a user,
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task updateRegistrationAsync(int userid, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.Current current = null);

        /// <summary>
        /// Fetch registration for a single user.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<UserInfo, string>> getRegistrationAsync(int userid, global::Ice.Current current = null);

        /// <summary>
        /// Fetch a group of registered users.
        /// </summary>
        /// <param name="filter">Substring of user name. If blank, will retrieve all registered users.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, string>> getRegisteredUsersAsync(string filter, global::Ice.Current current = null);

        /// <summary>
        /// Verify the password of a user.
        /// You can use this to verify a user's credentials.
        /// </summary>
        /// <param name="name">User name. See RegisteredUser.name.
        /// </param>
        /// <param name="pw">User password.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<int> verifyPasswordAsync(string name, string pw, global::Ice.Current current = null);

        /// <summary>
        /// Fetch user texture.
        /// Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<byte[]> getTextureAsync(int userid, global::Ice.Current current = null);

        /// <summary>
        /// Set a user texture (now called avatar).
        /// </summary>
        /// <param name="userid">ID of registered user. See RegisteredUser.userid.
        /// </param>
        /// <param name="tex">Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.</param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task setTextureAsync(int userid, byte[] tex, global::Ice.Current current = null);

        /// <summary>
        /// Get virtual server uptime.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<int> getUptimeAsync(global::Ice.Current current = null);

        /// <summary>
        /// Update the server's certificate information.
        /// Reconfigure the running server's TLS socket with the given
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task updateCertificateAsync(string certificate, string privateKey, string passphrase, global::Ice.Current current = null);
    }

    /// <summary>
    /// Callback interface for Meta.
    /// You can supply an implementation of this to receive notifications
    /// when servers are stopped or started.
    /// If an added callback ever throws an exception or goes away, it will be automatically removed.
    /// Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
    /// complete before continuing processing.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public interface MetaCallbackOperations_
    {
        /// <summary>
        /// Called when a server is started.
        /// The server is up and running when this event is sent, so all methods that 
        /// need a running server will work.
        /// </summary>
        /// <param name="srv">Interface for started server.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        void started(ServerPrx srv, global::Ice.Current current = null);

        /// <summary>
        /// Called when a server is stopped.
        /// The server is already stopped when this event is sent, so no methods that
        /// need a running server will work.
        /// </summary>
        /// <param name="srv">Interface for started server.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        void stopped(ServerPrx srv, global::Ice.Current current = null);
    }

    /// <summary>
    /// This is the meta interface.
    /// It is primarily used for retrieving the Server interfaces for each individual server.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public interface MetaOperations_
    {
        /// <summary>
        /// Fetch interface to specific server.
        /// </summary>
        /// <param name="id">Server ID. See Server.getId.
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<ServerPrx> getServerAsync(int id, global::Ice.Current current = null);

        /// <summary>
        /// Create a new server.
        /// Call Server.getId on the returned interface to find it's ID.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<ServerPrx> newServerAsync(global::Ice.Current current = null);

        /// <summary>
        /// Fetch list of all currently running servers.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<ServerPrx[]> getBootedServersAsync(global::Ice.Current current = null);

        /// <summary>
        /// Fetch list of all defined servers.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<ServerPrx[]> getAllServersAsync(global::Ice.Current current = null);

        /// <summary>
        /// Fetch default configuraion.
        /// This returns the configuration items that were set in the configuration file, or
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, string>> getDefaultConfAsync(global::Ice.Current current = null);

        /// <summary>
        /// Fetch version of Murmur.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<Meta_GetVersionResult> getVersionAsync(global::Ice.Current current = null);

        /// <summary>
        /// Add a callback.
        /// The callback will receive notifications when servers are started or stopped.
        /// </summary>
        /// <param name="cb">Callback interface which will receive notifications.</param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task addCallbackAsync(MetaCallbackPrx cb, global::Ice.Current current = null);

        /// <summary>
        /// Remove a callback.
        /// </summary>
        /// <param name="cb">Callback interface to be removed.</param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task removeCallbackAsync(MetaCallbackPrx cb, global::Ice.Current current = null);

        /// <summary>
        /// Get murmur uptime.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<int> getUptimeAsync(global::Ice.Current current = null);

        /// <summary>
        /// Get slice file.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<string> getSliceAsync(global::Ice.Current current = null);

        /// <summary>
        /// Returns a checksum dict for the slice file.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, string>> getSliceChecksumsAsync(global::Ice.Current current = null);
    }
}

namespace Murmur
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class NetAddressHelper
    {
        public static void write(global::Ice.OutputStream ostr, byte[] v)
        {
            ostr.writeByteSeq(v);
        }

        public static byte[] read(global::Ice.InputStream istr)
        {
            byte[] v;
            v = istr.readByteSeq();
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class IntListHelper
    {
        public static void write(global::Ice.OutputStream ostr, int[] v)
        {
            ostr.writeIntSeq(v);
        }

        public static int[] read(global::Ice.InputStream istr)
        {
            int[] v;
            v = istr.readIntSeq();
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class TreeListHelper
    {
        public static void write(global::Ice.OutputStream ostr, Tree[] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    ostr.writeValue(v[ix]);
                }
            }
        }

        public static Tree[] read(global::Ice.InputStream istr)
        {
            Tree[] v;
            {
                int szx = istr.readAndCheckSeqSize(1);
                v = new Tree[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    istr.readValue(global::IceInternal.Patcher.arrayReadValue<Tree>(v, ix));
                }
            }
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class UserMapHelper
    {
        public static void write(global::Ice.OutputStream ostr,
                                 global::System.Collections.Generic.Dictionary<int, User> v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Count);
                foreach(global::System.Collections.Generic.KeyValuePair<int, User> e in v)
                {
                    ostr.writeInt(e.Key);
                    User.ice_write(ostr, e.Value);
                }
            }
        }

        public static global::System.Collections.Generic.Dictionary<int, User> read(global::Ice.InputStream istr)
        {
            int sz = istr.readSize();
            global::System.Collections.Generic.Dictionary<int, User> r = new global::System.Collections.Generic.Dictionary<int, User>();
            for(int i = 0; i < sz; ++i)
            {
                int k;
                k = istr.readInt();
                User v;
                v = null;
                v = User.ice_read(istr);
                r[k] = v;
            }
            return r;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class ChannelMapHelper
    {
        public static void write(global::Ice.OutputStream ostr,
                                 global::System.Collections.Generic.Dictionary<int, Channel> v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Count);
                foreach(global::System.Collections.Generic.KeyValuePair<int, Channel> e in v)
                {
                    ostr.writeInt(e.Key);
                    Channel.ice_write(ostr, e.Value);
                }
            }
        }

        public static global::System.Collections.Generic.Dictionary<int, Channel> read(global::Ice.InputStream istr)
        {
            int sz = istr.readSize();
            global::System.Collections.Generic.Dictionary<int, Channel> r = new global::System.Collections.Generic.Dictionary<int, Channel>();
            for(int i = 0; i < sz; ++i)
            {
                int k;
                k = istr.readInt();
                Channel v;
                v = null;
                v = Channel.ice_read(istr);
                r[k] = v;
            }
            return r;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class ChannelListHelper
    {
        public static void write(global::Ice.OutputStream ostr, Channel[] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    (v[ix] == null ? new Channel() : v[ix]).ice_writeMembers(ostr);
                }
            }
        }

        public static Channel[] read(global::Ice.InputStream istr)
        {
            Channel[] v;
            {
                int szx = istr.readAndCheckSeqSize(16);
                v = new Channel[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new Channel();
                    v[ix].ice_readMembers(istr);
                }
            }
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class UserListHelper
    {
        public static void write(global::Ice.OutputStream ostr, User[] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    (v[ix] == null ? new User() : v[ix]).ice_writeMembers(ostr);
                }
            }
        }

        public static User[] read(global::Ice.InputStream istr)
        {
            User[] v;
            {
                int szx = istr.readAndCheckSeqSize(52);
                v = new User[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new User();
                    v[ix].ice_readMembers(istr);
                }
            }
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class GroupListHelper
    {
        public static void write(global::Ice.OutputStream ostr, Group[] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    (v[ix] == null ? new Group() : v[ix]).ice_writeMembers(ostr);
                }
            }
        }

        public static Group[] read(global::Ice.InputStream istr)
        {
            Group[] v;
            {
                int szx = istr.readAndCheckSeqSize(7);
                v = new Group[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new Group();
                    v[ix].ice_readMembers(istr);
                }
            }
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class ACLListHelper
    {
        public static void write(global::Ice.OutputStream ostr, ACL[] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    (v[ix] == null ? new ACL() : v[ix]).ice_writeMembers(ostr);
                }
            }
        }

        public static ACL[] read(global::Ice.InputStream istr)
        {
            ACL[] v;
            {
                int szx = istr.readAndCheckSeqSize(16);
                v = new ACL[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new ACL();
                    v[ix].ice_readMembers(istr);
                }
            }
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class LogListHelper
    {
        public static void write(global::Ice.OutputStream ostr, LogEntry[] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    (v[ix] == null ? new LogEntry() : v[ix]).ice_writeMembers(ostr);
                }
            }
        }

        public static LogEntry[] read(global::Ice.InputStream istr)
        {
            LogEntry[] v;
            {
                int szx = istr.readAndCheckSeqSize(5);
                v = new LogEntry[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new LogEntry();
                    v[ix].ice_readMembers(istr);
                }
            }
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class BanListHelper
    {
        public static void write(global::Ice.OutputStream ostr, Ban[] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    (v[ix] == null ? new Ban() : v[ix]).ice_writeMembers(ostr);
                }
            }
        }

        public static Ban[] read(global::Ice.InputStream istr)
        {
            Ban[] v;
            {
                int szx = istr.readAndCheckSeqSize(16);
                v = new Ban[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new Ban();
                    v[ix].ice_readMembers(istr);
                }
            }
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class IdListHelper
    {
        public static void write(global::Ice.OutputStream ostr, int[] v)
        {
            ostr.writeIntSeq(v);
        }

        public static int[] read(global::Ice.InputStream istr)
        {
            int[] v;
            v = istr.readIntSeq();
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class NameListHelper
    {
        public static void write(global::Ice.OutputStream ostr, string[] v)
        {
            ostr.writeStringSeq(v);
        }

        public static string[] read(global::Ice.InputStream istr)
        {
            string[] v;
            v = istr.readStringSeq();
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class NameMapHelper
    {
        public static void write(global::Ice.OutputStream ostr,
                                 global::System.Collections.Generic.Dictionary<int, string> v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Count);
                foreach(global::System.Collections.Generic.KeyValuePair<int, string> e in v)
                {
                    ostr.writeInt(e.Key);
                    ostr.writeString(e.Value);
                }
            }
        }

        public static global::System.Collections.Generic.Dictionary<int, string> read(global::Ice.InputStream istr)
        {
            int sz = istr.readSize();
            global::System.Collections.Generic.Dictionary<int, string> r = new global::System.Collections.Generic.Dictionary<int, string>();
            for(int i = 0; i < sz; ++i)
            {
                int k;
                k = istr.readInt();
                string v;
                v = istr.readString();
                r[k] = v;
            }
            return r;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class IdMapHelper
    {
        public static void write(global::Ice.OutputStream ostr,
                                 global::System.Collections.Generic.Dictionary<string, int> v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Count);
                foreach(global::System.Collections.Generic.KeyValuePair<string, int> e in v)
                {
                    ostr.writeString(e.Key);
                    ostr.writeInt(e.Value);
                }
            }
        }

        public static global::System.Collections.Generic.Dictionary<string, int> read(global::Ice.InputStream istr)
        {
            int sz = istr.readSize();
            global::System.Collections.Generic.Dictionary<string, int> r = new global::System.Collections.Generic.Dictionary<string, int>();
            for(int i = 0; i < sz; ++i)
            {
                string k;
                k = istr.readString();
                int v;
                v = istr.readInt();
                r[k] = v;
            }
            return r;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class TextureHelper
    {
        public static void write(global::Ice.OutputStream ostr, byte[] v)
        {
            ostr.writeByteSeq(v);
        }

        public static byte[] read(global::Ice.InputStream istr)
        {
            byte[] v;
            v = istr.readByteSeq();
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class ConfigMapHelper
    {
        public static void write(global::Ice.OutputStream ostr,
                                 global::System.Collections.Generic.Dictionary<string, string> v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Count);
                foreach(global::System.Collections.Generic.KeyValuePair<string, string> e in v)
                {
                    ostr.writeString(e.Key);
                    ostr.writeString(e.Value);
                }
            }
        }

        public static global::System.Collections.Generic.Dictionary<string, string> read(global::Ice.InputStream istr)
        {
            int sz = istr.readSize();
            global::System.Collections.Generic.Dictionary<string, string> r = new global::System.Collections.Generic.Dictionary<string, string>();
            for(int i = 0; i < sz; ++i)
            {
                string k;
                k = istr.readString();
                string v;
                v = istr.readString();
                r[k] = v;
            }
            return r;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class GroupNameListHelper
    {
        public static void write(global::Ice.OutputStream ostr, string[] v)
        {
            ostr.writeStringSeq(v);
        }

        public static string[] read(global::Ice.InputStream istr)
        {
            string[] v;
            v = istr.readStringSeq();
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class CertificateDerHelper
    {
        public static void write(global::Ice.OutputStream ostr, byte[] v)
        {
            ostr.writeByteSeq(v);
        }

        public static byte[] read(global::Ice.InputStream istr)
        {
            byte[] v;
            v = istr.readByteSeq();
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class CertificateListHelper
    {
        public static void write(global::Ice.OutputStream ostr, byte[][] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    CertificateDerHelper.write(ostr, v[ix]);
                }
            }
        }

        public static byte[][] read(global::Ice.InputStream istr)
        {
            byte[][] v;
            {
                int szx = istr.readAndCheckSeqSize(1);
                v = new byte[szx][];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = CertificateDerHelper.read(istr);
                }
            }
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class UserInfoMapHelper
    {
        public static void write(global::Ice.OutputStream ostr,
                                 global::System.Collections.Generic.Dictionary<UserInfo, string> v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Count);
                foreach(global::System.Collections.Generic.KeyValuePair<UserInfo, string> e in v)
                {
                    ostr.writeEnum((int)e.Key, 6);
                    ostr.writeString(e.Value);
                }
            }
        }

        public static global::System.Collections.Generic.Dictionary<UserInfo, string> read(global::Ice.InputStream istr)
        {
            int sz = istr.readSize();
            global::System.Collections.Generic.Dictionary<UserInfo, string> r = new global::System.Collections.Generic.Dictionary<UserInfo, string>();
            for(int i = 0; i < sz; ++i)
            {
                UserInfo k;
                k = (UserInfo)istr.readEnum(6);
                string v;
                v = istr.readString();
                r[k] = v;
            }
            return r;
        }
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    [global::System.Serializable]
    public sealed class ServerCallbackPrxHelper : global::Ice.ObjectPrxHelperBase, ServerCallbackPrx
    {
        public ServerCallbackPrxHelper()
        {
        }

        public ServerCallbackPrxHelper(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #region Synchronous operations

        public void userConnected(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_userConnectedAsync(state, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void userDisconnected(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_userDisconnectedAsync(state, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void userStateChanged(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_userStateChangedAsync(state, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void userTextMessage(User state, TextMessage message, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_userTextMessageAsync(state, message, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void channelCreated(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_channelCreatedAsync(state, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void channelRemoved(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_channelRemovedAsync(state, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void channelStateChanged(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_channelStateChangedAsync(state, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        #endregion

        #region Async Task operations

        public global::System.Threading.Tasks.Task userConnectedAsync(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_userConnectedAsync(state, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_userConnectedAsync(User iceP_state, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_userConnected(iceP_state, context, synchronous, completed);
            return completed.Task;
        }

        private const string _userConnected_name = "userConnected";

        private void _iceI_userConnected(User iceP_state, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _userConnected_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    User.ice_write(ostr, iceP_state);
                });
        }

        public global::System.Threading.Tasks.Task userDisconnectedAsync(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_userDisconnectedAsync(state, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_userDisconnectedAsync(User iceP_state, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_userDisconnected(iceP_state, context, synchronous, completed);
            return completed.Task;
        }

        private const string _userDisconnected_name = "userDisconnected";

        private void _iceI_userDisconnected(User iceP_state, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _userDisconnected_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    User.ice_write(ostr, iceP_state);
                });
        }

        public global::System.Threading.Tasks.Task userStateChangedAsync(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_userStateChangedAsync(state, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_userStateChangedAsync(User iceP_state, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_userStateChanged(iceP_state, context, synchronous, completed);
            return completed.Task;
        }

        private const string _userStateChanged_name = "userStateChanged";

        private void _iceI_userStateChanged(User iceP_state, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _userStateChanged_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    User.ice_write(ostr, iceP_state);
                });
        }

        public global::System.Threading.Tasks.Task userTextMessageAsync(User state, TextMessage message, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_userTextMessageAsync(state, message, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_userTextMessageAsync(User iceP_state, TextMessage iceP_message, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_userTextMessage(iceP_state, iceP_message, context, synchronous, completed);
            return completed.Task;
        }

        private const string _userTextMessage_name = "userTextMessage";

        private void _iceI_userTextMessage(User iceP_state, TextMessage iceP_message, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _userTextMessage_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    User.ice_write(ostr, iceP_state);
                    TextMessage.ice_write(ostr, iceP_message);
                });
        }

        public global::System.Threading.Tasks.Task channelCreatedAsync(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_channelCreatedAsync(state, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_channelCreatedAsync(Channel iceP_state, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_channelCreated(iceP_state, context, synchronous, completed);
            return completed.Task;
        }

        private const string _channelCreated_name = "channelCreated";

        private void _iceI_channelCreated(Channel iceP_state, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _channelCreated_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    Channel.ice_write(ostr, iceP_state);
                });
        }

        public global::System.Threading.Tasks.Task channelRemovedAsync(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_channelRemovedAsync(state, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_channelRemovedAsync(Channel iceP_state, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_channelRemoved(iceP_state, context, synchronous, completed);
            return completed.Task;
        }

        private const string _channelRemoved_name = "channelRemoved";

        private void _iceI_channelRemoved(Channel iceP_state, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _channelRemoved_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    Channel.ice_write(ostr, iceP_state);
                });
        }

        public global::System.Threading.Tasks.Task channelStateChangedAsync(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_channelStateChangedAsync(state, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_channelStateChangedAsync(Channel iceP_state, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_channelStateChanged(iceP_state, context, synchronous, completed);
            return completed.Task;
        }

        private const string _channelStateChanged_name = "channelStateChanged";

        private void _iceI_channelStateChanged(Channel iceP_state, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _channelStateChanged_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    Channel.ice_write(ostr, iceP_state);
                });
        }

        #endregion

        #region Asynchronous operations

        public global::Ice.AsyncResult<Callback_ServerCallback_userConnected> begin_userConnected(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_userConnected(state, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_userConnected(User state, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_userConnected(state, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_userConnected(User state, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_userConnected(state, context, callback, cookie, false);
        }

        public void end_userConnected(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _userConnected_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerCallback_userConnected> begin_userConnected(User iceP_state, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerCallback_userConnected, object>(
                (Callback_ServerCallback_userConnected cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _userConnected_name, cookie, completedCallback);
            _iceI_userConnected(iceP_state, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerCallback_userDisconnected> begin_userDisconnected(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_userDisconnected(state, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_userDisconnected(User state, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_userDisconnected(state, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_userDisconnected(User state, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_userDisconnected(state, context, callback, cookie, false);
        }

        public void end_userDisconnected(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _userDisconnected_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerCallback_userDisconnected> begin_userDisconnected(User iceP_state, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerCallback_userDisconnected, object>(
                (Callback_ServerCallback_userDisconnected cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _userDisconnected_name, cookie, completedCallback);
            _iceI_userDisconnected(iceP_state, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerCallback_userStateChanged> begin_userStateChanged(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_userStateChanged(state, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_userStateChanged(User state, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_userStateChanged(state, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_userStateChanged(User state, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_userStateChanged(state, context, callback, cookie, false);
        }

        public void end_userStateChanged(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _userStateChanged_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerCallback_userStateChanged> begin_userStateChanged(User iceP_state, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerCallback_userStateChanged, object>(
                (Callback_ServerCallback_userStateChanged cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _userStateChanged_name, cookie, completedCallback);
            _iceI_userStateChanged(iceP_state, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerCallback_userTextMessage> begin_userTextMessage(User state, TextMessage message, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_userTextMessage(state, message, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_userTextMessage(User state, TextMessage message, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_userTextMessage(state, message, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_userTextMessage(User state, TextMessage message, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_userTextMessage(state, message, context, callback, cookie, false);
        }

        public void end_userTextMessage(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _userTextMessage_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerCallback_userTextMessage> begin_userTextMessage(User iceP_state, TextMessage iceP_message, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerCallback_userTextMessage, object>(
                (Callback_ServerCallback_userTextMessage cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _userTextMessage_name, cookie, completedCallback);
            _iceI_userTextMessage(iceP_state, iceP_message, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerCallback_channelCreated> begin_channelCreated(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_channelCreated(state, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_channelCreated(Channel state, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_channelCreated(state, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_channelCreated(Channel state, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_channelCreated(state, context, callback, cookie, false);
        }

        public void end_channelCreated(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _channelCreated_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerCallback_channelCreated> begin_channelCreated(Channel iceP_state, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerCallback_channelCreated, object>(
                (Callback_ServerCallback_channelCreated cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _channelCreated_name, cookie, completedCallback);
            _iceI_channelCreated(iceP_state, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerCallback_channelRemoved> begin_channelRemoved(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_channelRemoved(state, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_channelRemoved(Channel state, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_channelRemoved(state, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_channelRemoved(Channel state, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_channelRemoved(state, context, callback, cookie, false);
        }

        public void end_channelRemoved(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _channelRemoved_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerCallback_channelRemoved> begin_channelRemoved(Channel iceP_state, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerCallback_channelRemoved, object>(
                (Callback_ServerCallback_channelRemoved cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _channelRemoved_name, cookie, completedCallback);
            _iceI_channelRemoved(iceP_state, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerCallback_channelStateChanged> begin_channelStateChanged(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_channelStateChanged(state, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_channelStateChanged(Channel state, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_channelStateChanged(state, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_channelStateChanged(Channel state, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_channelStateChanged(state, context, callback, cookie, false);
        }

        public void end_channelStateChanged(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _channelStateChanged_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerCallback_channelStateChanged> begin_channelStateChanged(Channel iceP_state, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerCallback_channelStateChanged, object>(
                (Callback_ServerCallback_channelStateChanged cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _channelStateChanged_name, cookie, completedCallback);
            _iceI_channelStateChanged(iceP_state, context, synchronous, completed);
            return completed;
        }

        #endregion

        #region Checked and unchecked cast operations

        public static ServerCallbackPrx checkedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            ServerCallbackPrx r = b as ServerCallbackPrx;
            if((r == null) && b.ice_isA(ice_staticId()))
            {
                ServerCallbackPrxHelper h = new ServerCallbackPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ServerCallbackPrx checkedCast(global::Ice.ObjectPrx b, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            ServerCallbackPrx r = b as ServerCallbackPrx;
            if((r == null) && b.ice_isA(ice_staticId(), ctx))
            {
                ServerCallbackPrxHelper h = new ServerCallbackPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ServerCallbackPrx checkedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId()))
                {
                    ServerCallbackPrxHelper h = new ServerCallbackPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static ServerCallbackPrx checkedCast(global::Ice.ObjectPrx b, string f, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId(), ctx))
                {
                    ServerCallbackPrxHelper h = new ServerCallbackPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static ServerCallbackPrx uncheckedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            ServerCallbackPrx r = b as ServerCallbackPrx;
            if(r == null)
            {
                ServerCallbackPrxHelper h = new ServerCallbackPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ServerCallbackPrx uncheckedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            ServerCallbackPrxHelper h = new ServerCallbackPrxHelper();
            h.iceCopyFrom(bb);
            return h;
        }

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::Murmur::ServerCallback"
        };

        public static string ice_staticId()
        {
            return _ids[1];
        }

        #endregion

        #region Marshaling support

        public static void write(global::Ice.OutputStream ostr, ServerCallbackPrx v)
        {
            ostr.writeProxy(v);
        }

        public static ServerCallbackPrx read(global::Ice.InputStream istr)
        {
            global::Ice.ObjectPrx proxy = istr.readProxy();
            if(proxy != null)
            {
                ServerCallbackPrxHelper result = new ServerCallbackPrxHelper();
                result.iceCopyFrom(proxy);
                return result;
            }
            return null;
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    [global::System.Serializable]
    public sealed class ServerContextCallbackPrxHelper : global::Ice.ObjectPrxHelperBase, ServerContextCallbackPrx
    {
        public ServerContextCallbackPrxHelper()
        {
        }

        public ServerContextCallbackPrxHelper(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #region Synchronous operations

        public void contextAction(string action, User usr, int session, int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_contextActionAsync(action, usr, session, channelid, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        #endregion

        #region Async Task operations

        public global::System.Threading.Tasks.Task contextActionAsync(string action, User usr, int session, int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_contextActionAsync(action, usr, session, channelid, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_contextActionAsync(string iceP_action, User iceP_usr, int iceP_session, int iceP_channelid, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_contextAction(iceP_action, iceP_usr, iceP_session, iceP_channelid, context, synchronous, completed);
            return completed.Task;
        }

        private const string _contextAction_name = "contextAction";

        private void _iceI_contextAction(string iceP_action, User iceP_usr, int iceP_session, int iceP_channelid, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _contextAction_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_action);
                    User.ice_write(ostr, iceP_usr);
                    ostr.writeInt(iceP_session);
                    ostr.writeInt(iceP_channelid);
                });
        }

        #endregion

        #region Asynchronous operations

        public global::Ice.AsyncResult<Callback_ServerContextCallback_contextAction> begin_contextAction(string action, User usr, int session, int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_contextAction(action, usr, session, channelid, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_contextAction(string action, User usr, int session, int channelid, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_contextAction(action, usr, session, channelid, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_contextAction(string action, User usr, int session, int channelid, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_contextAction(action, usr, session, channelid, context, callback, cookie, false);
        }

        public void end_contextAction(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _contextAction_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerContextCallback_contextAction> begin_contextAction(string iceP_action, User iceP_usr, int iceP_session, int iceP_channelid, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerContextCallback_contextAction, object>(
                (Callback_ServerContextCallback_contextAction cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _contextAction_name, cookie, completedCallback);
            _iceI_contextAction(iceP_action, iceP_usr, iceP_session, iceP_channelid, context, synchronous, completed);
            return completed;
        }

        #endregion

        #region Checked and unchecked cast operations

        public static ServerContextCallbackPrx checkedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            ServerContextCallbackPrx r = b as ServerContextCallbackPrx;
            if((r == null) && b.ice_isA(ice_staticId()))
            {
                ServerContextCallbackPrxHelper h = new ServerContextCallbackPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ServerContextCallbackPrx checkedCast(global::Ice.ObjectPrx b, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            ServerContextCallbackPrx r = b as ServerContextCallbackPrx;
            if((r == null) && b.ice_isA(ice_staticId(), ctx))
            {
                ServerContextCallbackPrxHelper h = new ServerContextCallbackPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ServerContextCallbackPrx checkedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId()))
                {
                    ServerContextCallbackPrxHelper h = new ServerContextCallbackPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static ServerContextCallbackPrx checkedCast(global::Ice.ObjectPrx b, string f, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId(), ctx))
                {
                    ServerContextCallbackPrxHelper h = new ServerContextCallbackPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static ServerContextCallbackPrx uncheckedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            ServerContextCallbackPrx r = b as ServerContextCallbackPrx;
            if(r == null)
            {
                ServerContextCallbackPrxHelper h = new ServerContextCallbackPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ServerContextCallbackPrx uncheckedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            ServerContextCallbackPrxHelper h = new ServerContextCallbackPrxHelper();
            h.iceCopyFrom(bb);
            return h;
        }

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::Murmur::ServerContextCallback"
        };

        public static string ice_staticId()
        {
            return _ids[1];
        }

        #endregion

        #region Marshaling support

        public static void write(global::Ice.OutputStream ostr, ServerContextCallbackPrx v)
        {
            ostr.writeProxy(v);
        }

        public static ServerContextCallbackPrx read(global::Ice.InputStream istr)
        {
            global::Ice.ObjectPrx proxy = istr.readProxy();
            if(proxy != null)
            {
                ServerContextCallbackPrxHelper result = new ServerContextCallbackPrxHelper();
                result.iceCopyFrom(proxy);
                return result;
            }
            return null;
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    [global::System.Serializable]
    public sealed class ServerAuthenticatorPrxHelper : global::Ice.ObjectPrxHelperBase, ServerAuthenticatorPrx
    {
        public ServerAuthenticatorPrxHelper()
        {
        }

        public ServerAuthenticatorPrxHelper(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #region Synchronous operations

        public int authenticate(string name, string pw, byte[][] certificates, string certhash, bool certstrong, out string newname, out string[] groups, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                var result_ = _iceI_authenticateAsync(name, pw, certificates, certhash, certstrong, context, null, global::System.Threading.CancellationToken.None, true).Result;
                newname = result_.newname;
                groups = result_.groups;
                return result_.returnValue;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public bool getInfo(int id, out global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                var result_ = _iceI_getInfoAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
                info = result_.info;
                return result_.returnValue;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int nameToId(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_nameToIdAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public string idToName(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_idToNameAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public byte[] idToTexture(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_idToTextureAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        #endregion

        #region Async Task operations

        public global::System.Threading.Tasks.Task<ServerAuthenticator_AuthenticateResult> authenticateAsync(string name, string pw, byte[][] certificates, string certhash, bool certstrong, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_authenticateAsync(name, pw, certificates, certhash, certstrong, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ServerAuthenticator_AuthenticateResult> _iceI_authenticateAsync(string iceP_name, string iceP_pw, byte[][] iceP_certificates, string iceP_certhash, bool iceP_certstrong, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_authenticate_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<ServerAuthenticator_AuthenticateResult>(progress, cancel);
            _iceI_authenticate(iceP_name, iceP_pw, iceP_certificates, iceP_certhash, iceP_certstrong, context, synchronous, completed);
            return completed.Task;
        }

        private const string _authenticate_name = "authenticate";

        private void _iceI_authenticate(string iceP_name, string iceP_pw, byte[][] iceP_certificates, string iceP_certhash, bool iceP_certstrong, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ServerAuthenticator_AuthenticateResult>(completed);
            outAsync.invoke(
                _authenticate_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                    ostr.writeString(iceP_pw);
                    CertificateListHelper.write(ostr, iceP_certificates);
                    ostr.writeString(iceP_certhash);
                    ostr.writeBool(iceP_certstrong);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    ServerAuthenticator_AuthenticateResult ret = new ServerAuthenticator_AuthenticateResult();
                    ret.newname = istr.readString();
                    ret.groups = GroupNameListHelper.read(istr);
                    ret.returnValue = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<ServerAuthenticator_GetInfoResult> getInfoAsync(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getInfoAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ServerAuthenticator_GetInfoResult> _iceI_getInfoAsync(int iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getInfo_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<ServerAuthenticator_GetInfoResult>(progress, cancel);
            _iceI_getInfo(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getInfo_name = "getInfo";

        private void _iceI_getInfo(int iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ServerAuthenticator_GetInfoResult>(completed);
            outAsync.invoke(
                _getInfo_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_id);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    ServerAuthenticator_GetInfoResult ret = new ServerAuthenticator_GetInfoResult();
                    ret.info = UserInfoMapHelper.read(istr);
                    ret.returnValue = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> nameToIdAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_nameToIdAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_nameToIdAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_nameToId_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_nameToId(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _nameToId_name = "nameToId";

        private void _iceI_nameToId(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _nameToId_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<string> idToNameAsync(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_idToNameAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string> _iceI_idToNameAsync(int iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_idToName_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<string>(progress, cancel);
            _iceI_idToName(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _idToName_name = "idToName";

        private void _iceI_idToName(int iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string>(completed);
            outAsync.invoke(
                _idToName_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_id);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    string ret;
                    ret = istr.readString();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<byte[]> idToTextureAsync(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_idToTextureAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<byte[]> _iceI_idToTextureAsync(int iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_idToTexture_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<byte[]>(progress, cancel);
            _iceI_idToTexture(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _idToTexture_name = "idToTexture";

        private void _iceI_idToTexture(int iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<byte[]>(completed);
            outAsync.invoke(
                _idToTexture_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_id);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    byte[] ret;
                    ret = TextureHelper.read(istr);
                    return ret;
                });
        }

        #endregion

        #region Asynchronous operations

        public global::Ice.AsyncResult<Callback_ServerAuthenticator_authenticate> begin_authenticate(string name, string pw, byte[][] certificates, string certhash, bool certstrong, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_authenticate(name, pw, certificates, certhash, certstrong, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_authenticate(string name, string pw, byte[][] certificates, string certhash, bool certstrong, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_authenticate(name, pw, certificates, certhash, certstrong, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_authenticate(string name, string pw, byte[][] certificates, string certhash, bool certstrong, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_authenticate(name, pw, certificates, certhash, certstrong, context, callback, cookie, false);
        }

        public int end_authenticate(out string newname, out string[] groups, global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _authenticate_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<ServerAuthenticator_AuthenticateResult>)resultI_.OutgoingAsync;
            var result_ = outgoing_.getResult(resultI_.wait());
            newname = result_.newname;
            groups = result_.groups;
            return result_.returnValue;
        }

        private global::Ice.AsyncResult<Callback_ServerAuthenticator_authenticate> begin_authenticate(string iceP_name, string iceP_pw, byte[][] iceP_certificates, string iceP_certhash, bool iceP_certstrong, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_authenticate_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerAuthenticator_authenticate, ServerAuthenticator_AuthenticateResult>(
                (Callback_ServerAuthenticator_authenticate cb, ServerAuthenticator_AuthenticateResult ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret.returnValue, ret.newname, ret.groups);
                    }
                },
                this, _authenticate_name, cookie, completedCallback);
            _iceI_authenticate(iceP_name, iceP_pw, iceP_certificates, iceP_certhash, iceP_certstrong, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerAuthenticator_getInfo> begin_getInfo(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getInfo(id, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getInfo(int id, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getInfo(id, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getInfo(int id, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getInfo(id, context, callback, cookie, false);
        }

        public bool end_getInfo(out global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getInfo_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<ServerAuthenticator_GetInfoResult>)resultI_.OutgoingAsync;
            var result_ = outgoing_.getResult(resultI_.wait());
            info = result_.info;
            return result_.returnValue;
        }

        private global::Ice.AsyncResult<Callback_ServerAuthenticator_getInfo> begin_getInfo(int iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getInfo_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerAuthenticator_getInfo, ServerAuthenticator_GetInfoResult>(
                (Callback_ServerAuthenticator_getInfo cb, ServerAuthenticator_GetInfoResult ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret.returnValue, ret.info);
                    }
                },
                this, _getInfo_name, cookie, completedCallback);
            _iceI_getInfo(iceP_id, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerAuthenticator_nameToId> begin_nameToId(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_nameToId(name, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_nameToId(string name, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_nameToId(name, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_nameToId(string name, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_nameToId(name, context, callback, cookie, false);
        }

        public int end_nameToId(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _nameToId_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<int>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerAuthenticator_nameToId> begin_nameToId(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_nameToId_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerAuthenticator_nameToId, int>(
                (Callback_ServerAuthenticator_nameToId cb, int ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _nameToId_name, cookie, completedCallback);
            _iceI_nameToId(iceP_name, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerAuthenticator_idToName> begin_idToName(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_idToName(id, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_idToName(int id, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_idToName(id, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_idToName(int id, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_idToName(id, context, callback, cookie, false);
        }

        public string end_idToName(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _idToName_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<string>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerAuthenticator_idToName> begin_idToName(int iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_idToName_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerAuthenticator_idToName, string>(
                (Callback_ServerAuthenticator_idToName cb, string ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _idToName_name, cookie, completedCallback);
            _iceI_idToName(iceP_id, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerAuthenticator_idToTexture> begin_idToTexture(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_idToTexture(id, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_idToTexture(int id, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_idToTexture(id, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_idToTexture(int id, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_idToTexture(id, context, callback, cookie, false);
        }

        public byte[] end_idToTexture(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _idToTexture_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<byte[]>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerAuthenticator_idToTexture> begin_idToTexture(int iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_idToTexture_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerAuthenticator_idToTexture, byte[]>(
                (Callback_ServerAuthenticator_idToTexture cb, byte[] ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _idToTexture_name, cookie, completedCallback);
            _iceI_idToTexture(iceP_id, context, synchronous, completed);
            return completed;
        }

        #endregion

        #region Checked and unchecked cast operations

        public static ServerAuthenticatorPrx checkedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            ServerAuthenticatorPrx r = b as ServerAuthenticatorPrx;
            if((r == null) && b.ice_isA(ice_staticId()))
            {
                ServerAuthenticatorPrxHelper h = new ServerAuthenticatorPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ServerAuthenticatorPrx checkedCast(global::Ice.ObjectPrx b, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            ServerAuthenticatorPrx r = b as ServerAuthenticatorPrx;
            if((r == null) && b.ice_isA(ice_staticId(), ctx))
            {
                ServerAuthenticatorPrxHelper h = new ServerAuthenticatorPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ServerAuthenticatorPrx checkedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId()))
                {
                    ServerAuthenticatorPrxHelper h = new ServerAuthenticatorPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static ServerAuthenticatorPrx checkedCast(global::Ice.ObjectPrx b, string f, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId(), ctx))
                {
                    ServerAuthenticatorPrxHelper h = new ServerAuthenticatorPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static ServerAuthenticatorPrx uncheckedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            ServerAuthenticatorPrx r = b as ServerAuthenticatorPrx;
            if(r == null)
            {
                ServerAuthenticatorPrxHelper h = new ServerAuthenticatorPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ServerAuthenticatorPrx uncheckedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            ServerAuthenticatorPrxHelper h = new ServerAuthenticatorPrxHelper();
            h.iceCopyFrom(bb);
            return h;
        }

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::Murmur::ServerAuthenticator"
        };

        public static string ice_staticId()
        {
            return _ids[1];
        }

        #endregion

        #region Marshaling support

        public static void write(global::Ice.OutputStream ostr, ServerAuthenticatorPrx v)
        {
            ostr.writeProxy(v);
        }

        public static ServerAuthenticatorPrx read(global::Ice.InputStream istr)
        {
            global::Ice.ObjectPrx proxy = istr.readProxy();
            if(proxy != null)
            {
                ServerAuthenticatorPrxHelper result = new ServerAuthenticatorPrxHelper();
                result.iceCopyFrom(proxy);
                return result;
            }
            return null;
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    [global::System.Serializable]
    public sealed class ServerUpdatingAuthenticatorPrxHelper : global::Ice.ObjectPrxHelperBase, ServerUpdatingAuthenticatorPrx
    {
        public ServerUpdatingAuthenticatorPrxHelper()
        {
        }

        public ServerUpdatingAuthenticatorPrxHelper(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #region Synchronous operations

        public int authenticate(string name, string pw, byte[][] certificates, string certhash, bool certstrong, out string newname, out string[] groups, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                var result_ = _iceI_authenticateAsync(name, pw, certificates, certhash, certstrong, context, null, global::System.Threading.CancellationToken.None, true).Result;
                newname = result_.newname;
                groups = result_.groups;
                return result_.returnValue;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public bool getInfo(int id, out global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                var result_ = _iceI_getInfoAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
                info = result_.info;
                return result_.returnValue;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int nameToId(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_nameToIdAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public string idToName(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_idToNameAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public byte[] idToTexture(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_idToTextureAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_registerUserAsync(info, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int unregisterUser(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_unregisterUserAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public global::System.Collections.Generic.Dictionary<int, string> getRegisteredUsers(string filter, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getRegisteredUsersAsync(filter, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int setInfo(int id, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_setInfoAsync(id, info, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int setTexture(int id, byte[] tex, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_setTextureAsync(id, tex, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        #endregion

        #region Async Task operations

        public global::System.Threading.Tasks.Task<ServerAuthenticator_AuthenticateResult> authenticateAsync(string name, string pw, byte[][] certificates, string certhash, bool certstrong, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_authenticateAsync(name, pw, certificates, certhash, certstrong, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ServerAuthenticator_AuthenticateResult> _iceI_authenticateAsync(string iceP_name, string iceP_pw, byte[][] iceP_certificates, string iceP_certhash, bool iceP_certstrong, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_authenticate_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<ServerAuthenticator_AuthenticateResult>(progress, cancel);
            _iceI_authenticate(iceP_name, iceP_pw, iceP_certificates, iceP_certhash, iceP_certstrong, context, synchronous, completed);
            return completed.Task;
        }

        private const string _authenticate_name = "authenticate";

        private void _iceI_authenticate(string iceP_name, string iceP_pw, byte[][] iceP_certificates, string iceP_certhash, bool iceP_certstrong, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ServerAuthenticator_AuthenticateResult>(completed);
            outAsync.invoke(
                _authenticate_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                    ostr.writeString(iceP_pw);
                    CertificateListHelper.write(ostr, iceP_certificates);
                    ostr.writeString(iceP_certhash);
                    ostr.writeBool(iceP_certstrong);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    ServerAuthenticator_AuthenticateResult ret = new ServerAuthenticator_AuthenticateResult();
                    ret.newname = istr.readString();
                    ret.groups = GroupNameListHelper.read(istr);
                    ret.returnValue = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<ServerAuthenticator_GetInfoResult> getInfoAsync(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getInfoAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ServerAuthenticator_GetInfoResult> _iceI_getInfoAsync(int iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getInfo_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<ServerAuthenticator_GetInfoResult>(progress, cancel);
            _iceI_getInfo(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getInfo_name = "getInfo";

        private void _iceI_getInfo(int iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ServerAuthenticator_GetInfoResult>(completed);
            outAsync.invoke(
                _getInfo_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_id);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    ServerAuthenticator_GetInfoResult ret = new ServerAuthenticator_GetInfoResult();
                    ret.info = UserInfoMapHelper.read(istr);
                    ret.returnValue = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> nameToIdAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_nameToIdAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_nameToIdAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_nameToId_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_nameToId(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _nameToId_name = "nameToId";

        private void _iceI_nameToId(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _nameToId_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<string> idToNameAsync(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_idToNameAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string> _iceI_idToNameAsync(int iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_idToName_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<string>(progress, cancel);
            _iceI_idToName(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _idToName_name = "idToName";

        private void _iceI_idToName(int iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string>(completed);
            outAsync.invoke(
                _idToName_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_id);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    string ret;
                    ret = istr.readString();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<byte[]> idToTextureAsync(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_idToTextureAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<byte[]> _iceI_idToTextureAsync(int iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_idToTexture_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<byte[]>(progress, cancel);
            _iceI_idToTexture(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _idToTexture_name = "idToTexture";

        private void _iceI_idToTexture(int iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<byte[]>(completed);
            outAsync.invoke(
                _idToTexture_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_id);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    byte[] ret;
                    ret = TextureHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> registerUserAsync(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_registerUserAsync(info, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_registerUserAsync(global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_registerUser_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_registerUser(iceP_info, context, synchronous, completed);
            return completed.Task;
        }

        private const string _registerUser_name = "registerUser";

        private void _iceI_registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _registerUser_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    UserInfoMapHelper.write(ostr, iceP_info);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> unregisterUserAsync(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_unregisterUserAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_unregisterUserAsync(int iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_unregisterUser_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_unregisterUser(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _unregisterUser_name = "unregisterUser";

        private void _iceI_unregisterUser(int iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _unregisterUser_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_id);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, string>> getRegisteredUsersAsync(string filter, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getRegisteredUsersAsync(filter, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, string>> _iceI_getRegisteredUsersAsync(string iceP_filter, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getRegisteredUsers_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<global::System.Collections.Generic.Dictionary<int, string>>(progress, cancel);
            _iceI_getRegisteredUsers(iceP_filter, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getRegisteredUsers_name = "getRegisteredUsers";

        private void _iceI_getRegisteredUsers(string iceP_filter, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::System.Collections.Generic.Dictionary<int, string>>(completed);
            outAsync.invoke(
                _getRegisteredUsers_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_filter);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    global::System.Collections.Generic.Dictionary<int, string> ret;
                    ret = NameMapHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> setInfoAsync(int id, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_setInfoAsync(id, info, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_setInfoAsync(int iceP_id, global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setInfo_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_setInfo(iceP_id, iceP_info, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setInfo_name = "setInfo";

        private void _iceI_setInfo(int iceP_id, global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _setInfo_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_id);
                    UserInfoMapHelper.write(ostr, iceP_info);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> setTextureAsync(int id, byte[] tex, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_setTextureAsync(id, tex, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_setTextureAsync(int iceP_id, byte[] iceP_tex, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setTexture_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_setTexture(iceP_id, iceP_tex, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setTexture_name = "setTexture";

        private void _iceI_setTexture(int iceP_id, byte[] iceP_tex, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _setTexture_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_id);
                    TextureHelper.write(ostr, iceP_tex);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        #endregion

        #region Asynchronous operations

        public global::Ice.AsyncResult<Callback_ServerAuthenticator_authenticate> begin_authenticate(string name, string pw, byte[][] certificates, string certhash, bool certstrong, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_authenticate(name, pw, certificates, certhash, certstrong, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_authenticate(string name, string pw, byte[][] certificates, string certhash, bool certstrong, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_authenticate(name, pw, certificates, certhash, certstrong, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_authenticate(string name, string pw, byte[][] certificates, string certhash, bool certstrong, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_authenticate(name, pw, certificates, certhash, certstrong, context, callback, cookie, false);
        }

        public int end_authenticate(out string newname, out string[] groups, global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _authenticate_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<ServerAuthenticator_AuthenticateResult>)resultI_.OutgoingAsync;
            var result_ = outgoing_.getResult(resultI_.wait());
            newname = result_.newname;
            groups = result_.groups;
            return result_.returnValue;
        }

        private global::Ice.AsyncResult<Callback_ServerAuthenticator_authenticate> begin_authenticate(string iceP_name, string iceP_pw, byte[][] iceP_certificates, string iceP_certhash, bool iceP_certstrong, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_authenticate_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerAuthenticator_authenticate, ServerAuthenticator_AuthenticateResult>(
                (Callback_ServerAuthenticator_authenticate cb, ServerAuthenticator_AuthenticateResult ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret.returnValue, ret.newname, ret.groups);
                    }
                },
                this, _authenticate_name, cookie, completedCallback);
            _iceI_authenticate(iceP_name, iceP_pw, iceP_certificates, iceP_certhash, iceP_certstrong, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerAuthenticator_getInfo> begin_getInfo(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getInfo(id, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getInfo(int id, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getInfo(id, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getInfo(int id, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getInfo(id, context, callback, cookie, false);
        }

        public bool end_getInfo(out global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getInfo_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<ServerAuthenticator_GetInfoResult>)resultI_.OutgoingAsync;
            var result_ = outgoing_.getResult(resultI_.wait());
            info = result_.info;
            return result_.returnValue;
        }

        private global::Ice.AsyncResult<Callback_ServerAuthenticator_getInfo> begin_getInfo(int iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getInfo_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerAuthenticator_getInfo, ServerAuthenticator_GetInfoResult>(
                (Callback_ServerAuthenticator_getInfo cb, ServerAuthenticator_GetInfoResult ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret.returnValue, ret.info);
                    }
                },
                this, _getInfo_name, cookie, completedCallback);
            _iceI_getInfo(iceP_id, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerAuthenticator_nameToId> begin_nameToId(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_nameToId(name, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_nameToId(string name, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_nameToId(name, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_nameToId(string name, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_nameToId(name, context, callback, cookie, false);
        }

        public int end_nameToId(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _nameToId_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<int>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerAuthenticator_nameToId> begin_nameToId(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_nameToId_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerAuthenticator_nameToId, int>(
                (Callback_ServerAuthenticator_nameToId cb, int ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _nameToId_name, cookie, completedCallback);
            _iceI_nameToId(iceP_name, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerAuthenticator_idToName> begin_idToName(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_idToName(id, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_idToName(int id, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_idToName(id, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_idToName(int id, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_idToName(id, context, callback, cookie, false);
        }

        public string end_idToName(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _idToName_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<string>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerAuthenticator_idToName> begin_idToName(int iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_idToName_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerAuthenticator_idToName, string>(
                (Callback_ServerAuthenticator_idToName cb, string ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _idToName_name, cookie, completedCallback);
            _iceI_idToName(iceP_id, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerAuthenticator_idToTexture> begin_idToTexture(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_idToTexture(id, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_idToTexture(int id, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_idToTexture(id, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_idToTexture(int id, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_idToTexture(id, context, callback, cookie, false);
        }

        public byte[] end_idToTexture(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _idToTexture_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<byte[]>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerAuthenticator_idToTexture> begin_idToTexture(int iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_idToTexture_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerAuthenticator_idToTexture, byte[]>(
                (Callback_ServerAuthenticator_idToTexture cb, byte[] ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _idToTexture_name, cookie, completedCallback);
            _iceI_idToTexture(iceP_id, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerUpdatingAuthenticator_registerUser> begin_registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_registerUser(info, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_registerUser(info, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_registerUser(info, context, callback, cookie, false);
        }

        public int end_registerUser(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _registerUser_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<int>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerUpdatingAuthenticator_registerUser> begin_registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_registerUser_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerUpdatingAuthenticator_registerUser, int>(
                (Callback_ServerUpdatingAuthenticator_registerUser cb, int ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _registerUser_name, cookie, completedCallback);
            _iceI_registerUser(iceP_info, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerUpdatingAuthenticator_unregisterUser> begin_unregisterUser(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_unregisterUser(id, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_unregisterUser(int id, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_unregisterUser(id, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_unregisterUser(int id, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_unregisterUser(id, context, callback, cookie, false);
        }

        public int end_unregisterUser(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _unregisterUser_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<int>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerUpdatingAuthenticator_unregisterUser> begin_unregisterUser(int iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_unregisterUser_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerUpdatingAuthenticator_unregisterUser, int>(
                (Callback_ServerUpdatingAuthenticator_unregisterUser cb, int ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _unregisterUser_name, cookie, completedCallback);
            _iceI_unregisterUser(iceP_id, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerUpdatingAuthenticator_getRegisteredUsers> begin_getRegisteredUsers(string filter, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getRegisteredUsers(filter, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getRegisteredUsers(string filter, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getRegisteredUsers(filter, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getRegisteredUsers(string filter, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getRegisteredUsers(filter, context, callback, cookie, false);
        }

        public global::System.Collections.Generic.Dictionary<int, string> end_getRegisteredUsers(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getRegisteredUsers_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<global::System.Collections.Generic.Dictionary<int, string>>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerUpdatingAuthenticator_getRegisteredUsers> begin_getRegisteredUsers(string iceP_filter, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getRegisteredUsers_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerUpdatingAuthenticator_getRegisteredUsers, global::System.Collections.Generic.Dictionary<int, string>>(
                (Callback_ServerUpdatingAuthenticator_getRegisteredUsers cb, global::System.Collections.Generic.Dictionary<int, string> ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getRegisteredUsers_name, cookie, completedCallback);
            _iceI_getRegisteredUsers(iceP_filter, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerUpdatingAuthenticator_setInfo> begin_setInfo(int id, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_setInfo(id, info, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_setInfo(int id, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setInfo(id, info, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_setInfo(int id, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setInfo(id, info, context, callback, cookie, false);
        }

        public int end_setInfo(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _setInfo_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<int>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerUpdatingAuthenticator_setInfo> begin_setInfo(int iceP_id, global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_setInfo_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerUpdatingAuthenticator_setInfo, int>(
                (Callback_ServerUpdatingAuthenticator_setInfo cb, int ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _setInfo_name, cookie, completedCallback);
            _iceI_setInfo(iceP_id, iceP_info, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_ServerUpdatingAuthenticator_setTexture> begin_setTexture(int id, byte[] tex, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_setTexture(id, tex, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_setTexture(int id, byte[] tex, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setTexture(id, tex, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_setTexture(int id, byte[] tex, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setTexture(id, tex, context, callback, cookie, false);
        }

        public int end_setTexture(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _setTexture_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<int>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_ServerUpdatingAuthenticator_setTexture> begin_setTexture(int iceP_id, byte[] iceP_tex, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_setTexture_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_ServerUpdatingAuthenticator_setTexture, int>(
                (Callback_ServerUpdatingAuthenticator_setTexture cb, int ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _setTexture_name, cookie, completedCallback);
            _iceI_setTexture(iceP_id, iceP_tex, context, synchronous, completed);
            return completed;
        }

        #endregion

        #region Checked and unchecked cast operations

        public static ServerUpdatingAuthenticatorPrx checkedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            ServerUpdatingAuthenticatorPrx r = b as ServerUpdatingAuthenticatorPrx;
            if((r == null) && b.ice_isA(ice_staticId()))
            {
                ServerUpdatingAuthenticatorPrxHelper h = new ServerUpdatingAuthenticatorPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ServerUpdatingAuthenticatorPrx checkedCast(global::Ice.ObjectPrx b, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            ServerUpdatingAuthenticatorPrx r = b as ServerUpdatingAuthenticatorPrx;
            if((r == null) && b.ice_isA(ice_staticId(), ctx))
            {
                ServerUpdatingAuthenticatorPrxHelper h = new ServerUpdatingAuthenticatorPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ServerUpdatingAuthenticatorPrx checkedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId()))
                {
                    ServerUpdatingAuthenticatorPrxHelper h = new ServerUpdatingAuthenticatorPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static ServerUpdatingAuthenticatorPrx checkedCast(global::Ice.ObjectPrx b, string f, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId(), ctx))
                {
                    ServerUpdatingAuthenticatorPrxHelper h = new ServerUpdatingAuthenticatorPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static ServerUpdatingAuthenticatorPrx uncheckedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            ServerUpdatingAuthenticatorPrx r = b as ServerUpdatingAuthenticatorPrx;
            if(r == null)
            {
                ServerUpdatingAuthenticatorPrxHelper h = new ServerUpdatingAuthenticatorPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ServerUpdatingAuthenticatorPrx uncheckedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            ServerUpdatingAuthenticatorPrxHelper h = new ServerUpdatingAuthenticatorPrxHelper();
            h.iceCopyFrom(bb);
            return h;
        }

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::Murmur::ServerAuthenticator",
            "::Murmur::ServerUpdatingAuthenticator"
        };

        public static string ice_staticId()
        {
            return _ids[2];
        }

        #endregion

        #region Marshaling support

        public static void write(global::Ice.OutputStream ostr, ServerUpdatingAuthenticatorPrx v)
        {
            ostr.writeProxy(v);
        }

        public static ServerUpdatingAuthenticatorPrx read(global::Ice.InputStream istr)
        {
            global::Ice.ObjectPrx proxy = istr.readProxy();
            if(proxy != null)
            {
                ServerUpdatingAuthenticatorPrxHelper result = new ServerUpdatingAuthenticatorPrxHelper();
                result.iceCopyFrom(proxy);
                return result;
            }
            return null;
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    [global::System.Serializable]
    public sealed class ServerPrxHelper : global::Ice.ObjectPrxHelperBase, ServerPrx
    {
        public ServerPrxHelper()
        {
        }

        public ServerPrxHelper(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #region Synchronous operations

        public bool isRunning(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_isRunningAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void start(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_startAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void stop(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_stopAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void delete(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_deleteAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int id(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_idAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void addCallback(ServerCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_addCallbackAsync(cb, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void removeCallback(ServerCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_removeCallbackAsync(cb, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void setAuthenticator(ServerAuthenticatorPrx auth, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_setAuthenticatorAsync(auth, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public string getConf(string key, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getConfAsync(key, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public global::System.Collections.Generic.Dictionary<string, string> getAllConf(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getAllConfAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void setConf(string key, string value, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_setConfAsync(key, value, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void setSuperuserPassword(string pw, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_setSuperuserPasswordAsync(pw, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public LogEntry[] getLog(int first, int last, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getLogAsync(first, last, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int getLogLen(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getLogLenAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public global::System.Collections.Generic.Dictionary<int, User> getUsers(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getUsersAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public global::System.Collections.Generic.Dictionary<int, Channel> getChannels(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getChannelsAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public byte[][] getCertificateList(int session, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getCertificateListAsync(session, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public Tree getTree(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getTreeAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public Ban[] getBans(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getBansAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void setBans(Ban[] bans, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_setBansAsync(bans, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void kickUser(int session, string reason, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_kickUserAsync(session, reason, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public User getState(int session, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getStateAsync(session, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void setState(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_setStateAsync(state, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void sendMessage(int session, string text, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_sendMessageAsync(session, text, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public bool hasPermission(int session, int channelid, int perm, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_hasPermissionAsync(session, channelid, perm, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int effectivePermissions(int session, int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_effectivePermissionsAsync(session, channelid, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void addContextCallback(int session, string action, string text, ServerContextCallbackPrx cb, int ctx, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_addContextCallbackAsync(session, action, text, cb, ctx, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void removeContextCallback(ServerContextCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_removeContextCallbackAsync(cb, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public Channel getChannelState(int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getChannelStateAsync(channelid, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void setChannelState(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_setChannelStateAsync(state, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void removeChannel(int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_removeChannelAsync(channelid, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int addChannel(string name, int parent, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_addChannelAsync(name, parent, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void sendMessageChannel(int channelid, bool tree, string text, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_sendMessageChannelAsync(channelid, tree, text, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void getACL(int channelid, out ACL[] acls, out Group[] groups, out bool inherit, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                var result_ = _iceI_getACLAsync(channelid, context, null, global::System.Threading.CancellationToken.None, true).Result;
                acls = result_.acls;
                groups = result_.groups;
                inherit = result_.inherit;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void setACL(int channelid, ACL[] acls, Group[] groups, bool inherit, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_setACLAsync(channelid, acls, groups, inherit, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void addUserToGroup(int channelid, int session, string group, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_addUserToGroupAsync(channelid, session, group, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void removeUserFromGroup(int channelid, int session, string group, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_removeUserFromGroupAsync(channelid, session, group, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void redirectWhisperGroup(int session, string source, string target, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_redirectWhisperGroupAsync(session, source, target, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public global::System.Collections.Generic.Dictionary<int, string> getUserNames(int[] ids, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getUserNamesAsync(ids, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public global::System.Collections.Generic.Dictionary<string, int> getUserIds(string[] names, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getUserIdsAsync(names, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_registerUserAsync(info, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void unregisterUser(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_unregisterUserAsync(userid, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void updateRegistration(int userid, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_updateRegistrationAsync(userid, info, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public global::System.Collections.Generic.Dictionary<UserInfo, string> getRegistration(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getRegistrationAsync(userid, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public global::System.Collections.Generic.Dictionary<int, string> getRegisteredUsers(string filter, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getRegisteredUsersAsync(filter, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int verifyPassword(string name, string pw, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_verifyPasswordAsync(name, pw, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public byte[] getTexture(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getTextureAsync(userid, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void setTexture(int userid, byte[] tex, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_setTextureAsync(userid, tex, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int getUptime(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getUptimeAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void updateCertificate(string certificate, string privateKey, string passphrase, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_updateCertificateAsync(certificate, privateKey, passphrase, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        #endregion

        #region Async Task operations

        public global::System.Threading.Tasks.Task<bool> isRunningAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_isRunningAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<bool> _iceI_isRunningAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_isRunning_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<bool>(progress, cancel);
            _iceI_isRunning(context, synchronous, completed);
            return completed.Task;
        }

        private const string _isRunning_name = "isRunning";

        private void _iceI_isRunning(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<bool>(completed);
            outAsync.invoke(
                _isRunning_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    bool ret;
                    ret = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task startAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_startAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_startAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_start_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_start(context, synchronous, completed);
            return completed.Task;
        }

        private const string _start_name = "start";

        private void _iceI_start(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _start_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(ServerFailureException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task stopAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_stopAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_stopAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_stop_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_stop(context, synchronous, completed);
            return completed.Task;
        }

        private const string _stop_name = "stop";

        private void _iceI_stop(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _stop_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task deleteAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_deleteAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_deleteAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_delete_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_delete(context, synchronous, completed);
            return completed.Task;
        }

        private const string _delete_name = "delete";

        private void _iceI_delete(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _delete_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<int> idAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_idAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_idAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_id_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_id(context, synchronous, completed);
            return completed.Task;
        }

        private const string _id_name = "id";

        private void _iceI_id(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _id_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task addCallbackAsync(ServerCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_addCallbackAsync(cb, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_addCallbackAsync(ServerCallbackPrx iceP_cb, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_addCallback_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_addCallback(iceP_cb, context, synchronous, completed);
            return completed.Task;
        }

        private const string _addCallback_name = "addCallback";

        private void _iceI_addCallback(ServerCallbackPrx iceP_cb, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _addCallback_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ServerCallbackPrxHelper.write(ostr, iceP_cb);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidCallbackException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task removeCallbackAsync(ServerCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_removeCallbackAsync(cb, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_removeCallbackAsync(ServerCallbackPrx iceP_cb, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_removeCallback_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_removeCallback(iceP_cb, context, synchronous, completed);
            return completed.Task;
        }

        private const string _removeCallback_name = "removeCallback";

        private void _iceI_removeCallback(ServerCallbackPrx iceP_cb, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _removeCallback_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ServerCallbackPrxHelper.write(ostr, iceP_cb);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidCallbackException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task setAuthenticatorAsync(ServerAuthenticatorPrx auth, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_setAuthenticatorAsync(auth, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setAuthenticatorAsync(ServerAuthenticatorPrx iceP_auth, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setAuthenticator_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setAuthenticator(iceP_auth, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setAuthenticator_name = "setAuthenticator";

        private void _iceI_setAuthenticator(ServerAuthenticatorPrx iceP_auth, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setAuthenticator_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ServerAuthenticatorPrxHelper.write(ostr, iceP_auth);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidCallbackException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<string> getConfAsync(string key, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getConfAsync(key, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string> _iceI_getConfAsync(string iceP_key, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getConf_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<string>(progress, cancel);
            _iceI_getConf(iceP_key, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getConf_name = "getConf";

        private void _iceI_getConf(string iceP_key, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string>(completed);
            outAsync.invoke(
                _getConf_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_key);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(WriteOnlyException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    string ret;
                    ret = istr.readString();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, string>> getAllConfAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getAllConfAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, string>> _iceI_getAllConfAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAllConf_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<global::System.Collections.Generic.Dictionary<string, string>>(progress, cancel);
            _iceI_getAllConf(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAllConf_name = "getAllConf";

        private void _iceI_getAllConf(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::System.Collections.Generic.Dictionary<string, string>>(completed);
            outAsync.invoke(
                _getAllConf_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    global::System.Collections.Generic.Dictionary<string, string> ret;
                    ret = ConfigMapHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task setConfAsync(string key, string value, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_setConfAsync(key, value, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setConfAsync(string iceP_key, string iceP_value, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setConf_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setConf(iceP_key, iceP_value, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setConf_name = "setConf";

        private void _iceI_setConf(string iceP_key, string iceP_value, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setConf_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_key);
                    ostr.writeString(iceP_value);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task setSuperuserPasswordAsync(string pw, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_setSuperuserPasswordAsync(pw, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setSuperuserPasswordAsync(string iceP_pw, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setSuperuserPassword_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setSuperuserPassword(iceP_pw, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setSuperuserPassword_name = "setSuperuserPassword";

        private void _iceI_setSuperuserPassword(string iceP_pw, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setSuperuserPassword_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_pw);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<LogEntry[]> getLogAsync(int first, int last, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getLogAsync(first, last, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<LogEntry[]> _iceI_getLogAsync(int iceP_first, int iceP_last, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getLog_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<LogEntry[]>(progress, cancel);
            _iceI_getLog(iceP_first, iceP_last, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getLog_name = "getLog";

        private void _iceI_getLog(int iceP_first, int iceP_last, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<LogEntry[]>(completed);
            outAsync.invoke(
                _getLog_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_first);
                    ostr.writeInt(iceP_last);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    LogEntry[] ret;
                    ret = LogListHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> getLogLenAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getLogLenAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_getLogLenAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getLogLen_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_getLogLen(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getLogLen_name = "getLogLen";

        private void _iceI_getLogLen(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _getLogLen_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, User>> getUsersAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getUsersAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, User>> _iceI_getUsersAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getUsers_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<global::System.Collections.Generic.Dictionary<int, User>>(progress, cancel);
            _iceI_getUsers(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getUsers_name = "getUsers";

        private void _iceI_getUsers(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::System.Collections.Generic.Dictionary<int, User>>(completed);
            outAsync.invoke(
                _getUsers_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    global::System.Collections.Generic.Dictionary<int, User> ret;
                    ret = UserMapHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, Channel>> getChannelsAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getChannelsAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, Channel>> _iceI_getChannelsAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getChannels_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<global::System.Collections.Generic.Dictionary<int, Channel>>(progress, cancel);
            _iceI_getChannels(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getChannels_name = "getChannels";

        private void _iceI_getChannels(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::System.Collections.Generic.Dictionary<int, Channel>>(completed);
            outAsync.invoke(
                _getChannels_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    global::System.Collections.Generic.Dictionary<int, Channel> ret;
                    ret = ChannelMapHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<byte[][]> getCertificateListAsync(int session, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getCertificateListAsync(session, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<byte[][]> _iceI_getCertificateListAsync(int iceP_session, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getCertificateList_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<byte[][]>(progress, cancel);
            _iceI_getCertificateList(iceP_session, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getCertificateList_name = "getCertificateList";

        private void _iceI_getCertificateList(int iceP_session, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<byte[][]>(completed);
            outAsync.invoke(
                _getCertificateList_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_session);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(InvalidSessionException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    byte[][] ret;
                    ret = CertificateListHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<Tree> getTreeAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getTreeAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<Tree> _iceI_getTreeAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getTree_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<Tree>(progress, cancel);
            _iceI_getTree(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getTree_name = "getTree";

        private void _iceI_getTree(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<Tree>(completed);
            outAsync.invoke(
                _getTree_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    Tree ret = null;
                    istr.readValue((Tree v) => {ret = v; });
                    istr.readPendingValues();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<Ban[]> getBansAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getBansAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<Ban[]> _iceI_getBansAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getBans_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<Ban[]>(progress, cancel);
            _iceI_getBans(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getBans_name = "getBans";

        private void _iceI_getBans(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<Ban[]>(completed);
            outAsync.invoke(
                _getBans_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    Ban[] ret;
                    ret = BanListHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task setBansAsync(Ban[] bans, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_setBansAsync(bans, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setBansAsync(Ban[] iceP_bans, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setBans_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setBans(iceP_bans, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setBans_name = "setBans";

        private void _iceI_setBans(Ban[] iceP_bans, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setBans_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    BanListHelper.write(ostr, iceP_bans);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task kickUserAsync(int session, string reason, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_kickUserAsync(session, reason, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_kickUserAsync(int iceP_session, string iceP_reason, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_kickUser_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_kickUser(iceP_session, iceP_reason, context, synchronous, completed);
            return completed.Task;
        }

        private const string _kickUser_name = "kickUser";

        private void _iceI_kickUser(int iceP_session, string iceP_reason, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _kickUser_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_session);
                    ostr.writeString(iceP_reason);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(InvalidSessionException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<User> getStateAsync(int session, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getStateAsync(session, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<User> _iceI_getStateAsync(int iceP_session, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getState_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<User>(progress, cancel);
            _iceI_getState(iceP_session, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getState_name = "getState";

        private void _iceI_getState(int iceP_session, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<User>(completed);
            outAsync.invoke(
                _getState_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_session);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(InvalidSessionException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    User ret = null;
                    ret = User.ice_read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task setStateAsync(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_setStateAsync(state, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setStateAsync(User iceP_state, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setState_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setState(iceP_state, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setState_name = "setState";

        private void _iceI_setState(User iceP_state, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setState_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    User.ice_write(ostr, iceP_state);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidChannelException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(InvalidSessionException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task sendMessageAsync(int session, string text, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_sendMessageAsync(session, text, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_sendMessageAsync(int iceP_session, string iceP_text, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_sendMessage_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_sendMessage(iceP_session, iceP_text, context, synchronous, completed);
            return completed.Task;
        }

        private const string _sendMessage_name = "sendMessage";

        private void _iceI_sendMessage(int iceP_session, string iceP_text, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _sendMessage_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_session);
                    ostr.writeString(iceP_text);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(InvalidSessionException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<bool> hasPermissionAsync(int session, int channelid, int perm, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_hasPermissionAsync(session, channelid, perm, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<bool> _iceI_hasPermissionAsync(int iceP_session, int iceP_channelid, int iceP_perm, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_hasPermission_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<bool>(progress, cancel);
            _iceI_hasPermission(iceP_session, iceP_channelid, iceP_perm, context, synchronous, completed);
            return completed.Task;
        }

        private const string _hasPermission_name = "hasPermission";

        private void _iceI_hasPermission(int iceP_session, int iceP_channelid, int iceP_perm, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<bool>(completed);
            outAsync.invoke(
                _hasPermission_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_session);
                    ostr.writeInt(iceP_channelid);
                    ostr.writeInt(iceP_perm);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidChannelException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(InvalidSessionException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    bool ret;
                    ret = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> effectivePermissionsAsync(int session, int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_effectivePermissionsAsync(session, channelid, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_effectivePermissionsAsync(int iceP_session, int iceP_channelid, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_effectivePermissions_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_effectivePermissions(iceP_session, iceP_channelid, context, synchronous, completed);
            return completed.Task;
        }

        private const string _effectivePermissions_name = "effectivePermissions";

        private void _iceI_effectivePermissions(int iceP_session, int iceP_channelid, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _effectivePermissions_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_session);
                    ostr.writeInt(iceP_channelid);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidChannelException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(InvalidSessionException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task addContextCallbackAsync(int session, string action, string text, ServerContextCallbackPrx cb, int ctx, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_addContextCallbackAsync(session, action, text, cb, ctx, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_addContextCallbackAsync(int iceP_session, string iceP_action, string iceP_text, ServerContextCallbackPrx iceP_cb, int iceP_ctx, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_addContextCallback_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_addContextCallback(iceP_session, iceP_action, iceP_text, iceP_cb, iceP_ctx, context, synchronous, completed);
            return completed.Task;
        }

        private const string _addContextCallback_name = "addContextCallback";

        private void _iceI_addContextCallback(int iceP_session, string iceP_action, string iceP_text, ServerContextCallbackPrx iceP_cb, int iceP_ctx, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _addContextCallback_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_session);
                    ostr.writeString(iceP_action);
                    ostr.writeString(iceP_text);
                    ServerContextCallbackPrxHelper.write(ostr, iceP_cb);
                    ostr.writeInt(iceP_ctx);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidCallbackException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task removeContextCallbackAsync(ServerContextCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_removeContextCallbackAsync(cb, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_removeContextCallbackAsync(ServerContextCallbackPrx iceP_cb, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_removeContextCallback_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_removeContextCallback(iceP_cb, context, synchronous, completed);
            return completed.Task;
        }

        private const string _removeContextCallback_name = "removeContextCallback";

        private void _iceI_removeContextCallback(ServerContextCallbackPrx iceP_cb, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _removeContextCallback_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ServerContextCallbackPrxHelper.write(ostr, iceP_cb);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidCallbackException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<Channel> getChannelStateAsync(int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getChannelStateAsync(channelid, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<Channel> _iceI_getChannelStateAsync(int iceP_channelid, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getChannelState_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<Channel>(progress, cancel);
            _iceI_getChannelState(iceP_channelid, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getChannelState_name = "getChannelState";

        private void _iceI_getChannelState(int iceP_channelid, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<Channel>(completed);
            outAsync.invoke(
                _getChannelState_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_channelid);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidChannelException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    Channel ret = null;
                    ret = Channel.ice_read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task setChannelStateAsync(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_setChannelStateAsync(state, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setChannelStateAsync(Channel iceP_state, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setChannelState_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setChannelState(iceP_state, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setChannelState_name = "setChannelState";

        private void _iceI_setChannelState(Channel iceP_state, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setChannelState_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    Channel.ice_write(ostr, iceP_state);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidChannelException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(NestingLimitException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task removeChannelAsync(int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_removeChannelAsync(channelid, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_removeChannelAsync(int iceP_channelid, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_removeChannel_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_removeChannel(iceP_channelid, context, synchronous, completed);
            return completed.Task;
        }

        private const string _removeChannel_name = "removeChannel";

        private void _iceI_removeChannel(int iceP_channelid, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _removeChannel_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_channelid);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidChannelException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<int> addChannelAsync(string name, int parent, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_addChannelAsync(name, parent, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_addChannelAsync(string iceP_name, int iceP_parent, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_addChannel_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_addChannel(iceP_name, iceP_parent, context, synchronous, completed);
            return completed.Task;
        }

        private const string _addChannel_name = "addChannel";

        private void _iceI_addChannel(string iceP_name, int iceP_parent, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _addChannel_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                    ostr.writeInt(iceP_parent);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidChannelException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(NestingLimitException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task sendMessageChannelAsync(int channelid, bool tree, string text, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_sendMessageChannelAsync(channelid, tree, text, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_sendMessageChannelAsync(int iceP_channelid, bool iceP_tree, string iceP_text, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_sendMessageChannel_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_sendMessageChannel(iceP_channelid, iceP_tree, iceP_text, context, synchronous, completed);
            return completed.Task;
        }

        private const string _sendMessageChannel_name = "sendMessageChannel";

        private void _iceI_sendMessageChannel(int iceP_channelid, bool iceP_tree, string iceP_text, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _sendMessageChannel_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_channelid);
                    ostr.writeBool(iceP_tree);
                    ostr.writeString(iceP_text);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidChannelException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<Server_GetACLResult> getACLAsync(int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getACLAsync(channelid, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<Server_GetACLResult> _iceI_getACLAsync(int iceP_channelid, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getACL_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<Server_GetACLResult>(progress, cancel);
            _iceI_getACL(iceP_channelid, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getACL_name = "getACL";

        private void _iceI_getACL(int iceP_channelid, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<Server_GetACLResult>(completed);
            outAsync.invoke(
                _getACL_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_channelid);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidChannelException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    Server_GetACLResult ret = new Server_GetACLResult();
                    ret.acls = ACLListHelper.read(istr);
                    ret.groups = GroupListHelper.read(istr);
                    ret.inherit = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task setACLAsync(int channelid, ACL[] acls, Group[] groups, bool inherit, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_setACLAsync(channelid, acls, groups, inherit, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setACLAsync(int iceP_channelid, ACL[] iceP_acls, Group[] iceP_groups, bool iceP_inherit, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setACL_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setACL(iceP_channelid, iceP_acls, iceP_groups, iceP_inherit, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setACL_name = "setACL";

        private void _iceI_setACL(int iceP_channelid, ACL[] iceP_acls, Group[] iceP_groups, bool iceP_inherit, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setACL_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_channelid);
                    ACLListHelper.write(ostr, iceP_acls);
                    GroupListHelper.write(ostr, iceP_groups);
                    ostr.writeBool(iceP_inherit);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidChannelException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task addUserToGroupAsync(int channelid, int session, string group, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_addUserToGroupAsync(channelid, session, group, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_addUserToGroupAsync(int iceP_channelid, int iceP_session, string iceP_group, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_addUserToGroup_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_addUserToGroup(iceP_channelid, iceP_session, iceP_group, context, synchronous, completed);
            return completed.Task;
        }

        private const string _addUserToGroup_name = "addUserToGroup";

        private void _iceI_addUserToGroup(int iceP_channelid, int iceP_session, string iceP_group, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _addUserToGroup_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_channelid);
                    ostr.writeInt(iceP_session);
                    ostr.writeString(iceP_group);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidChannelException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(InvalidSessionException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task removeUserFromGroupAsync(int channelid, int session, string group, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_removeUserFromGroupAsync(channelid, session, group, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_removeUserFromGroupAsync(int iceP_channelid, int iceP_session, string iceP_group, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_removeUserFromGroup_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_removeUserFromGroup(iceP_channelid, iceP_session, iceP_group, context, synchronous, completed);
            return completed.Task;
        }

        private const string _removeUserFromGroup_name = "removeUserFromGroup";

        private void _iceI_removeUserFromGroup(int iceP_channelid, int iceP_session, string iceP_group, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _removeUserFromGroup_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_channelid);
                    ostr.writeInt(iceP_session);
                    ostr.writeString(iceP_group);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidChannelException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(InvalidSessionException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task redirectWhisperGroupAsync(int session, string source, string target, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_redirectWhisperGroupAsync(session, source, target, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_redirectWhisperGroupAsync(int iceP_session, string iceP_source, string iceP_target, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_redirectWhisperGroup_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_redirectWhisperGroup(iceP_session, iceP_source, iceP_target, context, synchronous, completed);
            return completed.Task;
        }

        private const string _redirectWhisperGroup_name = "redirectWhisperGroup";

        private void _iceI_redirectWhisperGroup(int iceP_session, string iceP_source, string iceP_target, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _redirectWhisperGroup_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_session);
                    ostr.writeString(iceP_source);
                    ostr.writeString(iceP_target);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(InvalidSessionException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, string>> getUserNamesAsync(int[] ids, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getUserNamesAsync(ids, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, string>> _iceI_getUserNamesAsync(int[] iceP_ids, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getUserNames_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<global::System.Collections.Generic.Dictionary<int, string>>(progress, cancel);
            _iceI_getUserNames(iceP_ids, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getUserNames_name = "getUserNames";

        private void _iceI_getUserNames(int[] iceP_ids, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::System.Collections.Generic.Dictionary<int, string>>(completed);
            outAsync.invoke(
                _getUserNames_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    IdListHelper.write(ostr, iceP_ids);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    global::System.Collections.Generic.Dictionary<int, string> ret;
                    ret = NameMapHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, int>> getUserIdsAsync(string[] names, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getUserIdsAsync(names, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, int>> _iceI_getUserIdsAsync(string[] iceP_names, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getUserIds_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<global::System.Collections.Generic.Dictionary<string, int>>(progress, cancel);
            _iceI_getUserIds(iceP_names, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getUserIds_name = "getUserIds";

        private void _iceI_getUserIds(string[] iceP_names, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::System.Collections.Generic.Dictionary<string, int>>(completed);
            outAsync.invoke(
                _getUserIds_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    NameListHelper.write(ostr, iceP_names);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    global::System.Collections.Generic.Dictionary<string, int> ret;
                    ret = IdMapHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> registerUserAsync(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_registerUserAsync(info, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_registerUserAsync(global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_registerUser_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_registerUser(iceP_info, context, synchronous, completed);
            return completed.Task;
        }

        private const string _registerUser_name = "registerUser";

        private void _iceI_registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _registerUser_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    UserInfoMapHelper.write(ostr, iceP_info);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(InvalidUserException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task unregisterUserAsync(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_unregisterUserAsync(userid, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_unregisterUserAsync(int iceP_userid, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_unregisterUser_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_unregisterUser(iceP_userid, context, synchronous, completed);
            return completed.Task;
        }

        private const string _unregisterUser_name = "unregisterUser";

        private void _iceI_unregisterUser(int iceP_userid, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _unregisterUser_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_userid);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(InvalidUserException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task updateRegistrationAsync(int userid, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_updateRegistrationAsync(userid, info, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_updateRegistrationAsync(int iceP_userid, global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_updateRegistration_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_updateRegistration(iceP_userid, iceP_info, context, synchronous, completed);
            return completed.Task;
        }

        private const string _updateRegistration_name = "updateRegistration";

        private void _iceI_updateRegistration(int iceP_userid, global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _updateRegistration_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_userid);
                    UserInfoMapHelper.write(ostr, iceP_info);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(InvalidUserException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<UserInfo, string>> getRegistrationAsync(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getRegistrationAsync(userid, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<UserInfo, string>> _iceI_getRegistrationAsync(int iceP_userid, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getRegistration_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<global::System.Collections.Generic.Dictionary<UserInfo, string>>(progress, cancel);
            _iceI_getRegistration(iceP_userid, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getRegistration_name = "getRegistration";

        private void _iceI_getRegistration(int iceP_userid, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::System.Collections.Generic.Dictionary<UserInfo, string>>(completed);
            outAsync.invoke(
                _getRegistration_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_userid);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(InvalidUserException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    global::System.Collections.Generic.Dictionary<UserInfo, string> ret;
                    ret = UserInfoMapHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, string>> getRegisteredUsersAsync(string filter, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getRegisteredUsersAsync(filter, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, string>> _iceI_getRegisteredUsersAsync(string iceP_filter, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getRegisteredUsers_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<global::System.Collections.Generic.Dictionary<int, string>>(progress, cancel);
            _iceI_getRegisteredUsers(iceP_filter, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getRegisteredUsers_name = "getRegisteredUsers";

        private void _iceI_getRegisteredUsers(string iceP_filter, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::System.Collections.Generic.Dictionary<int, string>>(completed);
            outAsync.invoke(
                _getRegisteredUsers_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_filter);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    global::System.Collections.Generic.Dictionary<int, string> ret;
                    ret = NameMapHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> verifyPasswordAsync(string name, string pw, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_verifyPasswordAsync(name, pw, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_verifyPasswordAsync(string iceP_name, string iceP_pw, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_verifyPassword_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_verifyPassword(iceP_name, iceP_pw, context, synchronous, completed);
            return completed.Task;
        }

        private const string _verifyPassword_name = "verifyPassword";

        private void _iceI_verifyPassword(string iceP_name, string iceP_pw, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _verifyPassword_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                    ostr.writeString(iceP_pw);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<byte[]> getTextureAsync(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getTextureAsync(userid, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<byte[]> _iceI_getTextureAsync(int iceP_userid, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getTexture_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<byte[]>(progress, cancel);
            _iceI_getTexture(iceP_userid, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getTexture_name = "getTexture";

        private void _iceI_getTexture(int iceP_userid, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<byte[]>(completed);
            outAsync.invoke(
                _getTexture_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_userid);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(InvalidUserException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    byte[] ret;
                    ret = TextureHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task setTextureAsync(int userid, byte[] tex, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_setTextureAsync(userid, tex, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setTextureAsync(int iceP_userid, byte[] iceP_tex, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setTexture_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setTexture(iceP_userid, iceP_tex, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setTexture_name = "setTexture";

        private void _iceI_setTexture(int iceP_userid, byte[] iceP_tex, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setTexture_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_userid);
                    TextureHelper.write(ostr, iceP_tex);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(InvalidTextureException)
                    {
                        throw;
                    }
                    catch(InvalidUserException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<int> getUptimeAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getUptimeAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_getUptimeAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getUptime_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_getUptime(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getUptime_name = "getUptime";

        private void _iceI_getUptime(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _getUptime_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task updateCertificateAsync(string certificate, string privateKey, string passphrase, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_updateCertificateAsync(certificate, privateKey, passphrase, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_updateCertificateAsync(string iceP_certificate, string iceP_privateKey, string iceP_passphrase, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_updateCertificate_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_updateCertificate(iceP_certificate, iceP_privateKey, iceP_passphrase, context, synchronous, completed);
            return completed.Task;
        }

        private const string _updateCertificate_name = "updateCertificate";

        private void _iceI_updateCertificate(string iceP_certificate, string iceP_privateKey, string iceP_passphrase, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _updateCertificate_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_certificate);
                    ostr.writeString(iceP_privateKey);
                    ostr.writeString(iceP_passphrase);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidInputDataException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(ServerBootedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        #endregion

        #region Asynchronous operations

        public global::Ice.AsyncResult<Callback_Server_isRunning> begin_isRunning(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_isRunning(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_isRunning(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_isRunning(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_isRunning(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_isRunning(context, callback, cookie, false);
        }

        public bool end_isRunning(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _isRunning_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<bool>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_isRunning> begin_isRunning(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_isRunning_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_isRunning, bool>(
                (Callback_Server_isRunning cb, bool ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _isRunning_name, cookie, completedCallback);
            _iceI_isRunning(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_start> begin_start(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_start(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_start(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_start(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_start(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_start(context, callback, cookie, false);
        }

        public void end_start(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _start_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_start> begin_start(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_start_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_start, object>(
                (Callback_Server_start cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _start_name, cookie, completedCallback);
            _iceI_start(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_stop> begin_stop(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_stop(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_stop(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_stop(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_stop(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_stop(context, callback, cookie, false);
        }

        public void end_stop(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _stop_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_stop> begin_stop(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_stop_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_stop, object>(
                (Callback_Server_stop cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _stop_name, cookie, completedCallback);
            _iceI_stop(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_delete> begin_delete(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_delete(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_delete(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_delete(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_delete(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_delete(context, callback, cookie, false);
        }

        public void end_delete(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _delete_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_delete> begin_delete(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_delete_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_delete, object>(
                (Callback_Server_delete cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _delete_name, cookie, completedCallback);
            _iceI_delete(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_id> begin_id(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_id(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_id(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_id(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_id(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_id(context, callback, cookie, false);
        }

        public int end_id(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _id_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<int>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_id> begin_id(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_id_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_id, int>(
                (Callback_Server_id cb, int ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _id_name, cookie, completedCallback);
            _iceI_id(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_addCallback> begin_addCallback(ServerCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_addCallback(cb, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_addCallback(ServerCallbackPrx cb, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_addCallback(cb, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_addCallback(ServerCallbackPrx cb, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_addCallback(cb, context, callback, cookie, false);
        }

        public void end_addCallback(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _addCallback_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_addCallback> begin_addCallback(ServerCallbackPrx iceP_cb, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_addCallback_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_addCallback, object>(
                (Callback_Server_addCallback cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _addCallback_name, cookie, completedCallback);
            _iceI_addCallback(iceP_cb, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_removeCallback> begin_removeCallback(ServerCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_removeCallback(cb, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_removeCallback(ServerCallbackPrx cb, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_removeCallback(cb, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_removeCallback(ServerCallbackPrx cb, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_removeCallback(cb, context, callback, cookie, false);
        }

        public void end_removeCallback(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _removeCallback_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_removeCallback> begin_removeCallback(ServerCallbackPrx iceP_cb, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_removeCallback_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_removeCallback, object>(
                (Callback_Server_removeCallback cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _removeCallback_name, cookie, completedCallback);
            _iceI_removeCallback(iceP_cb, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_setAuthenticator> begin_setAuthenticator(ServerAuthenticatorPrx auth, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_setAuthenticator(auth, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_setAuthenticator(ServerAuthenticatorPrx auth, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setAuthenticator(auth, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_setAuthenticator(ServerAuthenticatorPrx auth, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setAuthenticator(auth, context, callback, cookie, false);
        }

        public void end_setAuthenticator(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _setAuthenticator_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_setAuthenticator> begin_setAuthenticator(ServerAuthenticatorPrx iceP_auth, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_setAuthenticator_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_setAuthenticator, object>(
                (Callback_Server_setAuthenticator cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _setAuthenticator_name, cookie, completedCallback);
            _iceI_setAuthenticator(iceP_auth, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getConf> begin_getConf(string key, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getConf(key, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getConf(string key, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getConf(key, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getConf(string key, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getConf(key, context, callback, cookie, false);
        }

        public string end_getConf(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getConf_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<string>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getConf> begin_getConf(string iceP_key, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getConf_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getConf, string>(
                (Callback_Server_getConf cb, string ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getConf_name, cookie, completedCallback);
            _iceI_getConf(iceP_key, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getAllConf> begin_getAllConf(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getAllConf(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getAllConf(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getAllConf(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getAllConf(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getAllConf(context, callback, cookie, false);
        }

        public global::System.Collections.Generic.Dictionary<string, string> end_getAllConf(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getAllConf_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<global::System.Collections.Generic.Dictionary<string, string>>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getAllConf> begin_getAllConf(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getAllConf_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getAllConf, global::System.Collections.Generic.Dictionary<string, string>>(
                (Callback_Server_getAllConf cb, global::System.Collections.Generic.Dictionary<string, string> ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getAllConf_name, cookie, completedCallback);
            _iceI_getAllConf(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_setConf> begin_setConf(string key, string value, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_setConf(key, value, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_setConf(string key, string value, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setConf(key, value, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_setConf(string key, string value, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setConf(key, value, context, callback, cookie, false);
        }

        public void end_setConf(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _setConf_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_setConf> begin_setConf(string iceP_key, string iceP_value, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_setConf_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_setConf, object>(
                (Callback_Server_setConf cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _setConf_name, cookie, completedCallback);
            _iceI_setConf(iceP_key, iceP_value, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_setSuperuserPassword> begin_setSuperuserPassword(string pw, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_setSuperuserPassword(pw, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_setSuperuserPassword(string pw, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setSuperuserPassword(pw, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_setSuperuserPassword(string pw, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setSuperuserPassword(pw, context, callback, cookie, false);
        }

        public void end_setSuperuserPassword(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _setSuperuserPassword_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_setSuperuserPassword> begin_setSuperuserPassword(string iceP_pw, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_setSuperuserPassword_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_setSuperuserPassword, object>(
                (Callback_Server_setSuperuserPassword cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _setSuperuserPassword_name, cookie, completedCallback);
            _iceI_setSuperuserPassword(iceP_pw, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getLog> begin_getLog(int first, int last, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getLog(first, last, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getLog(int first, int last, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getLog(first, last, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getLog(int first, int last, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getLog(first, last, context, callback, cookie, false);
        }

        public LogEntry[] end_getLog(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getLog_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<LogEntry[]>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getLog> begin_getLog(int iceP_first, int iceP_last, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getLog_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getLog, LogEntry[]>(
                (Callback_Server_getLog cb, LogEntry[] ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getLog_name, cookie, completedCallback);
            _iceI_getLog(iceP_first, iceP_last, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getLogLen> begin_getLogLen(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getLogLen(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getLogLen(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getLogLen(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getLogLen(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getLogLen(context, callback, cookie, false);
        }

        public int end_getLogLen(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getLogLen_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<int>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getLogLen> begin_getLogLen(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getLogLen_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getLogLen, int>(
                (Callback_Server_getLogLen cb, int ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getLogLen_name, cookie, completedCallback);
            _iceI_getLogLen(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getUsers> begin_getUsers(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getUsers(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getUsers(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getUsers(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getUsers(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getUsers(context, callback, cookie, false);
        }

        public global::System.Collections.Generic.Dictionary<int, User> end_getUsers(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getUsers_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<global::System.Collections.Generic.Dictionary<int, User>>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getUsers> begin_getUsers(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getUsers_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getUsers, global::System.Collections.Generic.Dictionary<int, User>>(
                (Callback_Server_getUsers cb, global::System.Collections.Generic.Dictionary<int, User> ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getUsers_name, cookie, completedCallback);
            _iceI_getUsers(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getChannels> begin_getChannels(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getChannels(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getChannels(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getChannels(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getChannels(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getChannels(context, callback, cookie, false);
        }

        public global::System.Collections.Generic.Dictionary<int, Channel> end_getChannels(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getChannels_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<global::System.Collections.Generic.Dictionary<int, Channel>>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getChannels> begin_getChannels(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getChannels_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getChannels, global::System.Collections.Generic.Dictionary<int, Channel>>(
                (Callback_Server_getChannels cb, global::System.Collections.Generic.Dictionary<int, Channel> ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getChannels_name, cookie, completedCallback);
            _iceI_getChannels(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getCertificateList> begin_getCertificateList(int session, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getCertificateList(session, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getCertificateList(int session, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getCertificateList(session, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getCertificateList(int session, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getCertificateList(session, context, callback, cookie, false);
        }

        public byte[][] end_getCertificateList(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getCertificateList_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<byte[][]>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getCertificateList> begin_getCertificateList(int iceP_session, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getCertificateList_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getCertificateList, byte[][]>(
                (Callback_Server_getCertificateList cb, byte[][] ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getCertificateList_name, cookie, completedCallback);
            _iceI_getCertificateList(iceP_session, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getTree> begin_getTree(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getTree(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getTree(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getTree(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getTree(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getTree(context, callback, cookie, false);
        }

        public Tree end_getTree(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getTree_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<Tree>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getTree> begin_getTree(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getTree_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getTree, Tree>(
                (Callback_Server_getTree cb, Tree ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getTree_name, cookie, completedCallback);
            _iceI_getTree(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getBans> begin_getBans(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getBans(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getBans(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getBans(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getBans(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getBans(context, callback, cookie, false);
        }

        public Ban[] end_getBans(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getBans_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<Ban[]>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getBans> begin_getBans(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getBans_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getBans, Ban[]>(
                (Callback_Server_getBans cb, Ban[] ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getBans_name, cookie, completedCallback);
            _iceI_getBans(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_setBans> begin_setBans(Ban[] bans, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_setBans(bans, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_setBans(Ban[] bans, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setBans(bans, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_setBans(Ban[] bans, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setBans(bans, context, callback, cookie, false);
        }

        public void end_setBans(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _setBans_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_setBans> begin_setBans(Ban[] iceP_bans, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_setBans_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_setBans, object>(
                (Callback_Server_setBans cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _setBans_name, cookie, completedCallback);
            _iceI_setBans(iceP_bans, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_kickUser> begin_kickUser(int session, string reason, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_kickUser(session, reason, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_kickUser(int session, string reason, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_kickUser(session, reason, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_kickUser(int session, string reason, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_kickUser(session, reason, context, callback, cookie, false);
        }

        public void end_kickUser(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _kickUser_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_kickUser> begin_kickUser(int iceP_session, string iceP_reason, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_kickUser_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_kickUser, object>(
                (Callback_Server_kickUser cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _kickUser_name, cookie, completedCallback);
            _iceI_kickUser(iceP_session, iceP_reason, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getState> begin_getState(int session, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getState(session, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getState(int session, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getState(session, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getState(int session, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getState(session, context, callback, cookie, false);
        }

        public User end_getState(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getState_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<User>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getState> begin_getState(int iceP_session, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getState_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getState, User>(
                (Callback_Server_getState cb, User ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getState_name, cookie, completedCallback);
            _iceI_getState(iceP_session, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_setState> begin_setState(User state, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_setState(state, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_setState(User state, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setState(state, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_setState(User state, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setState(state, context, callback, cookie, false);
        }

        public void end_setState(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _setState_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_setState> begin_setState(User iceP_state, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_setState_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_setState, object>(
                (Callback_Server_setState cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _setState_name, cookie, completedCallback);
            _iceI_setState(iceP_state, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_sendMessage> begin_sendMessage(int session, string text, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_sendMessage(session, text, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_sendMessage(int session, string text, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_sendMessage(session, text, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_sendMessage(int session, string text, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_sendMessage(session, text, context, callback, cookie, false);
        }

        public void end_sendMessage(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _sendMessage_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_sendMessage> begin_sendMessage(int iceP_session, string iceP_text, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_sendMessage_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_sendMessage, object>(
                (Callback_Server_sendMessage cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _sendMessage_name, cookie, completedCallback);
            _iceI_sendMessage(iceP_session, iceP_text, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_hasPermission> begin_hasPermission(int session, int channelid, int perm, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_hasPermission(session, channelid, perm, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_hasPermission(int session, int channelid, int perm, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_hasPermission(session, channelid, perm, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_hasPermission(int session, int channelid, int perm, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_hasPermission(session, channelid, perm, context, callback, cookie, false);
        }

        public bool end_hasPermission(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _hasPermission_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<bool>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_hasPermission> begin_hasPermission(int iceP_session, int iceP_channelid, int iceP_perm, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_hasPermission_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_hasPermission, bool>(
                (Callback_Server_hasPermission cb, bool ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _hasPermission_name, cookie, completedCallback);
            _iceI_hasPermission(iceP_session, iceP_channelid, iceP_perm, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_effectivePermissions> begin_effectivePermissions(int session, int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_effectivePermissions(session, channelid, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_effectivePermissions(int session, int channelid, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_effectivePermissions(session, channelid, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_effectivePermissions(int session, int channelid, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_effectivePermissions(session, channelid, context, callback, cookie, false);
        }

        public int end_effectivePermissions(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _effectivePermissions_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<int>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_effectivePermissions> begin_effectivePermissions(int iceP_session, int iceP_channelid, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_effectivePermissions_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_effectivePermissions, int>(
                (Callback_Server_effectivePermissions cb, int ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _effectivePermissions_name, cookie, completedCallback);
            _iceI_effectivePermissions(iceP_session, iceP_channelid, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_addContextCallback> begin_addContextCallback(int session, string action, string text, ServerContextCallbackPrx cb, int ctx, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_addContextCallback(session, action, text, cb, ctx, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_addContextCallback(int session, string action, string text, ServerContextCallbackPrx cb, int ctx, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_addContextCallback(session, action, text, cb, ctx, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_addContextCallback(int session, string action, string text, ServerContextCallbackPrx cb, int ctx, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_addContextCallback(session, action, text, cb, ctx, context, callback, cookie, false);
        }

        public void end_addContextCallback(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _addContextCallback_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_addContextCallback> begin_addContextCallback(int iceP_session, string iceP_action, string iceP_text, ServerContextCallbackPrx iceP_cb, int iceP_ctx, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_addContextCallback_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_addContextCallback, object>(
                (Callback_Server_addContextCallback cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _addContextCallback_name, cookie, completedCallback);
            _iceI_addContextCallback(iceP_session, iceP_action, iceP_text, iceP_cb, iceP_ctx, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_removeContextCallback> begin_removeContextCallback(ServerContextCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_removeContextCallback(cb, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_removeContextCallback(ServerContextCallbackPrx cb, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_removeContextCallback(cb, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_removeContextCallback(ServerContextCallbackPrx cb, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_removeContextCallback(cb, context, callback, cookie, false);
        }

        public void end_removeContextCallback(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _removeContextCallback_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_removeContextCallback> begin_removeContextCallback(ServerContextCallbackPrx iceP_cb, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_removeContextCallback_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_removeContextCallback, object>(
                (Callback_Server_removeContextCallback cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _removeContextCallback_name, cookie, completedCallback);
            _iceI_removeContextCallback(iceP_cb, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getChannelState> begin_getChannelState(int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getChannelState(channelid, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getChannelState(int channelid, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getChannelState(channelid, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getChannelState(int channelid, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getChannelState(channelid, context, callback, cookie, false);
        }

        public Channel end_getChannelState(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getChannelState_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<Channel>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getChannelState> begin_getChannelState(int iceP_channelid, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getChannelState_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getChannelState, Channel>(
                (Callback_Server_getChannelState cb, Channel ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getChannelState_name, cookie, completedCallback);
            _iceI_getChannelState(iceP_channelid, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_setChannelState> begin_setChannelState(Channel state, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_setChannelState(state, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_setChannelState(Channel state, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setChannelState(state, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_setChannelState(Channel state, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setChannelState(state, context, callback, cookie, false);
        }

        public void end_setChannelState(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _setChannelState_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_setChannelState> begin_setChannelState(Channel iceP_state, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_setChannelState_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_setChannelState, object>(
                (Callback_Server_setChannelState cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _setChannelState_name, cookie, completedCallback);
            _iceI_setChannelState(iceP_state, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_removeChannel> begin_removeChannel(int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_removeChannel(channelid, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_removeChannel(int channelid, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_removeChannel(channelid, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_removeChannel(int channelid, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_removeChannel(channelid, context, callback, cookie, false);
        }

        public void end_removeChannel(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _removeChannel_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_removeChannel> begin_removeChannel(int iceP_channelid, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_removeChannel_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_removeChannel, object>(
                (Callback_Server_removeChannel cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _removeChannel_name, cookie, completedCallback);
            _iceI_removeChannel(iceP_channelid, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_addChannel> begin_addChannel(string name, int parent, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_addChannel(name, parent, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_addChannel(string name, int parent, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_addChannel(name, parent, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_addChannel(string name, int parent, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_addChannel(name, parent, context, callback, cookie, false);
        }

        public int end_addChannel(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _addChannel_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<int>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_addChannel> begin_addChannel(string iceP_name, int iceP_parent, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_addChannel_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_addChannel, int>(
                (Callback_Server_addChannel cb, int ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _addChannel_name, cookie, completedCallback);
            _iceI_addChannel(iceP_name, iceP_parent, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_sendMessageChannel> begin_sendMessageChannel(int channelid, bool tree, string text, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_sendMessageChannel(channelid, tree, text, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_sendMessageChannel(int channelid, bool tree, string text, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_sendMessageChannel(channelid, tree, text, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_sendMessageChannel(int channelid, bool tree, string text, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_sendMessageChannel(channelid, tree, text, context, callback, cookie, false);
        }

        public void end_sendMessageChannel(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _sendMessageChannel_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_sendMessageChannel> begin_sendMessageChannel(int iceP_channelid, bool iceP_tree, string iceP_text, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_sendMessageChannel_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_sendMessageChannel, object>(
                (Callback_Server_sendMessageChannel cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _sendMessageChannel_name, cookie, completedCallback);
            _iceI_sendMessageChannel(iceP_channelid, iceP_tree, iceP_text, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getACL> begin_getACL(int channelid, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getACL(channelid, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getACL(int channelid, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getACL(channelid, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getACL(int channelid, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getACL(channelid, context, callback, cookie, false);
        }

        public void end_getACL(out ACL[] acls, out Group[] groups, out bool inherit, global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getACL_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<Server_GetACLResult>)resultI_.OutgoingAsync;
            var result_ = outgoing_.getResult(resultI_.wait());
            acls = result_.acls;
            groups = result_.groups;
            inherit = result_.inherit;
        }

        private global::Ice.AsyncResult<Callback_Server_getACL> begin_getACL(int iceP_channelid, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getACL_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getACL, Server_GetACLResult>(
                (Callback_Server_getACL cb, Server_GetACLResult ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret.acls, ret.groups, ret.inherit);
                    }
                },
                this, _getACL_name, cookie, completedCallback);
            _iceI_getACL(iceP_channelid, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_setACL> begin_setACL(int channelid, ACL[] acls, Group[] groups, bool inherit, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_setACL(channelid, acls, groups, inherit, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_setACL(int channelid, ACL[] acls, Group[] groups, bool inherit, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setACL(channelid, acls, groups, inherit, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_setACL(int channelid, ACL[] acls, Group[] groups, bool inherit, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setACL(channelid, acls, groups, inherit, context, callback, cookie, false);
        }

        public void end_setACL(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _setACL_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_setACL> begin_setACL(int iceP_channelid, ACL[] iceP_acls, Group[] iceP_groups, bool iceP_inherit, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_setACL_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_setACL, object>(
                (Callback_Server_setACL cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _setACL_name, cookie, completedCallback);
            _iceI_setACL(iceP_channelid, iceP_acls, iceP_groups, iceP_inherit, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_addUserToGroup> begin_addUserToGroup(int channelid, int session, string group, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_addUserToGroup(channelid, session, group, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_addUserToGroup(int channelid, int session, string group, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_addUserToGroup(channelid, session, group, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_addUserToGroup(int channelid, int session, string group, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_addUserToGroup(channelid, session, group, context, callback, cookie, false);
        }

        public void end_addUserToGroup(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _addUserToGroup_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_addUserToGroup> begin_addUserToGroup(int iceP_channelid, int iceP_session, string iceP_group, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_addUserToGroup_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_addUserToGroup, object>(
                (Callback_Server_addUserToGroup cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _addUserToGroup_name, cookie, completedCallback);
            _iceI_addUserToGroup(iceP_channelid, iceP_session, iceP_group, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_removeUserFromGroup> begin_removeUserFromGroup(int channelid, int session, string group, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_removeUserFromGroup(channelid, session, group, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_removeUserFromGroup(int channelid, int session, string group, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_removeUserFromGroup(channelid, session, group, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_removeUserFromGroup(int channelid, int session, string group, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_removeUserFromGroup(channelid, session, group, context, callback, cookie, false);
        }

        public void end_removeUserFromGroup(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _removeUserFromGroup_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_removeUserFromGroup> begin_removeUserFromGroup(int iceP_channelid, int iceP_session, string iceP_group, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_removeUserFromGroup_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_removeUserFromGroup, object>(
                (Callback_Server_removeUserFromGroup cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _removeUserFromGroup_name, cookie, completedCallback);
            _iceI_removeUserFromGroup(iceP_channelid, iceP_session, iceP_group, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_redirectWhisperGroup> begin_redirectWhisperGroup(int session, string source, string target, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_redirectWhisperGroup(session, source, target, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_redirectWhisperGroup(int session, string source, string target, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_redirectWhisperGroup(session, source, target, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_redirectWhisperGroup(int session, string source, string target, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_redirectWhisperGroup(session, source, target, context, callback, cookie, false);
        }

        public void end_redirectWhisperGroup(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _redirectWhisperGroup_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_redirectWhisperGroup> begin_redirectWhisperGroup(int iceP_session, string iceP_source, string iceP_target, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_redirectWhisperGroup_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_redirectWhisperGroup, object>(
                (Callback_Server_redirectWhisperGroup cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _redirectWhisperGroup_name, cookie, completedCallback);
            _iceI_redirectWhisperGroup(iceP_session, iceP_source, iceP_target, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getUserNames> begin_getUserNames(int[] ids, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getUserNames(ids, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getUserNames(int[] ids, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getUserNames(ids, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getUserNames(int[] ids, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getUserNames(ids, context, callback, cookie, false);
        }

        public global::System.Collections.Generic.Dictionary<int, string> end_getUserNames(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getUserNames_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<global::System.Collections.Generic.Dictionary<int, string>>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getUserNames> begin_getUserNames(int[] iceP_ids, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getUserNames_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getUserNames, global::System.Collections.Generic.Dictionary<int, string>>(
                (Callback_Server_getUserNames cb, global::System.Collections.Generic.Dictionary<int, string> ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getUserNames_name, cookie, completedCallback);
            _iceI_getUserNames(iceP_ids, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getUserIds> begin_getUserIds(string[] names, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getUserIds(names, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getUserIds(string[] names, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getUserIds(names, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getUserIds(string[] names, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getUserIds(names, context, callback, cookie, false);
        }

        public global::System.Collections.Generic.Dictionary<string, int> end_getUserIds(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getUserIds_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<global::System.Collections.Generic.Dictionary<string, int>>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getUserIds> begin_getUserIds(string[] iceP_names, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getUserIds_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getUserIds, global::System.Collections.Generic.Dictionary<string, int>>(
                (Callback_Server_getUserIds cb, global::System.Collections.Generic.Dictionary<string, int> ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getUserIds_name, cookie, completedCallback);
            _iceI_getUserIds(iceP_names, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_registerUser> begin_registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_registerUser(info, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_registerUser(info, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_registerUser(info, context, callback, cookie, false);
        }

        public int end_registerUser(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _registerUser_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<int>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_registerUser> begin_registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_registerUser_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_registerUser, int>(
                (Callback_Server_registerUser cb, int ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _registerUser_name, cookie, completedCallback);
            _iceI_registerUser(iceP_info, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_unregisterUser> begin_unregisterUser(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_unregisterUser(userid, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_unregisterUser(int userid, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_unregisterUser(userid, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_unregisterUser(int userid, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_unregisterUser(userid, context, callback, cookie, false);
        }

        public void end_unregisterUser(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _unregisterUser_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_unregisterUser> begin_unregisterUser(int iceP_userid, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_unregisterUser_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_unregisterUser, object>(
                (Callback_Server_unregisterUser cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _unregisterUser_name, cookie, completedCallback);
            _iceI_unregisterUser(iceP_userid, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_updateRegistration> begin_updateRegistration(int userid, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_updateRegistration(userid, info, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_updateRegistration(int userid, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_updateRegistration(userid, info, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_updateRegistration(int userid, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_updateRegistration(userid, info, context, callback, cookie, false);
        }

        public void end_updateRegistration(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _updateRegistration_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_updateRegistration> begin_updateRegistration(int iceP_userid, global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_updateRegistration_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_updateRegistration, object>(
                (Callback_Server_updateRegistration cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _updateRegistration_name, cookie, completedCallback);
            _iceI_updateRegistration(iceP_userid, iceP_info, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getRegistration> begin_getRegistration(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getRegistration(userid, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getRegistration(int userid, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getRegistration(userid, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getRegistration(int userid, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getRegistration(userid, context, callback, cookie, false);
        }

        public global::System.Collections.Generic.Dictionary<UserInfo, string> end_getRegistration(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getRegistration_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<global::System.Collections.Generic.Dictionary<UserInfo, string>>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getRegistration> begin_getRegistration(int iceP_userid, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getRegistration_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getRegistration, global::System.Collections.Generic.Dictionary<UserInfo, string>>(
                (Callback_Server_getRegistration cb, global::System.Collections.Generic.Dictionary<UserInfo, string> ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getRegistration_name, cookie, completedCallback);
            _iceI_getRegistration(iceP_userid, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getRegisteredUsers> begin_getRegisteredUsers(string filter, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getRegisteredUsers(filter, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getRegisteredUsers(string filter, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getRegisteredUsers(filter, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getRegisteredUsers(string filter, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getRegisteredUsers(filter, context, callback, cookie, false);
        }

        public global::System.Collections.Generic.Dictionary<int, string> end_getRegisteredUsers(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getRegisteredUsers_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<global::System.Collections.Generic.Dictionary<int, string>>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getRegisteredUsers> begin_getRegisteredUsers(string iceP_filter, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getRegisteredUsers_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getRegisteredUsers, global::System.Collections.Generic.Dictionary<int, string>>(
                (Callback_Server_getRegisteredUsers cb, global::System.Collections.Generic.Dictionary<int, string> ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getRegisteredUsers_name, cookie, completedCallback);
            _iceI_getRegisteredUsers(iceP_filter, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_verifyPassword> begin_verifyPassword(string name, string pw, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_verifyPassword(name, pw, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_verifyPassword(string name, string pw, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_verifyPassword(name, pw, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_verifyPassword(string name, string pw, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_verifyPassword(name, pw, context, callback, cookie, false);
        }

        public int end_verifyPassword(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _verifyPassword_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<int>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_verifyPassword> begin_verifyPassword(string iceP_name, string iceP_pw, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_verifyPassword_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_verifyPassword, int>(
                (Callback_Server_verifyPassword cb, int ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _verifyPassword_name, cookie, completedCallback);
            _iceI_verifyPassword(iceP_name, iceP_pw, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getTexture> begin_getTexture(int userid, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getTexture(userid, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getTexture(int userid, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getTexture(userid, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getTexture(int userid, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getTexture(userid, context, callback, cookie, false);
        }

        public byte[] end_getTexture(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getTexture_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<byte[]>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getTexture> begin_getTexture(int iceP_userid, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getTexture_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getTexture, byte[]>(
                (Callback_Server_getTexture cb, byte[] ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getTexture_name, cookie, completedCallback);
            _iceI_getTexture(iceP_userid, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_setTexture> begin_setTexture(int userid, byte[] tex, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_setTexture(userid, tex, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_setTexture(int userid, byte[] tex, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setTexture(userid, tex, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_setTexture(int userid, byte[] tex, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_setTexture(userid, tex, context, callback, cookie, false);
        }

        public void end_setTexture(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _setTexture_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_setTexture> begin_setTexture(int iceP_userid, byte[] iceP_tex, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_setTexture_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_setTexture, object>(
                (Callback_Server_setTexture cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _setTexture_name, cookie, completedCallback);
            _iceI_setTexture(iceP_userid, iceP_tex, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_getUptime> begin_getUptime(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getUptime(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getUptime(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getUptime(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getUptime(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getUptime(context, callback, cookie, false);
        }

        public int end_getUptime(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getUptime_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<int>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_getUptime> begin_getUptime(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getUptime_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_getUptime, int>(
                (Callback_Server_getUptime cb, int ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getUptime_name, cookie, completedCallback);
            _iceI_getUptime(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Server_updateCertificate> begin_updateCertificate(string certificate, string privateKey, string passphrase, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_updateCertificate(certificate, privateKey, passphrase, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_updateCertificate(string certificate, string privateKey, string passphrase, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_updateCertificate(certificate, privateKey, passphrase, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_updateCertificate(string certificate, string privateKey, string passphrase, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_updateCertificate(certificate, privateKey, passphrase, context, callback, cookie, false);
        }

        public void end_updateCertificate(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _updateCertificate_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Server_updateCertificate> begin_updateCertificate(string iceP_certificate, string iceP_privateKey, string iceP_passphrase, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_updateCertificate_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Server_updateCertificate, object>(
                (Callback_Server_updateCertificate cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _updateCertificate_name, cookie, completedCallback);
            _iceI_updateCertificate(iceP_certificate, iceP_privateKey, iceP_passphrase, context, synchronous, completed);
            return completed;
        }

        #endregion

        #region Checked and unchecked cast operations

        public static ServerPrx checkedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            ServerPrx r = b as ServerPrx;
            if((r == null) && b.ice_isA(ice_staticId()))
            {
                ServerPrxHelper h = new ServerPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ServerPrx checkedCast(global::Ice.ObjectPrx b, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            ServerPrx r = b as ServerPrx;
            if((r == null) && b.ice_isA(ice_staticId(), ctx))
            {
                ServerPrxHelper h = new ServerPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ServerPrx checkedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId()))
                {
                    ServerPrxHelper h = new ServerPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static ServerPrx checkedCast(global::Ice.ObjectPrx b, string f, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId(), ctx))
                {
                    ServerPrxHelper h = new ServerPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static ServerPrx uncheckedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            ServerPrx r = b as ServerPrx;
            if(r == null)
            {
                ServerPrxHelper h = new ServerPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ServerPrx uncheckedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            ServerPrxHelper h = new ServerPrxHelper();
            h.iceCopyFrom(bb);
            return h;
        }

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::Murmur::Server"
        };

        public static string ice_staticId()
        {
            return _ids[1];
        }

        #endregion

        #region Marshaling support

        public static void write(global::Ice.OutputStream ostr, ServerPrx v)
        {
            ostr.writeProxy(v);
        }

        public static ServerPrx read(global::Ice.InputStream istr)
        {
            global::Ice.ObjectPrx proxy = istr.readProxy();
            if(proxy != null)
            {
                ServerPrxHelper result = new ServerPrxHelper();
                result.iceCopyFrom(proxy);
                return result;
            }
            return null;
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    [global::System.Serializable]
    public sealed class MetaCallbackPrxHelper : global::Ice.ObjectPrxHelperBase, MetaCallbackPrx
    {
        public MetaCallbackPrxHelper()
        {
        }

        public MetaCallbackPrxHelper(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #region Synchronous operations

        public void started(ServerPrx srv, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_startedAsync(srv, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void stopped(ServerPrx srv, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_stoppedAsync(srv, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        #endregion

        #region Async Task operations

        public global::System.Threading.Tasks.Task startedAsync(ServerPrx srv, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_startedAsync(srv, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_startedAsync(ServerPrx iceP_srv, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_started(iceP_srv, context, synchronous, completed);
            return completed.Task;
        }

        private const string _started_name = "started";

        private void _iceI_started(ServerPrx iceP_srv, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _started_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ServerPrxHelper.write(ostr, iceP_srv);
                });
        }

        public global::System.Threading.Tasks.Task stoppedAsync(ServerPrx srv, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_stoppedAsync(srv, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_stoppedAsync(ServerPrx iceP_srv, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_stopped(iceP_srv, context, synchronous, completed);
            return completed.Task;
        }

        private const string _stopped_name = "stopped";

        private void _iceI_stopped(ServerPrx iceP_srv, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _stopped_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ServerPrxHelper.write(ostr, iceP_srv);
                });
        }

        #endregion

        #region Asynchronous operations

        public global::Ice.AsyncResult<Callback_MetaCallback_started> begin_started(ServerPrx srv, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_started(srv, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_started(ServerPrx srv, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_started(srv, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_started(ServerPrx srv, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_started(srv, context, callback, cookie, false);
        }

        public void end_started(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _started_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_MetaCallback_started> begin_started(ServerPrx iceP_srv, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_MetaCallback_started, object>(
                (Callback_MetaCallback_started cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _started_name, cookie, completedCallback);
            _iceI_started(iceP_srv, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_MetaCallback_stopped> begin_stopped(ServerPrx srv, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_stopped(srv, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_stopped(ServerPrx srv, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_stopped(srv, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_stopped(ServerPrx srv, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_stopped(srv, context, callback, cookie, false);
        }

        public void end_stopped(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _stopped_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_MetaCallback_stopped> begin_stopped(ServerPrx iceP_srv, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_MetaCallback_stopped, object>(
                (Callback_MetaCallback_stopped cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _stopped_name, cookie, completedCallback);
            _iceI_stopped(iceP_srv, context, synchronous, completed);
            return completed;
        }

        #endregion

        #region Checked and unchecked cast operations

        public static MetaCallbackPrx checkedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            MetaCallbackPrx r = b as MetaCallbackPrx;
            if((r == null) && b.ice_isA(ice_staticId()))
            {
                MetaCallbackPrxHelper h = new MetaCallbackPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static MetaCallbackPrx checkedCast(global::Ice.ObjectPrx b, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            MetaCallbackPrx r = b as MetaCallbackPrx;
            if((r == null) && b.ice_isA(ice_staticId(), ctx))
            {
                MetaCallbackPrxHelper h = new MetaCallbackPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static MetaCallbackPrx checkedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId()))
                {
                    MetaCallbackPrxHelper h = new MetaCallbackPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static MetaCallbackPrx checkedCast(global::Ice.ObjectPrx b, string f, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId(), ctx))
                {
                    MetaCallbackPrxHelper h = new MetaCallbackPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static MetaCallbackPrx uncheckedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            MetaCallbackPrx r = b as MetaCallbackPrx;
            if(r == null)
            {
                MetaCallbackPrxHelper h = new MetaCallbackPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static MetaCallbackPrx uncheckedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            MetaCallbackPrxHelper h = new MetaCallbackPrxHelper();
            h.iceCopyFrom(bb);
            return h;
        }

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::Murmur::MetaCallback"
        };

        public static string ice_staticId()
        {
            return _ids[1];
        }

        #endregion

        #region Marshaling support

        public static void write(global::Ice.OutputStream ostr, MetaCallbackPrx v)
        {
            ostr.writeProxy(v);
        }

        public static MetaCallbackPrx read(global::Ice.InputStream istr)
        {
            global::Ice.ObjectPrx proxy = istr.readProxy();
            if(proxy != null)
            {
                MetaCallbackPrxHelper result = new MetaCallbackPrxHelper();
                result.iceCopyFrom(proxy);
                return result;
            }
            return null;
        }

        #endregion
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class ServerListHelper
    {
        public static void write(global::Ice.OutputStream ostr, ServerPrx[] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    ServerPrxHelper.write(ostr, v[ix]);
                }
            }
        }

        public static ServerPrx[] read(global::Ice.InputStream istr)
        {
            ServerPrx[] v;
            {
                int szx = istr.readAndCheckSeqSize(2);
                v = new ServerPrx[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = ServerPrxHelper.read(istr);
                }
            }
            return v;
        }
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    [global::System.Serializable]
    public sealed class MetaPrxHelper : global::Ice.ObjectPrxHelperBase, MetaPrx
    {
        public MetaPrxHelper()
        {
        }

        public MetaPrxHelper(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #region Synchronous operations

        public ServerPrx getServer(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getServerAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public ServerPrx newServer(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_newServerAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public ServerPrx[] getBootedServers(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getBootedServersAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public ServerPrx[] getAllServers(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getAllServersAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public global::System.Collections.Generic.Dictionary<string, string> getDefaultConf(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getDefaultConfAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void getVersion(out int major, out int minor, out int patch, out string text, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                var result_ = _iceI_getVersionAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
                major = result_.major;
                minor = result_.minor;
                patch = result_.patch;
                text = result_.text;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void addCallback(MetaCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_addCallbackAsync(cb, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void removeCallback(MetaCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_removeCallbackAsync(cb, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int getUptime(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getUptimeAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public string getSlice(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getSliceAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public global::System.Collections.Generic.Dictionary<string, string> getSliceChecksums(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getSliceChecksumsAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        #endregion

        #region Async Task operations

        public global::System.Threading.Tasks.Task<ServerPrx> getServerAsync(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getServerAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ServerPrx> _iceI_getServerAsync(int iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getServer_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<ServerPrx>(progress, cancel);
            _iceI_getServer(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getServer_name = "getServer";

        private void _iceI_getServer(int iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ServerPrx>(completed);
            outAsync.invoke(
                _getServer_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_id);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    ServerPrx ret;
                    ret = ServerPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<ServerPrx> newServerAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_newServerAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ServerPrx> _iceI_newServerAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_newServer_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<ServerPrx>(progress, cancel);
            _iceI_newServer(context, synchronous, completed);
            return completed.Task;
        }

        private const string _newServer_name = "newServer";

        private void _iceI_newServer(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ServerPrx>(completed);
            outAsync.invoke(
                _newServer_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    ServerPrx ret;
                    ret = ServerPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<ServerPrx[]> getBootedServersAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getBootedServersAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ServerPrx[]> _iceI_getBootedServersAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getBootedServers_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<ServerPrx[]>(progress, cancel);
            _iceI_getBootedServers(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getBootedServers_name = "getBootedServers";

        private void _iceI_getBootedServers(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ServerPrx[]>(completed);
            outAsync.invoke(
                _getBootedServers_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    ServerPrx[] ret;
                    ret = ServerListHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<ServerPrx[]> getAllServersAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getAllServersAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ServerPrx[]> _iceI_getAllServersAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAllServers_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<ServerPrx[]>(progress, cancel);
            _iceI_getAllServers(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAllServers_name = "getAllServers";

        private void _iceI_getAllServers(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ServerPrx[]>(completed);
            outAsync.invoke(
                _getAllServers_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    ServerPrx[] ret;
                    ret = ServerListHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, string>> getDefaultConfAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getDefaultConfAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, string>> _iceI_getDefaultConfAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getDefaultConf_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<global::System.Collections.Generic.Dictionary<string, string>>(progress, cancel);
            _iceI_getDefaultConf(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getDefaultConf_name = "getDefaultConf";

        private void _iceI_getDefaultConf(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::System.Collections.Generic.Dictionary<string, string>>(completed);
            outAsync.invoke(
                _getDefaultConf_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    global::System.Collections.Generic.Dictionary<string, string> ret;
                    ret = ConfigMapHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<Meta_GetVersionResult> getVersionAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getVersionAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<Meta_GetVersionResult> _iceI_getVersionAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getVersion_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<Meta_GetVersionResult>(progress, cancel);
            _iceI_getVersion(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getVersion_name = "getVersion";

        private void _iceI_getVersion(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<Meta_GetVersionResult>(completed);
            outAsync.invoke(
                _getVersion_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                read: (global::Ice.InputStream istr) =>
                {
                    Meta_GetVersionResult ret = new Meta_GetVersionResult();
                    ret.major = istr.readInt();
                    ret.minor = istr.readInt();
                    ret.patch = istr.readInt();
                    ret.text = istr.readString();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task addCallbackAsync(MetaCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_addCallbackAsync(cb, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_addCallbackAsync(MetaCallbackPrx iceP_cb, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_addCallback_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_addCallback(iceP_cb, context, synchronous, completed);
            return completed.Task;
        }

        private const string _addCallback_name = "addCallback";

        private void _iceI_addCallback(MetaCallbackPrx iceP_cb, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _addCallback_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    MetaCallbackPrxHelper.write(ostr, iceP_cb);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidCallbackException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task removeCallbackAsync(MetaCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_removeCallbackAsync(cb, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_removeCallbackAsync(MetaCallbackPrx iceP_cb, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_removeCallback_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_removeCallback(iceP_cb, context, synchronous, completed);
            return completed.Task;
        }

        private const string _removeCallback_name = "removeCallback";

        private void _iceI_removeCallback(MetaCallbackPrx iceP_cb, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _removeCallback_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    MetaCallbackPrxHelper.write(ostr, iceP_cb);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(InvalidCallbackException)
                    {
                        throw;
                    }
                    catch(InvalidSecretException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<int> getUptimeAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getUptimeAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_getUptimeAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getUptime_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_getUptime(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getUptime_name = "getUptime";

        private void _iceI_getUptime(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _getUptime_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<string> getSliceAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getSliceAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string> _iceI_getSliceAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getSlice_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<string>(progress, cancel);
            _iceI_getSlice(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getSlice_name = "getSlice";

        private void _iceI_getSlice(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string>(completed);
            outAsync.invoke(
                _getSlice_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                read: (global::Ice.InputStream istr) =>
                {
                    string ret;
                    ret = istr.readString();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, string>> getSliceChecksumsAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getSliceChecksumsAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, string>> _iceI_getSliceChecksumsAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getSliceChecksums_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<global::System.Collections.Generic.Dictionary<string, string>>(progress, cancel);
            _iceI_getSliceChecksums(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getSliceChecksums_name = "getSliceChecksums";

        private void _iceI_getSliceChecksums(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::System.Collections.Generic.Dictionary<string, string>>(completed);
            outAsync.invoke(
                _getSliceChecksums_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                read: (global::Ice.InputStream istr) =>
                {
                    global::System.Collections.Generic.Dictionary<string, string> ret;
                    ret = global::Ice.SliceChecksumDictHelper.read(istr);
                    return ret;
                });
        }

        #endregion

        #region Asynchronous operations

        public global::Ice.AsyncResult<Callback_Meta_getServer> begin_getServer(int id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getServer(id, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getServer(int id, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getServer(id, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getServer(int id, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getServer(id, context, callback, cookie, false);
        }

        public ServerPrx end_getServer(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getServer_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<ServerPrx>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Meta_getServer> begin_getServer(int iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getServer_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Meta_getServer, ServerPrx>(
                (Callback_Meta_getServer cb, ServerPrx ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getServer_name, cookie, completedCallback);
            _iceI_getServer(iceP_id, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Meta_newServer> begin_newServer(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_newServer(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_newServer(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_newServer(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_newServer(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_newServer(context, callback, cookie, false);
        }

        public ServerPrx end_newServer(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _newServer_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<ServerPrx>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Meta_newServer> begin_newServer(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_newServer_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Meta_newServer, ServerPrx>(
                (Callback_Meta_newServer cb, ServerPrx ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _newServer_name, cookie, completedCallback);
            _iceI_newServer(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Meta_getBootedServers> begin_getBootedServers(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getBootedServers(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getBootedServers(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getBootedServers(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getBootedServers(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getBootedServers(context, callback, cookie, false);
        }

        public ServerPrx[] end_getBootedServers(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getBootedServers_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<ServerPrx[]>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Meta_getBootedServers> begin_getBootedServers(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getBootedServers_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Meta_getBootedServers, ServerPrx[]>(
                (Callback_Meta_getBootedServers cb, ServerPrx[] ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getBootedServers_name, cookie, completedCallback);
            _iceI_getBootedServers(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Meta_getAllServers> begin_getAllServers(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getAllServers(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getAllServers(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getAllServers(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getAllServers(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getAllServers(context, callback, cookie, false);
        }

        public ServerPrx[] end_getAllServers(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getAllServers_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<ServerPrx[]>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Meta_getAllServers> begin_getAllServers(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getAllServers_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Meta_getAllServers, ServerPrx[]>(
                (Callback_Meta_getAllServers cb, ServerPrx[] ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getAllServers_name, cookie, completedCallback);
            _iceI_getAllServers(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Meta_getDefaultConf> begin_getDefaultConf(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getDefaultConf(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getDefaultConf(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getDefaultConf(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getDefaultConf(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getDefaultConf(context, callback, cookie, false);
        }

        public global::System.Collections.Generic.Dictionary<string, string> end_getDefaultConf(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getDefaultConf_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<global::System.Collections.Generic.Dictionary<string, string>>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Meta_getDefaultConf> begin_getDefaultConf(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getDefaultConf_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Meta_getDefaultConf, global::System.Collections.Generic.Dictionary<string, string>>(
                (Callback_Meta_getDefaultConf cb, global::System.Collections.Generic.Dictionary<string, string> ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getDefaultConf_name, cookie, completedCallback);
            _iceI_getDefaultConf(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Meta_getVersion> begin_getVersion(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getVersion(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getVersion(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getVersion(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getVersion(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getVersion(context, callback, cookie, false);
        }

        public void end_getVersion(out int major, out int minor, out int patch, out string text, global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getVersion_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<Meta_GetVersionResult>)resultI_.OutgoingAsync;
            var result_ = outgoing_.getResult(resultI_.wait());
            major = result_.major;
            minor = result_.minor;
            patch = result_.patch;
            text = result_.text;
        }

        private global::Ice.AsyncResult<Callback_Meta_getVersion> begin_getVersion(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getVersion_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Meta_getVersion, Meta_GetVersionResult>(
                (Callback_Meta_getVersion cb, Meta_GetVersionResult ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret.major, ret.minor, ret.patch, ret.text);
                    }
                },
                this, _getVersion_name, cookie, completedCallback);
            _iceI_getVersion(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Meta_addCallback> begin_addCallback(MetaCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_addCallback(cb, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_addCallback(MetaCallbackPrx cb, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_addCallback(cb, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_addCallback(MetaCallbackPrx cb, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_addCallback(cb, context, callback, cookie, false);
        }

        public void end_addCallback(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _addCallback_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Meta_addCallback> begin_addCallback(MetaCallbackPrx iceP_cb, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_addCallback_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Meta_addCallback, object>(
                (Callback_Meta_addCallback cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _addCallback_name, cookie, completedCallback);
            _iceI_addCallback(iceP_cb, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Meta_removeCallback> begin_removeCallback(MetaCallbackPrx cb, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_removeCallback(cb, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_removeCallback(MetaCallbackPrx cb, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_removeCallback(cb, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_removeCallback(MetaCallbackPrx cb, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_removeCallback(cb, context, callback, cookie, false);
        }

        public void end_removeCallback(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _removeCallback_name);
            ((global::IceInternal.OutgoingAsyncT<object>)resultI_.OutgoingAsync).getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Meta_removeCallback> begin_removeCallback(MetaCallbackPrx iceP_cb, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_removeCallback_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Meta_removeCallback, object>(
                (Callback_Meta_removeCallback cb, object ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke();
                    }
                },
                this, _removeCallback_name, cookie, completedCallback);
            _iceI_removeCallback(iceP_cb, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Meta_getUptime> begin_getUptime(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getUptime(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getUptime(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getUptime(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getUptime(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getUptime(context, callback, cookie, false);
        }

        public int end_getUptime(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getUptime_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<int>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Meta_getUptime> begin_getUptime(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getUptime_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Meta_getUptime, int>(
                (Callback_Meta_getUptime cb, int ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getUptime_name, cookie, completedCallback);
            _iceI_getUptime(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Meta_getSlice> begin_getSlice(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getSlice(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getSlice(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getSlice(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getSlice(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getSlice(context, callback, cookie, false);
        }

        public string end_getSlice(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getSlice_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<string>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Meta_getSlice> begin_getSlice(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getSlice_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Meta_getSlice, string>(
                (Callback_Meta_getSlice cb, string ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getSlice_name, cookie, completedCallback);
            _iceI_getSlice(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_Meta_getSliceChecksums> begin_getSliceChecksums(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getSliceChecksums(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getSliceChecksums(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getSliceChecksums(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getSliceChecksums(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getSliceChecksums(context, callback, cookie, false);
        }

        public global::System.Collections.Generic.Dictionary<string, string> end_getSliceChecksums(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getSliceChecksums_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<global::System.Collections.Generic.Dictionary<string, string>>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_Meta_getSliceChecksums> begin_getSliceChecksums(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getSliceChecksums_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_Meta_getSliceChecksums, global::System.Collections.Generic.Dictionary<string, string>>(
                (Callback_Meta_getSliceChecksums cb, global::System.Collections.Generic.Dictionary<string, string> ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getSliceChecksums_name, cookie, completedCallback);
            _iceI_getSliceChecksums(context, synchronous, completed);
            return completed;
        }

        #endregion

        #region Checked and unchecked cast operations

        public static MetaPrx checkedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            MetaPrx r = b as MetaPrx;
            if((r == null) && b.ice_isA(ice_staticId()))
            {
                MetaPrxHelper h = new MetaPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static MetaPrx checkedCast(global::Ice.ObjectPrx b, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            MetaPrx r = b as MetaPrx;
            if((r == null) && b.ice_isA(ice_staticId(), ctx))
            {
                MetaPrxHelper h = new MetaPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static MetaPrx checkedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId()))
                {
                    MetaPrxHelper h = new MetaPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static MetaPrx checkedCast(global::Ice.ObjectPrx b, string f, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId(), ctx))
                {
                    MetaPrxHelper h = new MetaPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static MetaPrx uncheckedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            MetaPrx r = b as MetaPrx;
            if(r == null)
            {
                MetaPrxHelper h = new MetaPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static MetaPrx uncheckedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            MetaPrxHelper h = new MetaPrxHelper();
            h.iceCopyFrom(bb);
            return h;
        }

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::Murmur::Meta"
        };

        public static string ice_staticId()
        {
            return _ids[1];
        }

        #endregion

        #region Marshaling support

        public static void write(global::Ice.OutputStream ostr, MetaPrx v)
        {
            ostr.writeProxy(v);
        }

        public static MetaPrx read(global::Ice.InputStream istr)
        {
            global::Ice.ObjectPrx proxy = istr.readProxy();
            if(proxy != null)
            {
                MetaPrxHelper result = new MetaPrxHelper();
                result.iceCopyFrom(proxy);
                return result;
            }
            return null;
        }

        #endregion
    }
}

namespace Murmur
{
    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class ServerCallbackDisp_ : global::Ice.ObjectImpl, ServerCallback
    {
        #region Slice operations

        public abstract void userConnected(User state, global::Ice.Current current = null);

        public abstract void userDisconnected(User state, global::Ice.Current current = null);

        public abstract void userStateChanged(User state, global::Ice.Current current = null);

        public abstract void userTextMessage(User state, TextMessage message, global::Ice.Current current = null);

        public abstract void channelCreated(Channel state, global::Ice.Current current = null);

        public abstract void channelRemoved(Channel state, global::Ice.Current current = null);

        public abstract void channelStateChanged(Channel state, global::Ice.Current current = null);

        #endregion

        #region Slice type-related members

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::Murmur::ServerCallback"
        };

        public override bool ice_isA(string s, global::Ice.Current current = null)
        {
            return global::System.Array.BinarySearch(_ids, s, IceUtilInternal.StringUtil.OrdinalStringComparer) >= 0;
        }

        public override string[] ice_ids(global::Ice.Current current = null)
        {
            return _ids;
        }

        public override string ice_id(global::Ice.Current current = null)
        {
            return _ids[1];
        }

        public static new string ice_staticId()
        {
            return _ids[1];
        }

        #endregion

        #region Operation dispatch

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_userConnected(ServerCallback obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            User iceP_state;
            iceP_state = null;
            iceP_state = User.ice_read(istr);
            inS.endReadParams();
            obj.userConnected(iceP_state, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_userDisconnected(ServerCallback obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            User iceP_state;
            iceP_state = null;
            iceP_state = User.ice_read(istr);
            inS.endReadParams();
            obj.userDisconnected(iceP_state, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_userStateChanged(ServerCallback obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            User iceP_state;
            iceP_state = null;
            iceP_state = User.ice_read(istr);
            inS.endReadParams();
            obj.userStateChanged(iceP_state, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_userTextMessage(ServerCallback obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            User iceP_state;
            iceP_state = null;
            TextMessage iceP_message;
            iceP_message = null;
            iceP_state = User.ice_read(istr);
            iceP_message = TextMessage.ice_read(istr);
            inS.endReadParams();
            obj.userTextMessage(iceP_state, iceP_message, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_channelCreated(ServerCallback obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            Channel iceP_state;
            iceP_state = null;
            iceP_state = Channel.ice_read(istr);
            inS.endReadParams();
            obj.channelCreated(iceP_state, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_channelRemoved(ServerCallback obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            Channel iceP_state;
            iceP_state = null;
            iceP_state = Channel.ice_read(istr);
            inS.endReadParams();
            obj.channelRemoved(iceP_state, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_channelStateChanged(ServerCallback obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            Channel iceP_state;
            iceP_state = null;
            iceP_state = Channel.ice_read(istr);
            inS.endReadParams();
            obj.channelStateChanged(iceP_state, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        private static readonly string[] _all =
        {
            "channelCreated",
            "channelRemoved",
            "channelStateChanged",
            "ice_id",
            "ice_ids",
            "ice_isA",
            "ice_ping",
            "userConnected",
            "userDisconnected",
            "userStateChanged",
            "userTextMessage"
        };

        public override global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceDispatch(global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            int pos = global::System.Array.BinarySearch(_all, current.operation, global::IceUtilInternal.StringUtil.OrdinalStringComparer);
            if(pos < 0)
            {
                throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
            }

            switch(pos)
            {
                case 0:
                {
                    return iceD_channelCreated(this, inS, current);
                }
                case 1:
                {
                    return iceD_channelRemoved(this, inS, current);
                }
                case 2:
                {
                    return iceD_channelStateChanged(this, inS, current);
                }
                case 3:
                {
                    return global::Ice.ObjectImpl.iceD_ice_id(this, inS, current);
                }
                case 4:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ids(this, inS, current);
                }
                case 5:
                {
                    return global::Ice.ObjectImpl.iceD_ice_isA(this, inS, current);
                }
                case 6:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ping(this, inS, current);
                }
                case 7:
                {
                    return iceD_userConnected(this, inS, current);
                }
                case 8:
                {
                    return iceD_userDisconnected(this, inS, current);
                }
                case 9:
                {
                    return iceD_userStateChanged(this, inS, current);
                }
                case 10:
                {
                    return iceD_userTextMessage(this, inS, current);
                }
            }

            global::System.Diagnostics.Debug.Assert(false);
            throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class ServerContextCallbackDisp_ : global::Ice.ObjectImpl, ServerContextCallback
    {
        #region Slice operations

        public abstract void contextAction(string action, User usr, int session, int channelid, global::Ice.Current current = null);

        #endregion

        #region Slice type-related members

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::Murmur::ServerContextCallback"
        };

        public override bool ice_isA(string s, global::Ice.Current current = null)
        {
            return global::System.Array.BinarySearch(_ids, s, IceUtilInternal.StringUtil.OrdinalStringComparer) >= 0;
        }

        public override string[] ice_ids(global::Ice.Current current = null)
        {
            return _ids;
        }

        public override string ice_id(global::Ice.Current current = null)
        {
            return _ids[1];
        }

        public static new string ice_staticId()
        {
            return _ids[1];
        }

        #endregion

        #region Operation dispatch

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_contextAction(ServerContextCallback obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_action;
            User iceP_usr;
            iceP_usr = null;
            int iceP_session;
            int iceP_channelid;
            iceP_action = istr.readString();
            iceP_usr = User.ice_read(istr);
            iceP_session = istr.readInt();
            iceP_channelid = istr.readInt();
            inS.endReadParams();
            obj.contextAction(iceP_action, iceP_usr, iceP_session, iceP_channelid, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        private static readonly string[] _all =
        {
            "contextAction",
            "ice_id",
            "ice_ids",
            "ice_isA",
            "ice_ping"
        };

        public override global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceDispatch(global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            int pos = global::System.Array.BinarySearch(_all, current.operation, global::IceUtilInternal.StringUtil.OrdinalStringComparer);
            if(pos < 0)
            {
                throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
            }

            switch(pos)
            {
                case 0:
                {
                    return iceD_contextAction(this, inS, current);
                }
                case 1:
                {
                    return global::Ice.ObjectImpl.iceD_ice_id(this, inS, current);
                }
                case 2:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ids(this, inS, current);
                }
                case 3:
                {
                    return global::Ice.ObjectImpl.iceD_ice_isA(this, inS, current);
                }
                case 4:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ping(this, inS, current);
                }
            }

            global::System.Diagnostics.Debug.Assert(false);
            throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class ServerAuthenticatorDisp_ : global::Ice.ObjectImpl, ServerAuthenticator
    {
        #region Slice operations

        public abstract int authenticate(string name, string pw, byte[][] certificates, string certhash, bool certstrong, out string newname, out string[] groups, global::Ice.Current current = null);

        public abstract bool getInfo(int id, out global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.Current current = null);

        public abstract int nameToId(string name, global::Ice.Current current = null);

        public abstract string idToName(int id, global::Ice.Current current = null);

        public abstract byte[] idToTexture(int id, global::Ice.Current current = null);

        #endregion

        #region Slice type-related members

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::Murmur::ServerAuthenticator"
        };

        public override bool ice_isA(string s, global::Ice.Current current = null)
        {
            return global::System.Array.BinarySearch(_ids, s, IceUtilInternal.StringUtil.OrdinalStringComparer) >= 0;
        }

        public override string[] ice_ids(global::Ice.Current current = null)
        {
            return _ids;
        }

        public override string ice_id(global::Ice.Current current = null)
        {
            return _ids[1];
        }

        public static new string ice_staticId()
        {
            return _ids[1];
        }

        #endregion

        #region Operation dispatch

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_authenticate(ServerAuthenticator obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            string iceP_pw;
            byte[][] iceP_certificates;
            string iceP_certhash;
            bool iceP_certstrong;
            iceP_name = istr.readString();
            iceP_pw = istr.readString();
            iceP_certificates = CertificateListHelper.read(istr);
            iceP_certhash = istr.readString();
            iceP_certstrong = istr.readBool();
            inS.endReadParams();
            string iceP_newname;
            string[] iceP_groups;
            var ret = obj.authenticate(iceP_name, iceP_pw, iceP_certificates, iceP_certhash, iceP_certstrong, out iceP_newname, out iceP_groups, current);
            var ostr = inS.startWriteParams();
            ostr.writeString(iceP_newname);
            GroupNameListHelper.write(ostr, iceP_groups);
            ostr.writeInt(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getInfo(ServerAuthenticator obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_id;
            iceP_id = istr.readInt();
            inS.endReadParams();
            global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info;
            var ret = obj.getInfo(iceP_id, out iceP_info, current);
            var ostr = inS.startWriteParams();
            UserInfoMapHelper.write(ostr, iceP_info);
            ostr.writeBool(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_nameToId(ServerAuthenticator obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            iceP_name = istr.readString();
            inS.endReadParams();
            var ret = obj.nameToId(iceP_name, current);
            var ostr = inS.startWriteParams();
            ostr.writeInt(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_idToName(ServerAuthenticator obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_id;
            iceP_id = istr.readInt();
            inS.endReadParams();
            var ret = obj.idToName(iceP_id, current);
            var ostr = inS.startWriteParams();
            ostr.writeString(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_idToTexture(ServerAuthenticator obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_id;
            iceP_id = istr.readInt();
            inS.endReadParams();
            var ret = obj.idToTexture(iceP_id, current);
            var ostr = inS.startWriteParams();
            TextureHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        private static readonly string[] _all =
        {
            "authenticate",
            "getInfo",
            "ice_id",
            "ice_ids",
            "ice_isA",
            "ice_ping",
            "idToName",
            "idToTexture",
            "nameToId"
        };

        public override global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceDispatch(global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            int pos = global::System.Array.BinarySearch(_all, current.operation, global::IceUtilInternal.StringUtil.OrdinalStringComparer);
            if(pos < 0)
            {
                throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
            }

            switch(pos)
            {
                case 0:
                {
                    return iceD_authenticate(this, inS, current);
                }
                case 1:
                {
                    return iceD_getInfo(this, inS, current);
                }
                case 2:
                {
                    return global::Ice.ObjectImpl.iceD_ice_id(this, inS, current);
                }
                case 3:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ids(this, inS, current);
                }
                case 4:
                {
                    return global::Ice.ObjectImpl.iceD_ice_isA(this, inS, current);
                }
                case 5:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ping(this, inS, current);
                }
                case 6:
                {
                    return iceD_idToName(this, inS, current);
                }
                case 7:
                {
                    return iceD_idToTexture(this, inS, current);
                }
                case 8:
                {
                    return iceD_nameToId(this, inS, current);
                }
            }

            global::System.Diagnostics.Debug.Assert(false);
            throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class ServerUpdatingAuthenticatorDisp_ : global::Ice.ObjectImpl, ServerUpdatingAuthenticator
    {
        #region Slice operations

        public abstract int registerUser(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.Current current = null);

        public abstract int unregisterUser(int id, global::Ice.Current current = null);

        public abstract global::System.Collections.Generic.Dictionary<int, string> getRegisteredUsers(string filter, global::Ice.Current current = null);

        public abstract int setInfo(int id, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.Current current = null);

        public abstract int setTexture(int id, byte[] tex, global::Ice.Current current = null);

        #endregion

        #region Inherited Slice operations

        public abstract int authenticate(string name, string pw, byte[][] certificates, string certhash, bool certstrong, out string newname, out string[] groups, global::Ice.Current current = null);

        public abstract bool getInfo(int id, out global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.Current current = null);

        public abstract string idToName(int id, global::Ice.Current current = null);

        public abstract byte[] idToTexture(int id, global::Ice.Current current = null);

        public abstract int nameToId(string name, global::Ice.Current current = null);

        #endregion

        #region Slice type-related members

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::Murmur::ServerAuthenticator",
            "::Murmur::ServerUpdatingAuthenticator"
        };

        public override bool ice_isA(string s, global::Ice.Current current = null)
        {
            return global::System.Array.BinarySearch(_ids, s, IceUtilInternal.StringUtil.OrdinalStringComparer) >= 0;
        }

        public override string[] ice_ids(global::Ice.Current current = null)
        {
            return _ids;
        }

        public override string ice_id(global::Ice.Current current = null)
        {
            return _ids[2];
        }

        public static new string ice_staticId()
        {
            return _ids[2];
        }

        #endregion

        #region Operation dispatch

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_registerUser(ServerUpdatingAuthenticator obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info;
            iceP_info = UserInfoMapHelper.read(istr);
            inS.endReadParams();
            var ret = obj.registerUser(iceP_info, current);
            var ostr = inS.startWriteParams();
            ostr.writeInt(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_unregisterUser(ServerUpdatingAuthenticator obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            int iceP_id;
            iceP_id = istr.readInt();
            inS.endReadParams();
            var ret = obj.unregisterUser(iceP_id, current);
            var ostr = inS.startWriteParams();
            ostr.writeInt(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getRegisteredUsers(ServerUpdatingAuthenticator obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_filter;
            iceP_filter = istr.readString();
            inS.endReadParams();
            var ret = obj.getRegisteredUsers(iceP_filter, current);
            var ostr = inS.startWriteParams();
            NameMapHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_setInfo(ServerUpdatingAuthenticator obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_id;
            global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info;
            iceP_id = istr.readInt();
            iceP_info = UserInfoMapHelper.read(istr);
            inS.endReadParams();
            var ret = obj.setInfo(iceP_id, iceP_info, current);
            var ostr = inS.startWriteParams();
            ostr.writeInt(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_setTexture(ServerUpdatingAuthenticator obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_id;
            byte[] iceP_tex;
            iceP_id = istr.readInt();
            iceP_tex = TextureHelper.read(istr);
            inS.endReadParams();
            var ret = obj.setTexture(iceP_id, iceP_tex, current);
            var ostr = inS.startWriteParams();
            ostr.writeInt(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        private static readonly string[] _all =
        {
            "authenticate",
            "getInfo",
            "getRegisteredUsers",
            "ice_id",
            "ice_ids",
            "ice_isA",
            "ice_ping",
            "idToName",
            "idToTexture",
            "nameToId",
            "registerUser",
            "setInfo",
            "setTexture",
            "unregisterUser"
        };

        public override global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceDispatch(global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            int pos = global::System.Array.BinarySearch(_all, current.operation, global::IceUtilInternal.StringUtil.OrdinalStringComparer);
            if(pos < 0)
            {
                throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
            }

            switch(pos)
            {
                case 0:
                {
                    return ServerAuthenticatorDisp_.iceD_authenticate(this, inS, current);
                }
                case 1:
                {
                    return ServerAuthenticatorDisp_.iceD_getInfo(this, inS, current);
                }
                case 2:
                {
                    return iceD_getRegisteredUsers(this, inS, current);
                }
                case 3:
                {
                    return global::Ice.ObjectImpl.iceD_ice_id(this, inS, current);
                }
                case 4:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ids(this, inS, current);
                }
                case 5:
                {
                    return global::Ice.ObjectImpl.iceD_ice_isA(this, inS, current);
                }
                case 6:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ping(this, inS, current);
                }
                case 7:
                {
                    return ServerAuthenticatorDisp_.iceD_idToName(this, inS, current);
                }
                case 8:
                {
                    return ServerAuthenticatorDisp_.iceD_idToTexture(this, inS, current);
                }
                case 9:
                {
                    return ServerAuthenticatorDisp_.iceD_nameToId(this, inS, current);
                }
                case 10:
                {
                    return iceD_registerUser(this, inS, current);
                }
                case 11:
                {
                    return iceD_setInfo(this, inS, current);
                }
                case 12:
                {
                    return iceD_setTexture(this, inS, current);
                }
                case 13:
                {
                    return iceD_unregisterUser(this, inS, current);
                }
            }

            global::System.Diagnostics.Debug.Assert(false);
            throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class ServerDisp_ : global::Ice.ObjectImpl, Server
    {
        #region Slice operations

        public abstract global::System.Threading.Tasks.Task<bool> isRunningAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task startAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task stopAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task deleteAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<int> idAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task addCallbackAsync(ServerCallbackPrx cb, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task removeCallbackAsync(ServerCallbackPrx cb, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task setAuthenticatorAsync(ServerAuthenticatorPrx auth, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<string> getConfAsync(string key, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, string>> getAllConfAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task setConfAsync(string key, string value, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task setSuperuserPasswordAsync(string pw, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<LogEntry[]> getLogAsync(int first, int last, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<int> getLogLenAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, User>> getUsersAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, Channel>> getChannelsAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<byte[][]> getCertificateListAsync(int session, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<Tree> getTreeAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<Ban[]> getBansAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task setBansAsync(Ban[] bans, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task kickUserAsync(int session, string reason, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<User> getStateAsync(int session, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task setStateAsync(User state, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task sendMessageAsync(int session, string text, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<bool> hasPermissionAsync(int session, int channelid, int perm, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<int> effectivePermissionsAsync(int session, int channelid, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task addContextCallbackAsync(int session, string action, string text, ServerContextCallbackPrx cb, int ctx, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task removeContextCallbackAsync(ServerContextCallbackPrx cb, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<Channel> getChannelStateAsync(int channelid, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task setChannelStateAsync(Channel state, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task removeChannelAsync(int channelid, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<int> addChannelAsync(string name, int parent, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task sendMessageChannelAsync(int channelid, bool tree, string text, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<Server_GetACLResult> getACLAsync(int channelid, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task setACLAsync(int channelid, ACL[] acls, Group[] groups, bool inherit, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task addUserToGroupAsync(int channelid, int session, string group, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task removeUserFromGroupAsync(int channelid, int session, string group, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task redirectWhisperGroupAsync(int session, string source, string target, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, string>> getUserNamesAsync(int[] ids, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, int>> getUserIdsAsync(string[] names, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<int> registerUserAsync(global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task unregisterUserAsync(int userid, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task updateRegistrationAsync(int userid, global::System.Collections.Generic.Dictionary<UserInfo, string> info, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<UserInfo, string>> getRegistrationAsync(int userid, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<int, string>> getRegisteredUsersAsync(string filter, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<int> verifyPasswordAsync(string name, string pw, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<byte[]> getTextureAsync(int userid, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task setTextureAsync(int userid, byte[] tex, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<int> getUptimeAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task updateCertificateAsync(string certificate, string privateKey, string passphrase, global::Ice.Current current = null);

        #endregion

        #region Slice type-related members

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::Murmur::Server"
        };

        public override bool ice_isA(string s, global::Ice.Current current = null)
        {
            return global::System.Array.BinarySearch(_ids, s, IceUtilInternal.StringUtil.OrdinalStringComparer) >= 0;
        }

        public override string[] ice_ids(global::Ice.Current current = null)
        {
            return _ids;
        }

        public override string ice_id(global::Ice.Current current = null)
        {
            return _ids[1];
        }

        public static new string ice_staticId()
        {
            return _ids[1];
        }

        #endregion

        #region Operation dispatch

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_isRunning(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<bool>(obj.isRunningAsync(current),
                (ostr, ret) =>
                {
                    ostr.writeBool(ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_start(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask(obj.startAsync(current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_stop(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask(obj.stopAsync(current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_delete(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask(obj.deleteAsync(current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_id(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<int>(obj.idAsync(current),
                (ostr, ret) =>
                {
                    ostr.writeInt(ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_addCallback(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            ServerCallbackPrx iceP_cb;
            iceP_cb = ServerCallbackPrxHelper.read(istr);
            inS.endReadParams();
            return inS.setResultTask(obj.addCallbackAsync(iceP_cb, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_removeCallback(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            ServerCallbackPrx iceP_cb;
            iceP_cb = ServerCallbackPrxHelper.read(istr);
            inS.endReadParams();
            return inS.setResultTask(obj.removeCallbackAsync(iceP_cb, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_setAuthenticator(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            ServerAuthenticatorPrx iceP_auth;
            iceP_auth = ServerAuthenticatorPrxHelper.read(istr);
            inS.endReadParams();
            return inS.setResultTask(obj.setAuthenticatorAsync(iceP_auth, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getConf(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_key;
            iceP_key = istr.readString();
            inS.endReadParams();
            return inS.setResultTask<string>(obj.getConfAsync(iceP_key, current),
                (ostr, ret) =>
                {
                    ostr.writeString(ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getAllConf(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<global::System.Collections.Generic.Dictionary<string, string>>(obj.getAllConfAsync(current),
                (ostr, ret) =>
                {
                    ConfigMapHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_setConf(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_key;
            string iceP_value;
            iceP_key = istr.readString();
            iceP_value = istr.readString();
            inS.endReadParams();
            return inS.setResultTask(obj.setConfAsync(iceP_key, iceP_value, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_setSuperuserPassword(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_pw;
            iceP_pw = istr.readString();
            inS.endReadParams();
            return inS.setResultTask(obj.setSuperuserPasswordAsync(iceP_pw, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getLog(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_first;
            int iceP_last;
            iceP_first = istr.readInt();
            iceP_last = istr.readInt();
            inS.endReadParams();
            return inS.setResultTask<LogEntry[]>(obj.getLogAsync(iceP_first, iceP_last, current),
                (ostr, ret) =>
                {
                    LogListHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getLogLen(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<int>(obj.getLogLenAsync(current),
                (ostr, ret) =>
                {
                    ostr.writeInt(ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getUsers(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<global::System.Collections.Generic.Dictionary<int, User>>(obj.getUsersAsync(current),
                (ostr, ret) =>
                {
                    UserMapHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getChannels(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<global::System.Collections.Generic.Dictionary<int, Channel>>(obj.getChannelsAsync(current),
                (ostr, ret) =>
                {
                    ChannelMapHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getCertificateList(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_session;
            iceP_session = istr.readInt();
            inS.endReadParams();
            return inS.setResultTask<byte[][]>(obj.getCertificateListAsync(iceP_session, current),
                (ostr, ret) =>
                {
                    CertificateListHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getTree(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<Tree>(obj.getTreeAsync(current),
                (ostr, ret) =>
                {
                    ostr.writeValue(ret);
                    ostr.writePendingValues();
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getBans(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<Ban[]>(obj.getBansAsync(current),
                (ostr, ret) =>
                {
                    BanListHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_setBans(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            Ban[] iceP_bans;
            iceP_bans = BanListHelper.read(istr);
            inS.endReadParams();
            return inS.setResultTask(obj.setBansAsync(iceP_bans, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_kickUser(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            int iceP_session;
            string iceP_reason;
            iceP_session = istr.readInt();
            iceP_reason = istr.readString();
            inS.endReadParams();
            return inS.setResultTask(obj.kickUserAsync(iceP_session, iceP_reason, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getState(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_session;
            iceP_session = istr.readInt();
            inS.endReadParams();
            return inS.setResultTask<User>(obj.getStateAsync(iceP_session, current),
                (ostr, ret) =>
                {
                    User.ice_write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_setState(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            User iceP_state;
            iceP_state = null;
            iceP_state = User.ice_read(istr);
            inS.endReadParams();
            return inS.setResultTask(obj.setStateAsync(iceP_state, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_sendMessage(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            int iceP_session;
            string iceP_text;
            iceP_session = istr.readInt();
            iceP_text = istr.readString();
            inS.endReadParams();
            return inS.setResultTask(obj.sendMessageAsync(iceP_session, iceP_text, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_hasPermission(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            int iceP_session;
            int iceP_channelid;
            int iceP_perm;
            iceP_session = istr.readInt();
            iceP_channelid = istr.readInt();
            iceP_perm = istr.readInt();
            inS.endReadParams();
            return inS.setResultTask<bool>(obj.hasPermissionAsync(iceP_session, iceP_channelid, iceP_perm, current),
                (ostr, ret) =>
                {
                    ostr.writeBool(ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_effectivePermissions(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_session;
            int iceP_channelid;
            iceP_session = istr.readInt();
            iceP_channelid = istr.readInt();
            inS.endReadParams();
            return inS.setResultTask<int>(obj.effectivePermissionsAsync(iceP_session, iceP_channelid, current),
                (ostr, ret) =>
                {
                    ostr.writeInt(ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_addContextCallback(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            int iceP_session;
            string iceP_action;
            string iceP_text;
            ServerContextCallbackPrx iceP_cb;
            int iceP_ctx;
            iceP_session = istr.readInt();
            iceP_action = istr.readString();
            iceP_text = istr.readString();
            iceP_cb = ServerContextCallbackPrxHelper.read(istr);
            iceP_ctx = istr.readInt();
            inS.endReadParams();
            return inS.setResultTask(obj.addContextCallbackAsync(iceP_session, iceP_action, iceP_text, iceP_cb, iceP_ctx, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_removeContextCallback(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            ServerContextCallbackPrx iceP_cb;
            iceP_cb = ServerContextCallbackPrxHelper.read(istr);
            inS.endReadParams();
            return inS.setResultTask(obj.removeContextCallbackAsync(iceP_cb, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getChannelState(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_channelid;
            iceP_channelid = istr.readInt();
            inS.endReadParams();
            return inS.setResultTask<Channel>(obj.getChannelStateAsync(iceP_channelid, current),
                (ostr, ret) =>
                {
                    Channel.ice_write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_setChannelState(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            Channel iceP_state;
            iceP_state = null;
            iceP_state = Channel.ice_read(istr);
            inS.endReadParams();
            return inS.setResultTask(obj.setChannelStateAsync(iceP_state, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_removeChannel(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            int iceP_channelid;
            iceP_channelid = istr.readInt();
            inS.endReadParams();
            return inS.setResultTask(obj.removeChannelAsync(iceP_channelid, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_addChannel(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            int iceP_parent;
            iceP_name = istr.readString();
            iceP_parent = istr.readInt();
            inS.endReadParams();
            return inS.setResultTask<int>(obj.addChannelAsync(iceP_name, iceP_parent, current),
                (ostr, ret) =>
                {
                    ostr.writeInt(ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_sendMessageChannel(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            int iceP_channelid;
            bool iceP_tree;
            string iceP_text;
            iceP_channelid = istr.readInt();
            iceP_tree = istr.readBool();
            iceP_text = istr.readString();
            inS.endReadParams();
            return inS.setResultTask(obj.sendMessageChannelAsync(iceP_channelid, iceP_tree, iceP_text, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getACL(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_channelid;
            iceP_channelid = istr.readInt();
            inS.endReadParams();
            return inS.setResultTask<Server_GetACLResult>(obj.getACLAsync(iceP_channelid, current),
                (ostr, ret) =>
                {
                    ACLListHelper.write(ostr, ret.acls);
                    GroupListHelper.write(ostr, ret.groups);
                    ostr.writeBool(ret.inherit);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_setACL(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_channelid;
            ACL[] iceP_acls;
            Group[] iceP_groups;
            bool iceP_inherit;
            iceP_channelid = istr.readInt();
            iceP_acls = ACLListHelper.read(istr);
            iceP_groups = GroupListHelper.read(istr);
            iceP_inherit = istr.readBool();
            inS.endReadParams();
            return inS.setResultTask(obj.setACLAsync(iceP_channelid, iceP_acls, iceP_groups, iceP_inherit, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_addUserToGroup(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_channelid;
            int iceP_session;
            string iceP_group;
            iceP_channelid = istr.readInt();
            iceP_session = istr.readInt();
            iceP_group = istr.readString();
            inS.endReadParams();
            return inS.setResultTask(obj.addUserToGroupAsync(iceP_channelid, iceP_session, iceP_group, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_removeUserFromGroup(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_channelid;
            int iceP_session;
            string iceP_group;
            iceP_channelid = istr.readInt();
            iceP_session = istr.readInt();
            iceP_group = istr.readString();
            inS.endReadParams();
            return inS.setResultTask(obj.removeUserFromGroupAsync(iceP_channelid, iceP_session, iceP_group, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_redirectWhisperGroup(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_session;
            string iceP_source;
            string iceP_target;
            iceP_session = istr.readInt();
            iceP_source = istr.readString();
            iceP_target = istr.readString();
            inS.endReadParams();
            return inS.setResultTask(obj.redirectWhisperGroupAsync(iceP_session, iceP_source, iceP_target, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getUserNames(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int[] iceP_ids;
            iceP_ids = IdListHelper.read(istr);
            inS.endReadParams();
            return inS.setResultTask<global::System.Collections.Generic.Dictionary<int, string>>(obj.getUserNamesAsync(iceP_ids, current),
                (ostr, ret) =>
                {
                    NameMapHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getUserIds(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string[] iceP_names;
            iceP_names = NameListHelper.read(istr);
            inS.endReadParams();
            return inS.setResultTask<global::System.Collections.Generic.Dictionary<string, int>>(obj.getUserIdsAsync(iceP_names, current),
                (ostr, ret) =>
                {
                    IdMapHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_registerUser(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info;
            iceP_info = UserInfoMapHelper.read(istr);
            inS.endReadParams();
            return inS.setResultTask<int>(obj.registerUserAsync(iceP_info, current),
                (ostr, ret) =>
                {
                    ostr.writeInt(ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_unregisterUser(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            int iceP_userid;
            iceP_userid = istr.readInt();
            inS.endReadParams();
            return inS.setResultTask(obj.unregisterUserAsync(iceP_userid, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_updateRegistration(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_userid;
            global::System.Collections.Generic.Dictionary<UserInfo, string> iceP_info;
            iceP_userid = istr.readInt();
            iceP_info = UserInfoMapHelper.read(istr);
            inS.endReadParams();
            return inS.setResultTask(obj.updateRegistrationAsync(iceP_userid, iceP_info, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getRegistration(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_userid;
            iceP_userid = istr.readInt();
            inS.endReadParams();
            return inS.setResultTask<global::System.Collections.Generic.Dictionary<UserInfo, string>>(obj.getRegistrationAsync(iceP_userid, current),
                (ostr, ret) =>
                {
                    UserInfoMapHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getRegisteredUsers(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_filter;
            iceP_filter = istr.readString();
            inS.endReadParams();
            return inS.setResultTask<global::System.Collections.Generic.Dictionary<int, string>>(obj.getRegisteredUsersAsync(iceP_filter, current),
                (ostr, ret) =>
                {
                    NameMapHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_verifyPassword(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            string iceP_pw;
            iceP_name = istr.readString();
            iceP_pw = istr.readString();
            inS.endReadParams();
            return inS.setResultTask<int>(obj.verifyPasswordAsync(iceP_name, iceP_pw, current),
                (ostr, ret) =>
                {
                    ostr.writeInt(ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getTexture(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_userid;
            iceP_userid = istr.readInt();
            inS.endReadParams();
            return inS.setResultTask<byte[]>(obj.getTextureAsync(iceP_userid, current),
                (ostr, ret) =>
                {
                    TextureHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_setTexture(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_userid;
            byte[] iceP_tex;
            iceP_userid = istr.readInt();
            iceP_tex = TextureHelper.read(istr);
            inS.endReadParams();
            return inS.setResultTask(obj.setTextureAsync(iceP_userid, iceP_tex, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getUptime(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<int>(obj.getUptimeAsync(current),
                (ostr, ret) =>
                {
                    ostr.writeInt(ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_updateCertificate(Server obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_certificate;
            string iceP_privateKey;
            string iceP_passphrase;
            iceP_certificate = istr.readString();
            iceP_privateKey = istr.readString();
            iceP_passphrase = istr.readString();
            inS.endReadParams();
            return inS.setResultTask(obj.updateCertificateAsync(iceP_certificate, iceP_privateKey, iceP_passphrase, current));
        }

        private static readonly string[] _all =
        {
            "addCallback",
            "addChannel",
            "addContextCallback",
            "addUserToGroup",
            "delete",
            "effectivePermissions",
            "getACL",
            "getAllConf",
            "getBans",
            "getCertificateList",
            "getChannelState",
            "getChannels",
            "getConf",
            "getLog",
            "getLogLen",
            "getRegisteredUsers",
            "getRegistration",
            "getState",
            "getTexture",
            "getTree",
            "getUptime",
            "getUserIds",
            "getUserNames",
            "getUsers",
            "hasPermission",
            "ice_id",
            "ice_ids",
            "ice_isA",
            "ice_ping",
            "id",
            "isRunning",
            "kickUser",
            "redirectWhisperGroup",
            "registerUser",
            "removeCallback",
            "removeChannel",
            "removeContextCallback",
            "removeUserFromGroup",
            "sendMessage",
            "sendMessageChannel",
            "setACL",
            "setAuthenticator",
            "setBans",
            "setChannelState",
            "setConf",
            "setState",
            "setSuperuserPassword",
            "setTexture",
            "start",
            "stop",
            "unregisterUser",
            "updateCertificate",
            "updateRegistration",
            "verifyPassword"
        };

        public override global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceDispatch(global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            int pos = global::System.Array.BinarySearch(_all, current.operation, global::IceUtilInternal.StringUtil.OrdinalStringComparer);
            if(pos < 0)
            {
                throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
            }

            switch(pos)
            {
                case 0:
                {
                    return iceD_addCallback(this, inS, current);
                }
                case 1:
                {
                    return iceD_addChannel(this, inS, current);
                }
                case 2:
                {
                    return iceD_addContextCallback(this, inS, current);
                }
                case 3:
                {
                    return iceD_addUserToGroup(this, inS, current);
                }
                case 4:
                {
                    return iceD_delete(this, inS, current);
                }
                case 5:
                {
                    return iceD_effectivePermissions(this, inS, current);
                }
                case 6:
                {
                    return iceD_getACL(this, inS, current);
                }
                case 7:
                {
                    return iceD_getAllConf(this, inS, current);
                }
                case 8:
                {
                    return iceD_getBans(this, inS, current);
                }
                case 9:
                {
                    return iceD_getCertificateList(this, inS, current);
                }
                case 10:
                {
                    return iceD_getChannelState(this, inS, current);
                }
                case 11:
                {
                    return iceD_getChannels(this, inS, current);
                }
                case 12:
                {
                    return iceD_getConf(this, inS, current);
                }
                case 13:
                {
                    return iceD_getLog(this, inS, current);
                }
                case 14:
                {
                    return iceD_getLogLen(this, inS, current);
                }
                case 15:
                {
                    return iceD_getRegisteredUsers(this, inS, current);
                }
                case 16:
                {
                    return iceD_getRegistration(this, inS, current);
                }
                case 17:
                {
                    return iceD_getState(this, inS, current);
                }
                case 18:
                {
                    return iceD_getTexture(this, inS, current);
                }
                case 19:
                {
                    return iceD_getTree(this, inS, current);
                }
                case 20:
                {
                    return iceD_getUptime(this, inS, current);
                }
                case 21:
                {
                    return iceD_getUserIds(this, inS, current);
                }
                case 22:
                {
                    return iceD_getUserNames(this, inS, current);
                }
                case 23:
                {
                    return iceD_getUsers(this, inS, current);
                }
                case 24:
                {
                    return iceD_hasPermission(this, inS, current);
                }
                case 25:
                {
                    return global::Ice.ObjectImpl.iceD_ice_id(this, inS, current);
                }
                case 26:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ids(this, inS, current);
                }
                case 27:
                {
                    return global::Ice.ObjectImpl.iceD_ice_isA(this, inS, current);
                }
                case 28:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ping(this, inS, current);
                }
                case 29:
                {
                    return iceD_id(this, inS, current);
                }
                case 30:
                {
                    return iceD_isRunning(this, inS, current);
                }
                case 31:
                {
                    return iceD_kickUser(this, inS, current);
                }
                case 32:
                {
                    return iceD_redirectWhisperGroup(this, inS, current);
                }
                case 33:
                {
                    return iceD_registerUser(this, inS, current);
                }
                case 34:
                {
                    return iceD_removeCallback(this, inS, current);
                }
                case 35:
                {
                    return iceD_removeChannel(this, inS, current);
                }
                case 36:
                {
                    return iceD_removeContextCallback(this, inS, current);
                }
                case 37:
                {
                    return iceD_removeUserFromGroup(this, inS, current);
                }
                case 38:
                {
                    return iceD_sendMessage(this, inS, current);
                }
                case 39:
                {
                    return iceD_sendMessageChannel(this, inS, current);
                }
                case 40:
                {
                    return iceD_setACL(this, inS, current);
                }
                case 41:
                {
                    return iceD_setAuthenticator(this, inS, current);
                }
                case 42:
                {
                    return iceD_setBans(this, inS, current);
                }
                case 43:
                {
                    return iceD_setChannelState(this, inS, current);
                }
                case 44:
                {
                    return iceD_setConf(this, inS, current);
                }
                case 45:
                {
                    return iceD_setState(this, inS, current);
                }
                case 46:
                {
                    return iceD_setSuperuserPassword(this, inS, current);
                }
                case 47:
                {
                    return iceD_setTexture(this, inS, current);
                }
                case 48:
                {
                    return iceD_start(this, inS, current);
                }
                case 49:
                {
                    return iceD_stop(this, inS, current);
                }
                case 50:
                {
                    return iceD_unregisterUser(this, inS, current);
                }
                case 51:
                {
                    return iceD_updateCertificate(this, inS, current);
                }
                case 52:
                {
                    return iceD_updateRegistration(this, inS, current);
                }
                case 53:
                {
                    return iceD_verifyPassword(this, inS, current);
                }
            }

            global::System.Diagnostics.Debug.Assert(false);
            throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class MetaCallbackDisp_ : global::Ice.ObjectImpl, MetaCallback
    {
        #region Slice operations

        public abstract void started(ServerPrx srv, global::Ice.Current current = null);

        public abstract void stopped(ServerPrx srv, global::Ice.Current current = null);

        #endregion

        #region Slice type-related members

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::Murmur::MetaCallback"
        };

        public override bool ice_isA(string s, global::Ice.Current current = null)
        {
            return global::System.Array.BinarySearch(_ids, s, IceUtilInternal.StringUtil.OrdinalStringComparer) >= 0;
        }

        public override string[] ice_ids(global::Ice.Current current = null)
        {
            return _ids;
        }

        public override string ice_id(global::Ice.Current current = null)
        {
            return _ids[1];
        }

        public static new string ice_staticId()
        {
            return _ids[1];
        }

        #endregion

        #region Operation dispatch

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_started(MetaCallback obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            ServerPrx iceP_srv;
            iceP_srv = ServerPrxHelper.read(istr);
            inS.endReadParams();
            obj.started(iceP_srv, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_stopped(MetaCallback obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            ServerPrx iceP_srv;
            iceP_srv = ServerPrxHelper.read(istr);
            inS.endReadParams();
            obj.stopped(iceP_srv, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        private static readonly string[] _all =
        {
            "ice_id",
            "ice_ids",
            "ice_isA",
            "ice_ping",
            "started",
            "stopped"
        };

        public override global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceDispatch(global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            int pos = global::System.Array.BinarySearch(_all, current.operation, global::IceUtilInternal.StringUtil.OrdinalStringComparer);
            if(pos < 0)
            {
                throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
            }

            switch(pos)
            {
                case 0:
                {
                    return global::Ice.ObjectImpl.iceD_ice_id(this, inS, current);
                }
                case 1:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ids(this, inS, current);
                }
                case 2:
                {
                    return global::Ice.ObjectImpl.iceD_ice_isA(this, inS, current);
                }
                case 3:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ping(this, inS, current);
                }
                case 4:
                {
                    return iceD_started(this, inS, current);
                }
                case 5:
                {
                    return iceD_stopped(this, inS, current);
                }
            }

            global::System.Diagnostics.Debug.Assert(false);
            throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class MetaDisp_ : global::Ice.ObjectImpl, Meta
    {
        #region Slice operations

        public abstract global::System.Threading.Tasks.Task<ServerPrx> getServerAsync(int id, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<ServerPrx> newServerAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<ServerPrx[]> getBootedServersAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<ServerPrx[]> getAllServersAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, string>> getDefaultConfAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<Meta_GetVersionResult> getVersionAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task addCallbackAsync(MetaCallbackPrx cb, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task removeCallbackAsync(MetaCallbackPrx cb, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<int> getUptimeAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<string> getSliceAsync(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<global::System.Collections.Generic.Dictionary<string, string>> getSliceChecksumsAsync(global::Ice.Current current = null);

        #endregion

        #region Slice type-related members

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::Murmur::Meta"
        };

        public override bool ice_isA(string s, global::Ice.Current current = null)
        {
            return global::System.Array.BinarySearch(_ids, s, IceUtilInternal.StringUtil.OrdinalStringComparer) >= 0;
        }

        public override string[] ice_ids(global::Ice.Current current = null)
        {
            return _ids;
        }

        public override string ice_id(global::Ice.Current current = null)
        {
            return _ids[1];
        }

        public static new string ice_staticId()
        {
            return _ids[1];
        }

        #endregion

        #region Operation dispatch

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getServer(Meta obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_id;
            iceP_id = istr.readInt();
            inS.endReadParams();
            return inS.setResultTask<ServerPrx>(obj.getServerAsync(iceP_id, current),
                (ostr, ret) =>
                {
                    ServerPrxHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_newServer(Meta obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<ServerPrx>(obj.newServerAsync(current),
                (ostr, ret) =>
                {
                    ServerPrxHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getBootedServers(Meta obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<ServerPrx[]>(obj.getBootedServersAsync(current),
                (ostr, ret) =>
                {
                    ServerListHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getAllServers(Meta obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<ServerPrx[]>(obj.getAllServersAsync(current),
                (ostr, ret) =>
                {
                    ServerListHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getDefaultConf(Meta obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<global::System.Collections.Generic.Dictionary<string, string>>(obj.getDefaultConfAsync(current),
                (ostr, ret) =>
                {
                    ConfigMapHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getVersion(Meta obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<Meta_GetVersionResult>(obj.getVersionAsync(current),
                (ostr, ret) =>
                {
                    ostr.writeInt(ret.major);
                    ostr.writeInt(ret.minor);
                    ostr.writeInt(ret.patch);
                    ostr.writeString(ret.text);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_addCallback(Meta obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            MetaCallbackPrx iceP_cb;
            iceP_cb = MetaCallbackPrxHelper.read(istr);
            inS.endReadParams();
            return inS.setResultTask(obj.addCallbackAsync(iceP_cb, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_removeCallback(Meta obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            MetaCallbackPrx iceP_cb;
            iceP_cb = MetaCallbackPrxHelper.read(istr);
            inS.endReadParams();
            return inS.setResultTask(obj.removeCallbackAsync(iceP_cb, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getUptime(Meta obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<int>(obj.getUptimeAsync(current),
                (ostr, ret) =>
                {
                    ostr.writeInt(ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getSlice(Meta obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<string>(obj.getSliceAsync(current),
                (ostr, ret) =>
                {
                    ostr.writeString(ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getSliceChecksums(Meta obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            return inS.setResultTask<global::System.Collections.Generic.Dictionary<string, string>>(obj.getSliceChecksumsAsync(current),
                (ostr, ret) =>
                {
                    global::Ice.SliceChecksumDictHelper.write(ostr, ret);
                });
        }

        private static readonly string[] _all =
        {
            "addCallback",
            "getAllServers",
            "getBootedServers",
            "getDefaultConf",
            "getServer",
            "getSlice",
            "getSliceChecksums",
            "getUptime",
            "getVersion",
            "ice_id",
            "ice_ids",
            "ice_isA",
            "ice_ping",
            "newServer",
            "removeCallback"
        };

        public override global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceDispatch(global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            int pos = global::System.Array.BinarySearch(_all, current.operation, global::IceUtilInternal.StringUtil.OrdinalStringComparer);
            if(pos < 0)
            {
                throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
            }

            switch(pos)
            {
                case 0:
                {
                    return iceD_addCallback(this, inS, current);
                }
                case 1:
                {
                    return iceD_getAllServers(this, inS, current);
                }
                case 2:
                {
                    return iceD_getBootedServers(this, inS, current);
                }
                case 3:
                {
                    return iceD_getDefaultConf(this, inS, current);
                }
                case 4:
                {
                    return iceD_getServer(this, inS, current);
                }
                case 5:
                {
                    return iceD_getSlice(this, inS, current);
                }
                case 6:
                {
                    return iceD_getSliceChecksums(this, inS, current);
                }
                case 7:
                {
                    return iceD_getUptime(this, inS, current);
                }
                case 8:
                {
                    return iceD_getVersion(this, inS, current);
                }
                case 9:
                {
                    return global::Ice.ObjectImpl.iceD_ice_id(this, inS, current);
                }
                case 10:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ids(this, inS, current);
                }
                case 11:
                {
                    return global::Ice.ObjectImpl.iceD_ice_isA(this, inS, current);
                }
                case 12:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ping(this, inS, current);
                }
                case 13:
                {
                    return iceD_newServer(this, inS, current);
                }
                case 14:
                {
                    return iceD_removeCallback(this, inS, current);
                }
            }

            global::System.Diagnostics.Debug.Assert(false);
            throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        #endregion
    }
}
